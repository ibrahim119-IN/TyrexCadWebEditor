
==== FILE: index.html ====

<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TyrexWebCad - Ù†Ø¸Ø§Ù… ØªØµÙ…ÙŠÙ… Ø¨Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨</title>
    
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="stylesheet" href="./src/styles/main.css">
    
    <!-- ØªØ­Ù…ÙŠÙ„ OpenCASCADE Ù…Ù† CDN -->
   
</head>
<body>
    <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-container">
            <div class="loading-logo">
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <rect x="10" y="10" width="80" height="80" fill="none" stroke="#2196F3" stroke-width="2"/>
                    <line x1="10" y1="50" x2="90" y2="50" stroke="#2196F3" stroke-width="2"/>
                    <line x1="50" y1="10" x2="50" y2="90" stroke="#2196F3" stroke-width="2"/>
                    <circle cx="50" cy="50" r="20" fill="none" stroke="#2196F3" stroke-width="2"/>
                </svg>
            </div>
            <h1 class="loading-title">TyrexWebCad</h1>
            <p class="loading-subtitle">Ù†Ø¸Ø§Ù… ØªØµÙ…ÙŠÙ… Ù…ØªÙƒØ§Ù…Ù„ Ø¨Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø­Ø§Ø³ÙˆØ¨</p>
            
            <div class="loading-progress-container">
                <div id="loading-progress" class="loading-progress"></div>
            </div>
            <p id="loading-text" class="loading-text">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</p>
        </div>
    </div>
    
    <!-- Ø§Ù„Ø­Ø§ÙˆÙŠ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„ØªØ·Ø¨ÙŠÙ‚ -->
    <div id="app" class="app-container" style="display: none;">
        <!-- Ø­Ø§ÙˆÙŠ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ (Viewer) -->
        <div id="viewer-container" class="viewer-container"></div>
        
        <!-- Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ -->
        <div id="toolbar" class="toolbar">
            <div class="toolbar-group">
                <button id="btn-new" class="toolbar-btn" title="Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                        <polyline points="14 2 14 8 20 8"/>
                        <line x1="12" y1="18" x2="12" y2="12"/>
                        <line x1="9" y1="15" x2="15" y2="15"/>
                    </svg>
                    Ø¬Ø¯ÙŠØ¯
                </button>
                <button id="btn-open" class="toolbar-btn" title="ÙØªØ­ Ù…Ø´Ø±ÙˆØ¹">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                    </svg>
                    ÙØªØ­
                </button>
                <button id="btn-save" class="toolbar-btn" title="Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    Ø­ÙØ¸
                </button>
            </div>
            
            <div class="toolbar-separator"></div>
            
            <div class="toolbar-group">
                <button id="btn-2d-view" class="toolbar-btn active" title="Ø§Ù„Ø¹Ø±Ø¶ Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <line x1="3" y1="9" x2="21" y2="9"/>
                        <line x1="9" y1="21" x2="9" y2="9"/>
                    </svg>
                    2D
                </button>
                <button id="btn-3d-view" class="toolbar-btn" title="Ø§Ù„Ø¹Ø±Ø¶ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 2l-7 7v10h14V9l-7-7z"/>
                        <polyline points="2 12 12 2 22 12"/>
                    </svg>
                    3D
                </button>
            </div>
            
            <div class="toolbar-separator"></div>
            
            <div class="toolbar-group" id="drawing-tools">
                <button id="tool-select" class="toolbar-btn active" title="Ø£Ø¯Ø§Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M4 4l7 7-7 7z"/>
                    </svg>
                </button>
                <button id="tool-line" class="toolbar-btn" title="Ø±Ø³Ù… Ø®Ø·">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <line x1="5" y1="19" x2="19" y2="5"/>
                    </svg>
                </button>
                <button id="tool-circle" class="toolbar-btn" title="Ø±Ø³Ù… Ø¯Ø§Ø¦Ø±Ø©">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <circle cx="12" cy="12" r="10"/>
                    </svg>
                </button>
                <button id="tool-rectangle" class="toolbar-btn" title="Ø±Ø³Ù… Ù…Ø³ØªØ·ÙŠÙ„">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="3" y="3" width="18" height="18"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-separator"></div>
            
            <div class="toolbar-group">
                <button id="btn-undo" class="toolbar-btn" title="ØªØ±Ø§Ø¬Ø¹ (Ctrl+Z)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <polyline points="1 4 1 10 7 10"/>
                        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
                    </svg>
                </button>
                <button id="btn-redo" class="toolbar-btn" title="Ø¥Ø¹Ø§Ø¯Ø© (Ctrl+Y)">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <polyline points="23 4 23 10 17 10"/>
                        <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"/>
                    </svg>
                </button>
            </div>
            
            <div class="toolbar-separator"></div>
            
            <div class="toolbar-group">
                <label class="toolbar-label">
                    <input type="checkbox" id="snap-to-grid" checked>
                    Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„Ø´Ø¨ÙƒØ©
                </label>
                <label class="toolbar-label">
                    Ø­Ø¬Ù… Ø§Ù„Ø´Ø¨ÙƒØ©:
                    <select id="grid-size">
                        <option value="0.5">0.5Ù…</option>
                        <option value="1" selected>1Ù…</option>
                        <option value="2">2Ù…</option>
                        <option value="5">5Ù…</option>
                    </select>
                </label>
            </div>
        </div>
        
        <!-- Ø§Ù„Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
        <div id="side-panels" class="side-panels">
            <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ø·Ø¨Ù‚Ø§Øª -->
            <div id="layers-panel" class="panel">
                <div class="panel-header">
                    <h3>Ø§Ù„Ø·Ø¨Ù‚Ø§Øª</h3>
                    <button class="panel-btn" title="Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø©">+</button>
                </div>
                <div class="panel-content" id="layers-list">
                    <!-- Ø³ØªØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø·Ø¨Ù‚Ø§Øª Ù‡Ù†Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ -->
                </div>
            </div>
            
            <!-- Ù„ÙˆØ­Ø© Ø§Ù„Ø®ØµØ§Ø¦Øµ -->
            <div id="properties-panel" class="panel">
                <div class="panel-header">
                    <h3>Ø§Ù„Ø®ØµØ§Ø¦Øµ</h3>
                </div>
                <div class="panel-content" id="properties-content">
                    <p class="panel-message">Ø­Ø¯Ø¯ ÙƒØ§Ø¦Ù†Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ø®ØµØ§Ø¦ØµÙ‡</p>
                </div>
            </div>
        </div>
        
        <!-- Ø´Ø±ÙŠØ· Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙÙ„ÙŠ -->
        <div id="status-bar" class="status-bar">
            <div class="status-item" id="cursor-position">X: 0.00, Y: 0.00</div>
            <div class="status-item" id="object-info"></div>
            <div class="status-item" id="status-message">Ø¬Ø§Ù‡Ø²</div>
        </div>
    </div>
    
    <!-- Ø³Ø·Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø± (Ù…Ø®ÙÙŠ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹) -->
    <div id="command-line" class="command-line" style="display: none;">
        <span class="command-prompt">Ø§Ù„Ø£Ù…Ø±:</span>
        <input type="text" id="command-input" class="command-input" placeholder="Ø§ÙƒØªØ¨ Ø£Ù…Ø±Ø§Ù‹...">
    </div>
    
    <!-- Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡ Ø§Ù„Ù…Ø®ØµØµØ© -->
    <div id="toast-container" class="toast-container"></div>
    
    <!-- Ù†Ù‚Ø·Ø© Ø¯Ø®ÙˆÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© -->
    <script type="module" src="./src/main.ts"></script>
</body>
</html>

==== FILE: package.json ====

{
  "name": "tyrex-web-cad",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "npm run setup && vite",
    "build": "npm run setup && tsc && vite build",
    "preview": "vite preview",
    "setup": "node setup.js",
    "setup:opencascade": "node setup.js"
  },
  "dependencies": {
    "opencascade.js": "^1.1.1",
    "three": "^0.177.0"
  },
  "devDependencies": {
    "@types/node": "^20.11.5",
    "@types/three": "^0.160.0",
    "typescript": "^5.8.3",
    "vite": "^5.4.19"
  }
}


==== FILE: setup.js ====

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const assetsDir = path.join(__dirname, 'public', 'assets', 'opencascade');
if (!fs.existsSync(assetsDir)) {
    fs.mkdirSync(assetsDir, { recursive: true });
}

const sourceDir = path.join(__dirname, 'node_modules', 'opencascade.js', 'dist');

if (fs.existsSync(sourceDir)) {
    const files = fs.readdirSync(sourceDir);
    files.forEach(file => {
        if (file.includes('opencascade') || file.endsWith('.wasm')) {
            const src = path.join(sourceDir, file);
            const dest = path.join(assetsDir, file);
            fs.copyFileSync(src, dest);
            console.log(`âœ“ ${file}`);
        }
    });
}

==== FILE: tsconfig.json ====

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

==== FILE: tsconfig.node.json ====

{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

==== FILE: vite.config.ts ====

import { defineConfig } from 'vite'

export default defineConfig({
  server: {
    port: 3000,
    open: true,
    host: true,
    headers: {
      // ØªØ®ÙÙŠÙ Ø³ÙŠØ§Ø³Ø© COEP Ù„Ù„ØªØ·ÙˆÙŠØ± Ø§Ù„Ù…Ø­Ù„ÙŠ
      // Ù„Ù„Ø¥Ù†ØªØ§Ø¬ØŒ Ø§Ø³ØªØ®Ø¯Ù…: 'require-corp' Ùˆ 'same-origin'
      'Cross-Origin-Embedder-Policy': 'credentialless',
      'Cross-Origin-Opener-Policy': 'same-origin',
    }
  },
  optimizeDeps: {
    exclude: ['opencascade.js']
  },
  publicDir: 'public',
  assetsInclude: ['**/*.wasm', '**/*.wasm.js'],
  build: {
    target: 'es2020',
    outDir: 'dist',
    assetsDir: 'assets',
    copyPublicDir: true,
    rollupOptions: {
      output: {
        manualChunks: {
          'three': ['three'],
          'opencascade': ['opencascade.js']
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  },
  define: {
    global: 'globalThis'
  },
  worker: {
    format: 'es'
  }
})

==== FILE: src\Commands\AddObjectCommand.ts ====

import { GeometricObject } from '../models/GeometricObject';
import { Command } from '../core/CommandManager';

export class AddObjectCommand implements Command {
    private object: GeometricObject;
    private viewer: any; // Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ÙˆØ¹ Ù„Ø§Ø­Ù‚Ø§Ù‹

    constructor(object: GeometricObject, viewer: any) {
        this.object = object;
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer.addGeometricObject(this.object);
    }

    undo(): void {
        this.viewer.removeGeometricObject(this.object.id);
    }

    getDescription(): string {
        return `Ø¥Ø¶Ø§ÙØ© ${this.object.type}: ${this.object.id}`;
    }
}

==== FILE: src\Commands\AddWallCommand.ts ====

import { Vector3 } from 'three';
import { Wall } from '../models/Wall';
import { Command } from '../core/CommandManager';


export class AddWallCommand implements Command {
    private wall: Wall;
    private viewer: any; // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù†ÙˆØ¹ Viewer

    constructor(start: Vector3, end: Vector3, viewer: any) {
        this.wall = new Wall(start, end);
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer.addWallDirect(this.wall);
    }

    undo(): void {
        this.viewer.removeWallDirect(this.wall.id);
    }
}

==== FILE: src\Commands\Command.ts ====



==== FILE: src\Commands\DeleteObjectCommand.ts ====


// src/Commands/DeleteObjectCommand.ts
import { Command } from '../core/CommandManager';
export class DeleteObjectCommand implements Command {
    execute(): void {}
    undo(): void {}
}


==== FILE: src\Commands\ModifyObjectCommand.ts ====

// src/Commands/ModifyObjectCommand.ts
import { Command } from '../core/CommandManager';
export class ModifyObjectCommand implements Command {
    execute(): void {}
    undo(): void {}
}

==== FILE: src\core\AdvancedGeometryEngine.ts ====

/**
 * AdvancedGeometryEngine - Ù…Ø­Ø±Ùƒ Ù‡Ù†Ø¯Ø³ÙŠ Ù…ØªØ·ÙˆØ± Ù„Ù…Ù†Ø§ÙØ³Ø© AutoCAD
 * ÙŠØ¯Ø¹Ù… OpenCASCADE Ù…Ø¹ Ø£Ø¯Ø§Ø¡ Ø¹Ø§Ù„ÙŠ ÙˆÙ…ÙˆØ«ÙˆÙ‚ÙŠØ©
 */

import { Logger } from './Logger';

// Types
export interface GeometryEngineConfig {
    useWebWorker?: boolean;
    wasmPath?: string;
    fallbackToMock?: boolean;
    maxRetries?: number;
    timeout?: number;
}

export class AdvancedGeometryEngine {
    private static instance: AdvancedGeometryEngine;
    private oc: any = null;
    private worker?: Worker;
    private initialized = false;
    private initPromise?: Promise<void>;
    private logger: Logger;
    private config: GeometryEngineConfig;
    
    private constructor(config: GeometryEngineConfig = {}) {
        this.logger = Logger.getInstance();
        this.config = {
            useWebWorker: false, // Ù„Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠ
            wasmPath: '/assets/opencascade/',
            fallbackToMock: true,
            maxRetries: 3,
            timeout: 30000,
            ...config
        };
    }

    public static getInstance(config?: GeometryEngineConfig): AdvancedGeometryEngine {
        if (!AdvancedGeometryEngine.instance) {
            AdvancedGeometryEngine.instance = new AdvancedGeometryEngine(config);
        }
        return AdvancedGeometryEngine.instance;
    }

    public async initialize(): Promise<void> {
        if (this.initialized) return;
        if (this.initPromise) return this.initPromise;

        this.initPromise = this._initialize();
        return this.initPromise;
    }

    private async _initialize(): Promise<void> {
        this.logger.info('ğŸš€ Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø§Ù„Ù…ØªØ·ÙˆØ±...');
        
        let lastError: Error | null = null;
        
        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ OpenCASCADE Ø¨Ø·Ø±Ù‚ Ù…ØªØ¹Ø¯Ø¯Ø©
        const loaders = [
            () => this.loadViaScript(),
            () => this.loadViaFetch(),
            () => this.loadFromCDN()
        ];

        for (const loader of loaders) {
            try {
                await loader();
                if (this.oc && this.validateOpenCascade()) {
                    this.initialized = true;
                    this.logger.info('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCASCADE Ø¨Ù†Ø¬Ø§Ø­');
                    return;
                }
            } catch (error) {
                lastError = error as Error;
                this.logger.warn(`Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ ÙØ§Ø´Ù„Ø©: ${error}`);
            }
        }

        // Fallback to mock if enabled
        if (this.config.fallbackToMock) {
            this.logger.warn('Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© ÙƒØ­Ù„ Ù…Ø¤Ù‚Øª');
            this.setupMockOpenCascade();
            this.initialized = true;
            return;
        }

        throw lastError || new Error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ OpenCASCADE');
    }

    private async loadViaScript(): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.type = 'module';
            
            // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„Ø°ÙŠ ÙŠØ­Ù…Ù„ OpenCASCADE
            script.textContent = `
                // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ OpenCASCADE Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø­Ù„ÙŠ
                let opencascade;
                
                try {
                    // Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ù†Ø³ÙˆØ®Ø© Ù…Ø­Ù„ÙŠØ§Ù‹
                    const response = await fetch('${this.config.wasmPath}opencascade.wasm.js');
                    if (!response.ok) throw new Error('Failed to fetch');
                    
                    const text = await response.text();
                    const modifiedText = text.replace(/export default/g, 'window.__OCModule =');
                    
                    const blob = new Blob([modifiedText], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    
                    await import(url);
                    opencascade = window.__OCModule;
                } catch (e) {
                    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
                    try {
                        const module = await import('${this.config.wasmPath}opencascade.wasm.js');
                        opencascade = module.default || module;
                    } catch (e2) {
                        console.error('Failed to load OpenCASCADE:', e2);
                    }
                }
                
                if (opencascade) {
                    window.__opencascadeFactory = opencascade;
                }
            `;

            script.onload = async () => {
                await new Promise(r => setTimeout(r, 500)); // Ø§Ù†ØªØ¸Ø§Ø± Ù‚ØµÙŠØ±
                
                const factory = (window as any).__opencascadeFactory;
                if (factory) {
                    try {
                        this.oc = await factory({
                            locateFile: (path: string) => `${this.config.wasmPath}${path}`
                        });
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                } else {
                    reject(new Error('OpenCASCADE factory not found'));
                }
            };

            script.onerror = () => reject(new Error('Script loading failed'));
            document.head.appendChild(script);
            
            // Timeout
            setTimeout(() => reject(new Error('Loading timeout')), this.config.timeout!);
        });
    }

    private async loadViaFetch(): Promise<void> {
        const response = await fetch(`${this.config.wasmPath}opencascade.wasm.js`);
        const text = await response.text();
        
        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù†Øµ Ù„Ø¥Ø²Ø§Ù„Ø© export
        const modifiedText = text
            .replace(/export\s+default\s+/g, 'window.__OCFactory = ')
            .replace(/export\s+{[^}]*}/g, '');
        
        // ØªÙ†ÙÙŠØ° Ø§Ù„ÙƒÙˆØ¯
        const scriptEl = document.createElement('script');
        scriptEl.textContent = modifiedText;
        document.head.appendChild(scriptEl);
        
        await new Promise(r => setTimeout(r, 100));
        
        const factory = (window as any).__OCFactory;
        if (!factory) throw new Error('Factory not found after fetch');
        
        this.oc = await factory({
            locateFile: (path: string) => `${this.config.wasmPath}${path}`
        });
    }

    private async loadFromCDN(): Promise<void> {
        // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ù† CDN ÙƒÙ€ fallback
        const cdnUrl = 'https://cdn.jsdelivr.net/npm/opencascade.js@latest/dist/opencascade.wasm.js';
        const script = document.createElement('script');
        script.src = cdnUrl;
        
        return new Promise((resolve, reject) => {
            script.onload = async () => {
                const factory = (window as any).opencascade || (window as any).OpenCascade;
                if (factory) {
                    this.oc = await factory();
                    resolve();
                } else {
                    reject(new Error('CDN load failed'));
                }
            };
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    private validateOpenCascade(): boolean {
        if (!this.oc) return false;
        
        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        const requiredFunctions = [
            'gp_Pnt_1', 'gp_Dir_1', 'gp_Vec_1',
            'BRepPrimAPI_MakeBox_2', 'BRepPrimAPI_MakeSphere_2'
        ];
        
        return requiredFunctions.every(fn => typeof this.oc[fn] === 'function');
    }

    private setupMockOpenCascade(): void {
        this.oc = {
            // Ù†Ù‚Ø·Ø©
            gp_Pnt_1: class MockPoint {
                private x = 0;
                private y = 0; 
                private z = 0;
                
                SetX(val: number) { this.x = val; }
                SetY(val: number) { this.y = val; }
                SetZ(val: number) { this.z = val; }
                X() { return this.x; }
                Y() { return this.y; }
                Z() { return this.z; }
                delete() {}
            },
            
            // Ø§ØªØ¬Ø§Ù‡
            gp_Dir_1: class MockDir {
                private x = 0;
                private y = 0;
                private z = 1;
                
                SetX(val: number) { this.x = val; }
                SetY(val: number) { this.y = val; }
                SetZ(val: number) { this.z = val; }
                delete() {}
            },
            
            // Ù…ØªØ¬Ù‡
            gp_Vec_1: class MockVec {
                private x = 0;
                private y = 0;
                private z = 0;
                
                SetX(val: number) { this.x = val; }
                SetY(val: number) { this.y = val; }
                SetZ(val: number) { this.z = val; }
                delete() {}
            },
            
            // Ù…Ø­Ø§ÙˆØ±
            gp_Ax2_2: class MockAx2 {
                constructor(_origin: any, _dir: any) {}
                delete() {}
            },
            
            gp_Ax1_2: class MockAx1 {
                constructor(_origin: any, _dir: any) {}
                delete() {}
            },
            
            // ØªØ­ÙˆÙŠÙ„Ø§Øª
            gp_Trsf_1: class MockTransform {
                SetTranslation_1() {}
                SetRotation_1() {}
                SetScale_1() {}
                delete() {}
            },
            
            // Ø¨Ù†Ø§Ø© Ø§Ù„Ø£Ø´ÙƒØ§Ù„
            BRepBuilderAPI_MakeVertex: class {
                constructor(_point: any) {}
                IsDone() { return true; }
                Vertex() { return { delete: () => {} }; }
            },
            
            BRepPrimAPI_MakeBox_2: class {
                constructor(_w: number, _h: number, _d: number) {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            BRepPrimAPI_MakeBox_3: class {
                constructor(_origin: any, _w: number, _h: number, _d: number) {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            BRepPrimAPI_MakeSphere_2: class {
                constructor(_center: any, _radius: number) {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            BRepPrimAPI_MakeCylinder_2: class {
                constructor(_axis: any, _radius: number, _height: number) {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            // Ø¹Ù…Ù„ÙŠØ§Øª Ø¨ÙˆÙ„ÙŠØ§Ù†ÙŠØ©
            BRepAlgoAPI_Fuse_1: class {
                constructor(_s1: any, _s2: any) {}
                Build() {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            BRepAlgoAPI_Cut_1: class {
                constructor(_s1: any, _s2: any) {}
                Build() {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            BRepAlgoAPI_Common_1: class {
                constructor(_s1: any, _s2: any) {}
                Build() {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            // Ø¨Ù†Ø§Ø© Ø£Ø®Ø±Ù‰
            GC_MakeSegment_1: class {
                constructor(_p1: any, _p2: any) {}
                IsDone() { return true; }
                Value() { return { delete: () => {} }; }
            },
            
            BRepBuilderAPI_MakeEdge_1: class {
                constructor(_p1: any, _p2: any) {}
                IsDone() { return true; }
                Edge() { return { delete: () => {} }; }
            },
            
            BRepBuilderAPI_MakeEdge_2: class {
                constructor(_curve: any) {}
                IsDone() { return true; }
                Edge() { return { delete: () => {} }; }
            },
            
            BRepBuilderAPI_MakeWire_1: class {
                Add_1() {}
                IsDone() { return true; }
                Wire() { return { delete: () => {} }; }
            },
            
            BRepBuilderAPI_MakeFace_2: class {
                constructor(_wire: any) {}
                IsDone() { return true; }
                Face() { return { delete: () => {} }; }
            },
            
            GC_MakeCircle_2: class {
                constructor(_axis: any, _radius: number) {}
                IsDone() { return true; }
                Value() { return { delete: () => {} }; }
            },
            
            BRepBuilderAPI_Transform_2: class {
                constructor(_shape: any, _transform: any) {}
                Build() {}
                IsDone() { return true; }
                Shape() { return { delete: () => {} }; }
            },
            
            // Ø£Ø¯ÙˆØ§Øª
            BRepMesh_IncrementalMesh_2: class {
                constructor(_shape: any, _deflection: number) {}
                Perform() {}
            },
            
            Bnd_Box_1: class {
                IsVoid() { return false; }
                CornerMin() { return { X: () => -1, Y: () => -1, Z: () => -1, delete: () => {} }; }
                CornerMax() { return { X: () => 1, Y: () => 1, Z: () => 1, delete: () => {} }; }
                delete() {}
            },
            
            BRepBndLib: {
                Add: () => {}
            },
            
            GProp_GProps_1: class {
                Mass() { return 1; }
                CentreOfMass() { return { X: () => 0, Y: () => 0, Z: () => 0, delete: () => {} }; }
                delete() {}
            },
            
            BRepGProp: {
                VolumeProperties_1: () => {},
                SurfaceProperties_1: () => {}
            },
            
            TopExp_Explorer_2: class {
                constructor(_shape: any, _type: any) {}
                More() { return false; }
                Next() {}
                Current() { return { delete: () => {} }; }
            },
            
            TopAbs_ShapeEnum: {
                TopAbs_VERTEX: 0,
                TopAbs_EDGE: 1,
                TopAbs_FACE: 4,
                TopAbs_SHELL: 5,
                TopAbs_SOLID: 6
            },
            
            TopoDS: {
                Face_1: (shape: any) => shape
            },
            
            TopLoc_Location_1: class {
                Transformation() { return { delete: () => {} }; }
                delete() {}
            },
            
            BRep_Tool: {
                Triangulation: () => ({
                    IsNull: () => true,
                    NbNodes: () => 0,
                    NbTriangles: () => 0,
                    Node: () => ({ 
                        X: () => 0, 
                        Y: () => 0, 
                        Z: () => 0, 
                        Transformed: function() { return this; },
                        delete: () => {} 
                    }),
                    Triangle: () => ({ Value: () => 1, delete: () => {} }),
                    delete: () => {}
                })
            }
        };
    }

    // ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø§Ù…Ø© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù€ OpenCASCADE
    public getOC(): any {
        if (!this.initialized) {
            throw new Error('Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ØºÙŠØ± Ù…Ù‡ÙŠØ£');
        }
        return this.oc;
    }

    public isReady(): boolean {
        return this.initialized && this.oc !== null;
    }

    public isMockMode(): boolean {
        return this.initialized && !!this.config.fallbackToMock && !this.validateOpenCascade();
    }

    public async dispose(): Promise<void> {
        if (this.worker) {
            this.worker.terminate();
        }
        this.oc = null;
        this.initialized = false;
        this.logger.info('ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ');
    }
}

==== FILE: src\core\CommandManager.ts ====

export interface Command {
    execute(): void;
    undo(): void;
}

export class CommandManager {
    private history: Command[] = [];
    private currentIndex: number = -1;
    private maxHistory: number = 50;

    execute(command: Command): void {
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¨Ø¹Ø¯ Ø§Ù„ÙÙ‡Ø±Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ
        this.history = this.history.slice(0, this.currentIndex + 1);
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
        this.history.push(command);
        
        // ØªÙ‚Ù„ÙŠÙ… Ø§Ù„ØªØ§Ø±ÙŠØ® Ø¥Ø°Ø§ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯
        if (this.history.length > this.maxHistory) {
            this.history.shift();
        } else {
            this.currentIndex++;
        }
        
        command.execute();
    }

    undo(): boolean {
        if (this.canUndo()) {
            this.history[this.currentIndex].undo();
            this.currentIndex--;
            return true;
        }
        return false;
    }

    redo(): boolean {
        if (this.canRedo()) {
            this.currentIndex++;
            this.history[this.currentIndex].execute();
            return true;
        }
        return false;
    }

    canUndo(): boolean {
        return this.currentIndex >= 0;
    }

    canRedo(): boolean {
        return this.currentIndex < this.history.length - 1;
    }

    clear(): void {
        this.history = [];
        this.currentIndex = -1;
    }
}

==== FILE: src\core\Constants.ts ====

// Ø«ÙˆØ§Ø¨Øª Ø¹Ø§Ù…Ø© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹

export const Constants = {
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
    GRID: {
        DEFAULT_SIZE: 1,        // Ø­Ø¬Ù… Ø§Ù„Ø´Ø¨ÙƒØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¨Ø§Ù„Ù…ØªØ±
        MIN_SIZE: 0.1,         // Ø£ØµØºØ± Ø­Ø¬Ù… Ù„Ù„Ø´Ø¨ÙƒØ©
        MAX_SIZE: 10,          // Ø£ÙƒØ¨Ø± Ø­Ø¬Ù… Ù„Ù„Ø´Ø¨ÙƒØ©
        COLOR: 0x888888,       // Ù„ÙˆÙ† Ø§Ù„Ø´Ø¨ÙƒØ©
        DIVISIONS: 100         // Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ‚Ø³ÙŠÙ…Ø§Øª
    },

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
    WALL: {
        DEFAULT_HEIGHT: 3,     // Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¨Ø§Ù„Ù…ØªØ±
        DEFAULT_THICKNESS: 0.2, // Ø³Ù…Ùƒ Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
        MIN_LENGTH: 0.1,       // Ø£Ù‚Ù„ Ø·ÙˆÙ„ Ù…Ø³Ù…ÙˆØ­ Ù„Ù„Ø¬Ø¯Ø§Ø±
        COLOR_2D: 0x808080,    // Ù„ÙˆÙ† Ø§Ù„Ø¬Ø¯Ø§Ø± ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶ Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        COLOR_SELECTED: 0xff0000,   // Ù„ÙˆÙ† Ø§Ù„Ø¬Ø¯Ø§Ø± Ø§Ù„Ù…Ø­Ø¯Ø¯
        COLOR_HIGHLIGHTED: 0x2196F3, // Ù„ÙˆÙ† Ø§Ù„ØªÙ…ÙŠÙŠØ²
        COLOR_PREVIEW: 0x2196F3     // Ù„ÙˆÙ† Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
    },

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
    CAMERA: {
        FRUSTUM_SIZE_2D: 50,   // Ø­Ø¬Ù… Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        FOV_3D: 45,            // Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø±Ø¤ÙŠØ© Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        NEAR: 0.1,
        FAR: 1000
    },

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­ÙƒÙ…
    CONTROLS: {
        PAN_SPEED: 2,
        ZOOM_SPEED: 1.2,
        DAMPING_FACTOR: 0.05
    },

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
    SNAP: {
        GRID_ENABLED_DEFAULT: true,
        ANGLE_SNAP_ENABLED: true,
        ANGLE_SNAP_DEGREES: [0, 45, 90, 135, 180, 225, 270, 315],
        ANGLE_TOLERANCE: 5,     // Ø¯Ø±Ø¬Ø§Øª Ø§Ù„ØªØ³Ø§Ù…Ø­ Ù„Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠ
        ENDPOINT_SNAP_DISTANCE: 0.5  // Ù…Ø³Ø§ÙØ© Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ù„Ù†Ù‡Ø§ÙŠØ§Øª Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
    },

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    UI: {
        DIMENSION_OFFSET: 20,    // Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø§Ø± ÙˆØªØ³Ù…ÙŠØ© Ø§Ù„Ù‚ÙŠØ§Ø³ Ø¨Ø§Ù„Ø¨ÙƒØ³Ù„
        DIMENSION_FONT_SIZE: 14, // Ø­Ø¬Ù… Ø®Ø· Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª
        INFO_UPDATE_RATE: 100    // Ù…Ø¹Ø¯Ù„ ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ø§Ù„Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ©
    }
} as const;

==== FILE: src\core\CoordinateSystem.ts ====



==== FILE: src\core\GeometryEngine.ts ====

/**
 * GeometryEngine - Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
 * Ù…Ø­Ø±Ùƒ Ù…ØªÙƒØ§Ù…Ù„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù…Ø¹ Ø¯Ø¹Ù… OpenCASCADE
 */

import { Logger } from './Logger';
import { AdvancedGeometryEngine } from './AdvancedGeometryEngine';

export type OCHandle = number;
export type OCShapeHandle = OCHandle;
export type OCPointHandle = OCHandle;
export type OCLineHandle = OCHandle;
export type OCCircleHandle = OCHandle;
export type OCSolidHandle = OCHandle;
export type OCFaceHandle = OCHandle;
export type OCEdgeHandle = OCHandle;
export type OCVertexHandle = OCHandle;

export interface Point3D {
    x: number;
    y: number;
    z: number;
}

export interface Vector3D {
    x: number;
    y: number;
    z: number;
}

export interface Transform3D {
    translation: Vector3D;
    rotation: Vector3D;
    scale: Vector3D;
}

export interface BoundingBox {
    min: Point3D;
    max: Point3D;
    center: Point3D;
    dimensions: Vector3D;
}

export interface TessellationResult {
    vertices: Float32Array;
    indices: Uint32Array;
    normals?: Float32Array;
    uvs?: Float32Array;
    colors?: Float32Array;
}

export interface TessellationParams {
    deflection: number;
    angleDeflection?: number;
    relative?: boolean;
    inParallel?: boolean;
    minSize?: number;
    internalVerticesMode?: boolean;
}

export interface GeometryInfo {
    volume?: number;
    surfaceArea?: number;
    centroid?: Point3D;
    boundingBox: BoundingBox;
    topology: {
        vertices: number;
        edges: number;
        faces: number;
        shells: number;
        solids: number;
    };
}

export enum GeometryType {
    VERTEX = 'vertex',
    EDGE = 'edge',
    WIRE = 'wire',
    FACE = 'face',
    SHELL = 'shell',
    SOLID = 'solid',
    COMPOUND = 'compound'
}

export enum BooleanOperation {
    UNION = 'union',
    INTERSECTION = 'intersection',
    DIFFERENCE = 'difference',
    SYMMETRIC_DIFFERENCE = 'symmetric_difference'
}

export class GeometryEngine {
    private static instance: GeometryEngine;
    private oc: any = null;
    private initialized: boolean = false;
    private initPromise: Promise<void> | null = null;
    private logger: Logger;
    
    private shapeCache: Map<OCShapeHandle, any> = new Map();
    private shapeMetadata: Map<OCShapeHandle, any> = new Map();
    private nextHandle: number = 1;
    private memoryUsage: number = 0;
    private maxMemoryUsage: number = 500 * 1024 * 1024; // 500MB
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
    private stats = {
        operationsCount: 0,
        cacheHits: 0,
        cacheMisses: 0,
        memoryAllocations: 0,
        memoryDeallocations: 0,
        averageOperationTime: 0
    };

    private advancedEngine: AdvancedGeometryEngine;

    private constructor() {
        this.logger = Logger.getInstance();
        this.advancedEngine = AdvancedGeometryEngine.getInstance({
            wasmPath: '/assets/opencascade/',
            fallbackToMock: true,
            timeout: 30000
        });
    }

    public static getInstance(): GeometryEngine {
        if (!GeometryEngine.instance) {
            GeometryEngine.instance = new GeometryEngine();
        }
        return GeometryEngine.instance;
    }

    public async initialize(): Promise<void> {
        if (this.initialized) return;
        if (this.initPromise) return this.initPromise;

        this.initPromise = this._doInitialize();
        return this.initPromise;
    }

    private async _doInitialize(): Promise<void> {
        try {
            this.logger.info('ØªÙ‡ÙŠØ¦Ø© GeometryEngine...');
            
            // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø§ÙƒÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©
            this._setupMockOpenCASCADE();
            
            this.initialized = true;
            this.logger.info('GeometryEngine Ø¬Ø§Ù‡Ø² (Mock Mode)');

            this.initialized = true;
            this.logger.info('GeometryEngine Ø¬Ø§Ù‡Ø²');
            await this.runInitializationTests();

        } catch (error) {
            this.logger.error('ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© GeometryEngine Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ:', error);
            this.logger.warn('Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø³Ø®Ø© OpenCASCADE Ù…Ø­Ø§ÙƒØ§Ø© ÙƒØ­Ù„ Ø¨Ø¯ÙŠÙ„.');
            this._setupMockOpenCASCADE();
            
            if (!this.oc || !this.oc.gp_Pnt_1) {
                 this.logger.error('ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© Ø­ØªÙ‰ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ù† OpenCASCADE.');
                 this.initialized = false;
                 throw new Error('ÙØ´Ù„ ØªØ§Ù… ÙÙŠ ØªÙ‡ÙŠØ¦Ø© GeometryEngineØŒ Ø­ØªÙ‰ Ù…Ø¹ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©.');
            }
            
            this.initialized = true;
            this.logger.info('ØªÙ… ØªÙ‡ÙŠØ¦Ø© GeometryEngine Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†Ø³Ø®Ø© Ù…Ø­Ø§ÙƒØ§Ø©.');
        }
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ù† OpenCASCADE
    private _setupMockOpenCASCADE(): void {
        this.logger.info('Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø³Ø®Ø© OpenCASCADE Ù…Ø­Ø§ÙƒØ§Ø©...');
        this.oc = {
            gp_Pnt_1: function() {
                const point = {
                    _x: 0,
                    _y: 0,
                    _z: 0,
                    SetX: function(val: number) { this._x = val; },
                    SetY: function(val: number) { this._y = val; },
                    SetZ: function(val: number) { this._z = val; },
                    X: function() { return this._x; },
                    Y: function() { return this._y; },
                    Z: function() { return this._z; },
                    delete: () => {},
                    Transformed: function(_t: any) { return this; }
                };
                return point;
            },
            gp_Dir_1: function() { 
                const dir = {
                    _x: 0,
                    _y: 0,
                    _z: 1,
                    SetX: function(val: number) { this._x = val; },
                    SetY: function(val: number) { this._y = val; },
                    SetZ: function(val: number) { this._z = val; },
                    delete: () => {}
                };
                return dir;
            },
            gp_Ax2_2: function(_p: any, _d: any) { return { delete: () => {} }; },
            gp_Vec_1: function() { 
                const vec = {
                    _x: 0,
                    _y: 0,
                    _z: 0,
                    SetX: function(val: number) { this._x = val; },
                    SetY: function(val: number) { this._y = val; },
                    SetZ: function(val: number) { this._z = val; },
                    delete: () => {}
                };
                return vec;
            },
            gp_Ax1_2: function(_p: any, _d: any) { return { delete: () => {} }; },
            gp_Trsf_1: function() {
                return {
                    SetTranslation_1: () => {}, SetRotation_1: () => {}, SetScale_1: () => {}, delete: () => {}
                };
            },
            BRepBuilderAPI_MakeVertex: function(_p: any) { return { IsDone: () => true, Vertex: () => ({ delete: () => {} }) }; },
            GC_MakeSegment_1: function(_p1: any, _p2: any) { return { IsDone: () => true, Value: () => ({ delete: () => {} }) }; },
            BRepBuilderAPI_MakeEdge_2: function(_curve: any) { return { IsDone: () => true, Edge: () => ({ delete: () => {} }) }; },
            GC_MakeCircle_2: function(_axis: any, _radius: number) { return { IsDone: () => true, Value: () => ({ delete: () => {} }) }; },
            BRepBuilderAPI_MakeEdge_1: function(_p1: any, _p2: any) { return { IsDone: () => true, Edge: () => ({ delete: () => {} }) }; },
            BRepBuilderAPI_MakeWire_1: function() {
                return {
                    Add_1: () => {}, IsDone: () => true, Wire: () => ({ delete: () => {} })
                };
            },
            BRepBuilderAPI_MakeFace_2: function(_wire: any) { return { IsDone: () => true, Face: () => ({ delete: () => {} }) }; },
            BRepPrimAPI_MakeBox_2: function(_w: number, _h: number, _d: number) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }) }; },
            BRepPrimAPI_MakeBox_3: function(_p: any, _w: number, _h: number, _d: number) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }) }; },
            BRepPrimAPI_MakeSphere_2: function(_center: any, _radius: number) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }) }; },
            BRepPrimAPI_MakeCylinder_2: function(_axis: any, _radius: number, _height: number) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }) }; },
            BRepAlgoAPI_Fuse_1: function(_s1: any, _s2: any) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }), Build: () => {} }; },
            BRepAlgoAPI_Cut_1: function(_s1: any, _s2: any) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }), Build: () => {} }; },
            BRepAlgoAPI_Common_1: function(_s1: any, _s2: any) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }), Build: () => {} }; },
            BRepBuilderAPI_Transform_2: function(_shape: any, _transform: any) { return { IsDone: () => true, Shape: () => ({ delete: () => {} }), Build: () => {} }; },
            BRepMesh_IncrementalMesh_2: function(_shape: any, _deflection: number) { return { Perform: () => {} }; },
            Bnd_Box_1: function() {
                return {
                    IsVoid: () => false,
                    CornerMin: () => ({ X: () => 0, Y: () => 0, Z: () => 0, delete: () => {} }),
                    CornerMax: () => ({ X: () => 1, Y: () => 1, Z: () => 1, delete: () => {} }),
                    delete: () => {}
                };
            },
            BRepBndLib: { Add: () => {} },
            GProp_GProps_1: function() {
                return {
                    Mass: () => 1,
                    CentreOfMass: () => ({ X: () => 0, Y: () => 0, Z: () => 0, delete: () => {} }),
                    delete: () => {}
                };
            },
            BRepGProp: { VolumeProperties_1: () => {}, SurfaceProperties_1: () => {} },
            TopExp_Explorer_2: function(_shape: any, _type: any) {
                return { More: () => false, Next: () => {}, Current: () => ({ delete: () => {} }) };
            },
            TopAbs_ShapeEnum: { TopAbs_VERTEX: 0, TopAbs_EDGE: 1, TopAbs_FACE: 4, TopAbs_SHELL: 5, TopAbs_SOLID: 6 },
            TopoDS: { Face_1: (shape: any) => shape },
            TopLoc_Location_1: function() { return { Transformation: () => ({ delete: () => {} }), delete: () => {} }; },
            BRep_Tool: {
                Triangulation: () => ({
                    IsNull: () => true, NbNodes: () => 0, NbTriangles: () => 0,
                    Node: () => ({ X: () => 0, Y: () => 0, Z: () => 0, Transformed: function() { return this; }, delete: () => {} }),
                    Triangle: () => ({ Value: () => 1, delete: () => {} }),
                    delete: () => {}
                })
            }
        };
    }

    // Ø§Ù„Ø¯Ø§Ù„Ø© useMockOpenCASCADE Ù„Ù„ØªÙˆØ§ÙÙ‚
    public useMockOpenCASCADE(): void {
        this._setupMockOpenCASCADE();
    }

    private async runInitializationTests(): Promise<void> {
        // ØªØ®Ø·ÙŠ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ø§ÙƒÙŠ
        if (this.advancedEngine && this.advancedEngine.isMockMode()) {
            this.logger.debug('ØªØ®Ø·ÙŠ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø­Ø§ÙƒÙŠ');
            return;
        }
        
        try {
            // Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª OpenCASCADE Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ ÙÙ‚Ø·
            const testPoint = new this.oc.gp_Pnt_1();
            testPoint.SetX(0);
            testPoint.SetY(0);
            testPoint.SetZ(0);
            testPoint.delete();
            
            this.logger.debug('Ù†Ø¬Ø­Øª Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‡ÙŠØ¦Ø©');
        } catch (error) {
            this.logger.warn('ÙØ´Ù„Øª Ø¨Ø¹Ø¶ Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø§Ù„ØªÙ‡ÙŠØ¦Ø©:', error);
        }
    }

    // ==================== Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ====================

    public createPoint(x: number, y: number, z: number = 0): OCPointHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createPoint', () => {
            const point = new this.oc.gp_Pnt_1();
            point.SetX(x);
            point.SetY(y);
            point.SetZ(z);
            const vertex = new this.oc.BRepBuilderAPI_MakeVertex(point);
            
            if (!vertex.IsDone()) {
                throw new Error('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø£Ø³');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, vertex.Vertex());
            this.shapeMetadata.set(handle, {
                type: GeometryType.VERTEX,
                created: Date.now(),
                coordinates: { x, y, z }
            });
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ù‚Ø·Ø©: (${x}, ${y}, ${z}) - Handle: ${handle}`);
            return handle;
        });
    }

    public createLine(startPoint: Point3D, endPoint: Point3D): OCLineHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createLine', () => {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª
            if (!startPoint || typeof startPoint.x !== 'number' || typeof startPoint.y !== 'number') {
                throw new Error('Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø©');
            }
            if (!endPoint || typeof endPoint.x !== 'number' || typeof endPoint.y !== 'number') {
                throw new Error('Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ© ØºÙŠØ± ØµØ§Ù„Ø­Ø©');
            }
            
            const p1 = new this.oc.gp_Pnt_1();
            p1.SetX(startPoint.x);
            p1.SetY(startPoint.y);
            p1.SetZ(startPoint.z || 0);
            
            const p2 = new this.oc.gp_Pnt_1();
            p2.SetX(endPoint.x);
            p2.SetY(endPoint.y);
            p2.SetZ(endPoint.z || 0);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ØªØ³Ø§ÙˆÙŠ Ø§Ù„Ù†Ù‚Ø·ØªÙŠÙ†
            if (this.arePointsEqual(p1, p2)) {
                p1.delete(); p2.delete();
                throw new Error('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù…Ù† Ù†Ù‚Ø·ØªÙŠÙ† Ù…ØªØ·Ø§Ø¨Ù‚ØªÙŠÙ†');
            }
            
            const line = new this.oc.GC_MakeSegment_1(p1, p2);
            if (!line.IsDone()) {
                p1.delete(); p2.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‚Ø·Ø¹ Ø§Ù„Ø®Ø·');
            }
            
            const edge = new this.oc.BRepBuilderAPI_MakeEdge_2(line.Value());
            if (!edge.IsDone()) {
                p1.delete(); p2.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø§ÙØ© Ø§Ù„Ø®Ø·');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, edge.Edge());
            this.shapeMetadata.set(handle, {
                type: GeometryType.EDGE,
                created: Date.now(),
                startPoint,
                endPoint,
                length: this.calculateDistance(startPoint, endPoint)
            });
            
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            p1.delete(); p2.delete();
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· - Handle: ${handle}`);
            return handle;
        });
    }

    public createCircle(center: Point3D, normal: Vector3D, radius: number): OCCircleHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createCircle', () => {
            if (radius <= 0) {
                throw new Error('Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±');
            }

            const centerPnt = new this.oc.gp_Pnt_1();
            centerPnt.SetX(center.x);
            centerPnt.SetY(center.y);
            centerPnt.SetZ(center.z);
            
            const normalVec = new this.oc.gp_Dir_1();
            normalVec.SetX(normal.x);
            normalVec.SetY(normal.y);
            normalVec.SetZ(normal.z);
            
            const axis = new this.oc.gp_Ax2_2(centerPnt, normalVec);
            
            const circle = new this.oc.GC_MakeCircle_2(axis, radius);
            if (!circle.IsDone()) {
                centerPnt.delete(); normalVec.delete(); axis.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©');
            }
            
            const edge = new this.oc.BRepBuilderAPI_MakeEdge_2(circle.Value());
            if (!edge.IsDone()) {
                centerPnt.delete(); normalVec.delete(); axis.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø§ÙØ© Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, edge.Edge());
            this.shapeMetadata.set(handle, {
                type: GeometryType.EDGE,
                created: Date.now(),
                center,
                normal,
                radius,
                circumference: 2 * Math.PI * radius,
                area: Math.PI * radius * radius
            });
            
            centerPnt.delete(); normalVec.delete(); axis.delete();
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø§Ø¦Ø±Ø© - Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±: ${radius} - Handle: ${handle}`);
            return handle;
        });
    }

    public createRectangle(corner1: Point3D, corner2: Point3D, _height: number = 0): OCFaceHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createRectangle', () => {
            const p1 = new this.oc.gp_Pnt_1();
            p1.SetX(corner1.x); p1.SetY(corner1.y); p1.SetZ(corner1.z);
            
            const p2 = new this.oc.gp_Pnt_1();
            p2.SetX(corner2.x); p2.SetY(corner1.y); p2.SetZ(corner1.z);
            
            const p3 = new this.oc.gp_Pnt_1();
            p3.SetX(corner2.x); p3.SetY(corner2.y); p3.SetZ(corner1.z);
            
            const p4 = new this.oc.gp_Pnt_1();
            p4.SetX(corner1.x); p4.SetY(corner2.y); p4.SetZ(corner1.z);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­ÙˆØ§Ù
            const edge1 = new this.oc.BRepBuilderAPI_MakeEdge_1(p1, p2);
            const edge2 = new this.oc.BRepBuilderAPI_MakeEdge_1(p2, p3);
            const edge3 = new this.oc.BRepBuilderAPI_MakeEdge_1(p3, p4);
            const edge4 = new this.oc.BRepBuilderAPI_MakeEdge_1(p4, p1);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù„Ùƒ
            const wireBuilder = new this.oc.BRepBuilderAPI_MakeWire_1();
            wireBuilder.Add_1(edge1.Edge());
            wireBuilder.Add_1(edge2.Edge());
            wireBuilder.Add_1(edge3.Edge());
            wireBuilder.Add_1(edge4.Edge());
            
            if (!wireBuilder.IsDone()) {
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø³Ù„Ùƒ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„');
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙˆØ¬Ù‡
            const face = new this.oc.BRepBuilderAPI_MakeFace_2(wireBuilder.Wire());
            if (!face.IsDone()) {
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ¬Ù‡ Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, face.Face());
            this.shapeMetadata.set(handle, {
                type: GeometryType.FACE,
                created: Date.now(),
                corner1,
                corner2,
                width: Math.abs(corner2.x - corner1.x),
                height: Math.abs(corner2.y - corner1.y),
                area: Math.abs(corner2.x - corner1.x) * Math.abs(corner2.y - corner1.y)
            });
            
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            [p1, p2, p3, p4].forEach(p => p.delete());
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ·ÙŠÙ„ - Handle: ${handle}`);
            return handle;
        });
    }

    public createBox(width: number, height: number, depth: number, corner?: Point3D): OCSolidHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createBox', () => {
            if (width <= 0 || height <= 0 || depth <= 0) {
                throw new Error('Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚ ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±');
            }

            let box;
            if (corner) {
                const cornerPnt = new this.oc.gp_Pnt_1();
                cornerPnt.SetX(corner.x);
                cornerPnt.SetY(corner.y);
                cornerPnt.SetZ(corner.z);
                box = new this.oc.BRepPrimAPI_MakeBox_3(cornerPnt, width, height, depth);
                cornerPnt.delete();
            } else {
                box = new this.oc.BRepPrimAPI_MakeBox_2(width, height, depth);
            }
            
            if (!box.IsDone()) {
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØµÙ†Ø¯ÙˆÙ‚');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, box.Shape());
            this.shapeMetadata.set(handle, {
                type: GeometryType.SOLID,
                created: Date.now(),
                dimensions: { width, height, depth },
                volume: width * height * depth,
                corner: corner || { x: 0, y: 0, z: 0 }
            });
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ØµÙ†Ø¯ÙˆÙ‚: ${width}x${height}x${depth} - Handle: ${handle}`);
            return handle;
        });
    }

    public createSphere(center: Point3D, radius: number): OCSolidHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createSphere', () => {
            if (radius <= 0) {
                throw new Error('Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±');
            }

            const centerPnt = new this.oc.gp_Pnt_1();
            centerPnt.SetX(center.x);
            centerPnt.SetY(center.y);
            centerPnt.SetZ(center.z);
            const sphere = new this.oc.BRepPrimAPI_MakeSphere_2(centerPnt, radius);
            
            if (!sphere.IsDone()) {
                centerPnt.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ±Ø©');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, sphere.Shape());
            this.shapeMetadata.set(handle, {
                type: GeometryType.SOLID,
                created: Date.now(),
                center,
                radius,
                volume: (4/3) * Math.PI * Math.pow(radius, 3),
                surfaceArea: 4 * Math.PI * Math.pow(radius, 2)
            });
            
            centerPnt.delete();
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ±Ø© - Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø±: ${radius} - Handle: ${handle}`);
            return handle;
        });
    }

    public createCylinder(baseCenter: Point3D, axis: Vector3D, radius: number, height: number): OCSolidHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('createCylinder', () => {
            if (radius <= 0 || height <= 0) {
                throw new Error('Ù†ØµÙ Ø§Ù„Ù‚Ø·Ø± ÙˆØ§Ù„Ø§Ø±ØªÙØ§Ø¹ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ†Ø§ Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±');
            }

            const basePnt = new this.oc.gp_Pnt_1();
            basePnt.SetX(baseCenter.x);
            basePnt.SetY(baseCenter.y);
            basePnt.SetZ(baseCenter.z);
            
            const axisDir = new this.oc.gp_Dir_1();
            axisDir.SetX(axis.x);
            axisDir.SetY(axis.y);
            axisDir.SetZ(axis.z);
            
            const axisObj = new this.oc.gp_Ax2_2(basePnt, axisDir);
            
            const cylinder = new this.oc.BRepPrimAPI_MakeCylinder_2(axisObj, radius, height);
            
            if (!cylinder.IsDone()) {
                basePnt.delete(); axisDir.delete(); axisObj.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø³Ø·ÙˆØ§Ù†Ø©');
            }
            
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, cylinder.Shape());
            this.shapeMetadata.set(handle, {
                type: GeometryType.SOLID,
                created: Date.now(),
                baseCenter,
                axis,
                radius,
                height,
                volume: Math.PI * Math.pow(radius, 2) * height,
                surfaceArea: 2 * Math.PI * radius * (radius + height)
            });
            
            basePnt.delete(); axisDir.delete(); axisObj.delete();
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø³Ø·ÙˆØ§Ù†Ø© - Handle: ${handle}`);
            return handle;
        });
    }

    // ==================== Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ© ====================

    public performBooleanOperation(
        shape1Handle: OCShapeHandle, 
        shape2Handle: OCShapeHandle, 
        operation: BooleanOperation
    ): OCShapeHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('booleanOperation', () => {
            const shape1 = this.getShape(shape1Handle);
            const shape2 = this.getShape(shape2Handle);
            
            if (!shape1 || !shape2) {
                throw new Error('Ø£Ø´ÙƒØ§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©');
            }
            
            let result;
            
            switch (operation) {
                case BooleanOperation.UNION:
                    result = new this.oc.BRepAlgoAPI_Fuse_1(shape1, shape2);
                    break;
                case BooleanOperation.DIFFERENCE:
                    result = new this.oc.BRepAlgoAPI_Cut_1(shape1, shape2);
                    break;
                case BooleanOperation.INTERSECTION:
                    result = new this.oc.BRepAlgoAPI_Common_1(shape1, shape2);
                    break;
                case BooleanOperation.SYMMETRIC_DIFFERENCE:
                    // ØªÙ†ÙÙŠØ° Ø§Ù„ÙØ±Ù‚ Ø§Ù„Ù…ØªÙ…Ø§Ø«Ù„ Ø¹Ø¨Ø± (AâˆªB) - (Aâˆ©B)
                    const unionOp = new this.oc.BRepAlgoAPI_Fuse_1(shape1, shape2);
                    unionOp.Build();
                    const intersectionOp = new this.oc.BRepAlgoAPI_Common_1(shape1, shape2);
                    intersectionOp.Build();
                    result = new this.oc.BRepAlgoAPI_Cut_1(unionOp.Shape(), intersectionOp.Shape());
                    break;
                default:
                    throw new Error(`Ø¹Ù…Ù„ÙŠØ© Ù…Ù†Ø·Ù‚ÙŠØ© ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø©: ${operation}`);
            }
            
            result.Build();
            
            if (!result.IsDone()) {
                throw new Error(`ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠØ©: ${operation}`);
            }
            
            const resultShape = result.Shape();
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, resultShape);
            this.shapeMetadata.set(handle, {
                type: GeometryType.SOLID,
                created: Date.now(),
                operation,
                operands: [shape1Handle, shape2Handle]
            });
            
            this.logger.debug(`ØªÙ… Ø¥Ø¬Ø±Ø§Ø¡ Ø¹Ù…Ù„ÙŠØ© ${operation} - Handle: ${handle}`);
            return handle;
        });
    }

    // ==================== Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© ====================

    public translateShape(shapeHandle: OCShapeHandle, translation: Vector3D): OCShapeHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('translate', () => {
            const shape = this.getShape(shapeHandle);
            
            const translationVec = new this.oc.gp_Vec_1();
            translationVec.SetX(translation.x);
            translationVec.SetY(translation.y);
            translationVec.SetZ(translation.z);
            
            const transform = new this.oc.gp_Trsf_1();
            transform.SetTranslation_1(translationVec);
            
            const transformOp = new this.oc.BRepBuilderAPI_Transform_2(shape, transform);
            transformOp.Build();
            
            if (!transformOp.IsDone()) {
                translationVec.delete(); transform.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´ÙƒÙ„');
            }
            
            const resultShape = transformOp.Shape();
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, resultShape);
            this.shapeMetadata.set(handle, {
                ...this.shapeMetadata.get(shapeHandle),
                created: Date.now(),
                transformation: 'translation',
                translationVector: translation
            });
            
            translationVec.delete(); transform.delete();
            
            this.logger.debug(`ØªÙ… ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´ÙƒÙ„ - Handle: ${handle}`);
            return handle;
        });
    }

    public rotateShape(shapeHandle: OCShapeHandle, axis: Point3D, direction: Vector3D, angle: number): OCShapeHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('rotate', () => {
            const shape = this.getShape(shapeHandle);
            
            const axisPnt = new this.oc.gp_Pnt_1();
            axisPnt.SetX(axis.x);
            axisPnt.SetY(axis.y);
            axisPnt.SetZ(axis.z);
            
            const axisDir = new this.oc.gp_Dir_1();
            axisDir.SetX(direction.x);
            axisDir.SetY(direction.y);
            axisDir.SetZ(direction.z);
            
            const rotationAxis = new this.oc.gp_Ax1_2(axisPnt, axisDir);
            
            const transform = new this.oc.gp_Trsf_1();
            transform.SetRotation_1(rotationAxis, angle);
            
            const transformOp = new this.oc.BRepBuilderAPI_Transform_2(shape, transform);
            transformOp.Build();
            
            if (!transformOp.IsDone()) {
                axisPnt.delete(); axisDir.delete(); rotationAxis.delete(); transform.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø´ÙƒÙ„');
            }
            
            const resultShape = transformOp.Shape();
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, resultShape);
            this.shapeMetadata.set(handle, {
                ...this.shapeMetadata.get(shapeHandle),
                created: Date.now(),
                transformation: 'rotation',
                rotationAxis: axis,
                rotationDirection: direction,
                rotationAngle: angle
            });
            
            axisPnt.delete(); axisDir.delete(); rotationAxis.delete(); transform.delete();
            
            this.logger.debug(`ØªÙ… Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø´ÙƒÙ„ - Ø²Ø§ÙˆÙŠØ©: ${angle} Ø±Ø§Ø¯ÙŠØ§Ù† - Handle: ${handle}`);
            return handle;
        });
    }

    public scaleShape(shapeHandle: OCShapeHandle, center: Point3D, scaleFactor: number): OCShapeHandle {
        this.ensureInitialized();
        return this.executeWithProfiling('scale', () => {
            if (scaleFactor <= 0) {
                throw new Error('Ù…Ø¹Ø§Ù…Ù„ Ø§Ù„ØªÙƒØ¨ÙŠØ± ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø£ÙƒØ¨Ø± Ù…Ù† ØµÙØ±');
            }
            
            const shape = this.getShape(shapeHandle);
            
            const centerPnt = new this.oc.gp_Pnt_1();
            centerPnt.SetX(center.x);
            centerPnt.SetY(center.y);
            centerPnt.SetZ(center.z);
            
            const transform = new this.oc.gp_Trsf_1();
            transform.SetScale_1(centerPnt, scaleFactor);
            
            const transformOp = new this.oc.BRepBuilderAPI_Transform_2(shape, transform);
            transformOp.Build();
            
            if (!transformOp.IsDone()) {
                centerPnt.delete(); transform.delete();
                throw new Error('ÙØ´Ù„ ÙÙŠ ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø´ÙƒÙ„');
            }
            
            const resultShape = transformOp.Shape();
            const handle = this.getNextHandle();
            this.shapeCache.set(handle, resultShape);
            this.shapeMetadata.set(handle, {
                ...this.shapeMetadata.get(shapeHandle),
                created: Date.now(),
                transformation: 'scale',
                scaleCenter: center,
                scaleFactor
            });
            
            centerPnt.delete(); transform.delete();
            
            this.logger.debug(`ØªÙ… ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø´ÙƒÙ„ - Ù…Ø¹Ø§Ù…Ù„: ${scaleFactor} - Handle: ${handle}`);
            return handle;
        });
    }

    // ==================== Ø§Ù„ØªØ´Ø¨ÙŠÙƒ ÙˆØ§Ù„ØªØµØ¯ÙŠØ± ====================

    public tessellateShape(shapeHandle: OCShapeHandle, params: TessellationParams): TessellationResult {
        this.ensureInitialized();
        return this.executeWithProfiling('tessellate', () => {
            const shape = this.getShape(shapeHandle);
            
            if (!shape) {
                throw new Error('Ø´ÙƒÙ„ ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ù„ØªØ­ÙˆÙŠÙ„');
            }
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ´Ø¨ÙŠÙƒ
            const mesh = new this.oc.BRepMesh_IncrementalMesh_2(
                shape, 
                params.deflection, 
                params.relative || false, 
                params.angleDeflection || 0.5, 
                params.inParallel || true
            );
            
            mesh.Perform();
            
            // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            const vertices: number[] = [];
            const indices: number[] = [];
            const normals: number[] = [];
            
            // Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¹Ø¨Ø± Ø§Ù„ÙˆØ¬ÙˆÙ‡ ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            const explorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_FACE);
            let vertexIndex = 0;
            
            while (explorer.More()) {
                const face = this.oc.TopoDS.Face_1(explorer.Current());
                const location = new this.oc.TopLoc_Location_1();
                const triangulation = this.oc.BRep_Tool.Triangulation(face, location);
                
                if (!triangulation.IsNull()) {
                    const transform = location.Transformation();
                    const nodeCount = triangulation.NbNodes();
                    const triangleCount = triangulation.NbTriangles();
                    
                    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø±Ø¤ÙˆØ³
                    for (let i = 1; i <= nodeCount; i++) {
                        const node = triangulation.Node(i);
                        const transformedNode = node.Transformed(transform);
                        
                        vertices.push(transformedNode.X(), transformedNode.Y(), transformedNode.Z());
                        
                        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¹Ø§Ø¯ÙŠ (Ù…Ø¨Ø³Ø·)
                        normals.push(0, 0, 1);
                    }
                    
                    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø«Ù„Ø«Ø§Øª
                    for (let i = 1; i <= triangleCount; i++) {
                        const triangle = triangulation.Triangle(i);
                        const [n1, n2, n3] = [triangle.Value(1), triangle.Value(2), triangle.Value(3)];
                        
                        indices.push(
                            vertexIndex + n1 - 1,
                            vertexIndex + n2 - 1,
                            vertexIndex + n3 - 1
                        );
                    }
                    
                    vertexIndex += nodeCount;
                }
                
                explorer.Next();
            }
            
            this.logger.debug(`ØªÙ… ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´ÙƒÙ„ Ø¥Ù„Ù‰ Ø´Ø¨ÙƒØ©: ${vertices.length/3} Ø±Ø¤ÙˆØ³ØŒ ${indices.length/3} Ù…Ø«Ù„Ø«Ø§Øª`);
            
            return {
                vertices: new Float32Array(vertices),
                indices: new Uint32Array(indices),
                normals: new Float32Array(normals)
            };
        });
    }

    // ==================== Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ ====================

    public getShapeInfo(shapeHandle: OCShapeHandle): GeometryInfo {
        this.ensureInitialized();
        return this.executeWithProfiling('getShapeInfo', () => {
            const shape = this.getShape(shapeHandle);
            const metadata = this.shapeMetadata.get(shapeHandle);
            
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¯ÙˆØ¯
            const bbox = new this.oc.Bnd_Box_1();
            this.oc.BRepBndLib.Add(shape, bbox, false);
            
            let boundingBox: BoundingBox;
            if (!bbox.IsVoid()) {
                const min = bbox.CornerMin();
                const max = bbox.CornerMax();
                
                boundingBox = {
                    min: { x: min.X(), y: min.Y(), z: min.Z() },
                    max: { x: max.X(), y: max.Y(), z: max.Z() },
                    center: {
                        x: (min.X() + max.X()) / 2,
                        y: (min.Y() + max.Y()) / 2,
                        z: (min.Z() + max.Z()) / 2
                    },
                    dimensions: {
                        x: max.X() - min.X(),
                        y: max.Y() - min.Y(),
                        z: max.Z() - min.Z()
                    }
                };
                
                min.delete(); max.delete();
            } else {
                boundingBox = {
                    min: { x: 0, y: 0, z: 0 },
                    max: { x: 0, y: 0, z: 0 },
                    center: { x: 0, y: 0, z: 0 },
                    dimensions: { x: 0, y: 0, z: 0 }
                };
            }
            
            bbox.delete();
            
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·ÙˆØ¨ÙˆÙ„ÙˆØ¬ÙŠØ§
            const topology = this.calculateTopology(shape);
            
            // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©
            let volume: number | undefined;
            let surfaceArea: number | undefined;
            let centroid: Point3D | undefined;
            
            try {
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¬Ù… (Ù„Ù„Ø£Ø¬Ø³Ø§Ù… Ø§Ù„ØµÙ„Ø¨Ø©)
                if (metadata?.type === GeometryType.SOLID) {
                    const gprops = new this.oc.GProp_GProps_1();
                    this.oc.BRepGProp.VolumeProperties_1(shape, gprops);
                    volume = gprops.Mass();
                    
                    const centerOfMass = gprops.CentreOfMass();
                    centroid = {
                        x: centerOfMass.X(),
                        y: centerOfMass.Y(),
                        z: centerOfMass.Z()
                    };
                    
                    gprops.delete();
                    centerOfMass.delete();
                }
                
                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø³Ø·Ø­ÙŠØ©
                const surfaceProps = new this.oc.GProp_GProps_1();
                this.oc.BRepGProp.SurfaceProperties_1(shape, surfaceProps);
                surfaceArea = surfaceProps.Mass();
                surfaceProps.delete();
                
            } catch (error) {
                this.logger.warn('ÙØ´Ù„ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ©:', error);
            }
            
            return {
                volume,
                surfaceArea,
                centroid,
                boundingBox,
                topology
            };
        });
    }

    private calculateTopology(shape: any): { vertices: number; edges: number; faces: number; shells: number; solids: number } {
        const topology = { vertices: 0, edges: 0, faces: 0, shells: 0, solids: 0 };
        
        try {
            // Ø¹Ø¯ Ø§Ù„Ø±Ø¤ÙˆØ³
            const vertexExplorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_VERTEX);
            while (vertexExplorer.More()) {
                topology.vertices++;
                vertexExplorer.Next();
            }
            
            // Ø¹Ø¯ Ø§Ù„Ø­ÙˆØ§Ù
            const edgeExplorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_EDGE);
            while (edgeExplorer.More()) {
                topology.edges++;
                edgeExplorer.Next();
            }
            
            // Ø¹Ø¯ Ø§Ù„ÙˆØ¬ÙˆÙ‡
            const faceExplorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_FACE);
            while (faceExplorer.More()) {
                topology.faces++;
                faceExplorer.Next();
            }
            
            // Ø¹Ø¯ Ø§Ù„Ø£ØµØ¯Ø§Ù
            const shellExplorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_SHELL);
            while (shellExplorer.More()) {
                topology.shells++;
                shellExplorer.Next();
            }
            
            // Ø¹Ø¯ Ø§Ù„Ø£Ø¬Ø³Ø§Ù… Ø§Ù„ØµÙ„Ø¨Ø©
            const solidExplorer = new this.oc.TopExp_Explorer_2(shape, this.oc.TopAbs_ShapeEnum.TopAbs_SOLID);
            while (solidExplorer.More()) {
                topology.solids++;
                solidExplorer.Next();
            }
            
        } catch (error) {
            this.logger.warn('ÙØ´Ù„ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·ÙˆØ¨ÙˆÙ„ÙˆØ¬ÙŠØ§:', error);
        }
        
        return topology;
    }

    // ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡ ====================

    public deleteShape(handle: OCShapeHandle): void {
        if (this.shapeCache.has(handle)) {
            const shape = this.shapeCache.get(handle);
            
            try {
                if (shape && typeof shape.delete === 'function') {
                    shape.delete();
                    this.stats.memoryDeallocations++;
                }
            } catch (error) {
                this.logger.warn(`ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø´ÙƒÙ„ ${handle}:`, error);
            }
            
            this.shapeCache.delete(handle);
            this.shapeMetadata.delete(handle);
            this.logger.debug(`ØªÙ… Ø­Ø°Ù Ø§Ù„Ø´ÙƒÙ„: ${handle}`);
        }
    }

    public clearCache(): void {
        this.shapeCache.forEach((_shape, handle) => {
            this.deleteShape(handle);
        });
        
        this.shapeCache.clear();
        this.shapeMetadata.clear();
        this.logger.info('ØªÙ… Ù…Ø³Ø­ Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª');
    }

    public getStats(): typeof this.stats {
        return { ...this.stats };
    }

    public getMemoryUsage(): { current: number; max: number; cacheSize: number } {
        return {
            current: this.memoryUsage,
            max: this.maxMemoryUsage,
            cacheSize: this.shapeCache.size
        };
    }

    // ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================

    private ensureInitialized(): void {
        if (!this.initialized || !this.oc) {
            throw new Error('GeometryEngine ØºÙŠØ± Ù…Ù‡ÙŠØ£ - Ø§Ø³ØªØ¯Ø¹ initialize() Ø£ÙˆÙ„Ø§Ù‹');
        }
    }

    private getShape(handle: OCHandle): any {
        const shape = this.shapeCache.get(handle);
        if (!shape) {
            this.stats.cacheMisses++;
            throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„ Ø¨Ø§Ù„Ù…Ø¹Ø±Ù: ${handle}`);
        }
        this.stats.cacheHits++;
        return shape;
    }

    private getNextHandle(): OCHandle {
        return this.nextHandle++;
    }

    private arePointsEqual(p1: any, p2: any, tolerance: number = 1e-6): boolean {
        try {
            return Math.abs(p1.X() - p2.X()) < tolerance &&
                   Math.abs(p1.Y() - p2.Y()) < tolerance &&
                   Math.abs(p1.Z() - p2.Z()) < tolerance;
        } catch (error) {
            return false;
        }
    }

    private calculateDistance(p1: Point3D, p2: Point3D): number {
        return Math.sqrt(
            Math.pow(p2.x - p1.x, 2) +
            Math.pow(p2.y - p1.y, 2) +
            Math.pow(p2.z - p1.z, 2)
        );
    }

    private executeWithProfiling<T>(operationName: string, operation: () => T): T {
        const startTime = performance.now();
        
        try {
            this.stats.operationsCount++;
            this.stats.memoryAllocations++;
            
            const result = operation();
            
            const endTime = performance.now();
            const operationTime = endTime - startTime;
            
            // ØªØ­Ø¯ÙŠØ« Ù…ØªÙˆØ³Ø· ÙˆÙ‚Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
            this.stats.averageOperationTime = 
                (this.stats.averageOperationTime * (this.stats.operationsCount - 1) + operationTime) / 
                this.stats.operationsCount;
            
            if (operationTime > 100) { // ØªØ­Ø°ÙŠØ± Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¨Ø·ÙŠØ¦Ø©
                this.logger.warn(`Ø¹Ù…Ù„ÙŠØ© Ø¨Ø·ÙŠØ¦Ø©: ${operationName} Ø§Ø³ØªØºØ±Ù‚Øª ${operationTime.toFixed(2)}ms`);
            }
            
            return result;
            
        } catch (error) {
            const endTime = performance.now();
            this.logger.error(`ÙØ´Ù„Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© ${operationName} Ø¨Ø¹Ø¯ ${(endTime - startTime).toFixed(2)}ms:`, error);
            throw error;
        }
    }

    public isReady(): boolean {
        return this.initialized && this.oc !== null;
    }

    public dispose(): void {
        try {
            this.clearCache();
            this.oc = null;
            this.initialized = false;
            this.initPromise = null;
            
            this.logger.info('ØªÙ… ØªÙ†Ø¸ÙŠÙ GeometryEngine');
        } catch (error) {
            this.logger.error('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†Ø¸ÙŠÙ GeometryEngine:', error);
        }
    }

    public getEngineInfo(): {
        initialized: boolean;
        shapeCount: number;
        nextHandle: number;
        stats: {
            operationsCount: number;
            cacheHits: number;
            cacheMisses: number;
            memoryAllocations: number;
            memoryDeallocations: number;
            averageOperationTime: number;
        };
        memoryUsage: { current: number; max: number; cacheSize: number };
    } {
        return {
            initialized: this.initialized,
            shapeCount: this.shapeCache.size,
            nextHandle: this.nextHandle,
            stats: this.getStats(),
            memoryUsage: this.getMemoryUsage()
        };
    }
}

==== FILE: src\core\Logger.ts ====

/**
 * Logger - Advanced logging system for debugging and monitoring
 */

// Log levels
export enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    FATAL = 4
}

// Log entry interface
export interface LogEntry {
    timestamp: Date;
    level: LogLevel;
    message: string;
    category?: string;
    data?: any;
    stack?: string;
}

// Logger configuration
export interface LoggerConfig {
    level: LogLevel;
    enableConsole: boolean;
    enableStorage: boolean;
    maxStoredLogs: number;
    enableTimestamp: boolean;
    enableColors: boolean;
    categories?: string[];
}

/**
 * Logger class - Singleton pattern
 */
export class Logger {
    private static instance: Logger;
    private config: LoggerConfig;
    private logs: LogEntry[] = [];
    private listeners: ((entry: LogEntry) => void)[] = [];

    // Console colors
    private colors = {
        [LogLevel.DEBUG]: 'color: #888',
        [LogLevel.INFO]: 'color: #2196F3',
        [LogLevel.WARN]: 'color: #FF9800',
        [LogLevel.ERROR]: 'color: #F44336',
        [LogLevel.FATAL]: 'color: #B71C1C; font-weight: bold'
    };

    // Level names
    private levelNames = {
        [LogLevel.DEBUG]: 'DEBUG',
        [LogLevel.INFO]: 'INFO',
        [LogLevel.WARN]: 'WARN',
        [LogLevel.ERROR]: 'ERROR',
        [LogLevel.FATAL]: 'FATAL'
    };

    private constructor() {
        this.config = {
            level: LogLevel.INFO,
            enableConsole: true,
            enableStorage: true,
            maxStoredLogs: 1000,
            enableTimestamp: true,
            enableColors: true,
            categories: []
        };
    }

    /**
     * Get logger instance
     */
    public static getInstance(): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger();
        }
        return Logger.instance;
    }

    /**
     * Configure logger
     */
    public configure(config: Partial<LoggerConfig>): void {
        Object.assign(this.config, config);
        
        // Trim logs if needed
        if (this.logs.length > this.config.maxStoredLogs) {
            this.logs = this.logs.slice(-this.config.maxStoredLogs);
        }
    }

    /**
     * Set log level
     */
    public setLevel(level: LogLevel): void {
        this.config.level = level;
    }

    /**
     * Debug log
     */
    public debug(message: string, data?: any, category?: string): void {
        this.log(LogLevel.DEBUG, message, data, category);
    }

    /**
     * Info log
     */
    public info(message: string, data?: any, category?: string): void {
        this.log(LogLevel.INFO, message, data, category);
    }

    /**
     * Warning log
     */
    public warn(message: string, data?: any, category?: string): void {
        this.log(LogLevel.WARN, message, data, category);
    }

    /**
     * Error log
     */
    public error(message: string, error?: any, category?: string): void {
        let data = error;
        let stack: string | undefined;
        
        if (error instanceof Error) {
            data = {
                name: error.name,
                message: error.message,
                stack: error.stack
            };
            stack = error.stack;
        }
        
        this.log(LogLevel.ERROR, message, data, category, stack);
    }

    /**
     * Fatal log
     */
    public fatal(message: string, error?: any, category?: string): void {
        let data = error;
        let stack: string | undefined;
        
        if (error instanceof Error) {
            data = {
                name: error.name,
                message: error.message,
                stack: error.stack
            };
            stack = error.stack;
        }
        
        this.log(LogLevel.FATAL, message, data, category, stack);
    }

    /**
     * Log with specific level
     */
    private log(
        level: LogLevel,
        message: string,
        data?: any,
        category?: string,
        stack?: string
    ): void {
        // Check if should log
        if (level < this.config.level) {
            return;
        }
        
        // Check category filter
        if (category && this.config.categories && this.config.categories.length > 0) {
            if (!this.config.categories.includes(category)) {
                return;
            }
        }
        
        // Create log entry
        const entry: LogEntry = {
            timestamp: new Date(),
            level,
            message,
            category,
            data,
            stack
        };
        
        // Store log
        if (this.config.enableStorage) {
            this.logs.push(entry);
            
            // Trim if needed
            if (this.logs.length > this.config.maxStoredLogs) {
                this.logs.shift();
            }
        }
        
        // Console output
        if (this.config.enableConsole) {
            this.consoleOutput(entry);
        }
        
        // Notify listeners
        this.notifyListeners(entry);
    }

    /**
     * Console output
     */
    private consoleOutput(entry: LogEntry): void {
        const parts: string[] = [];
        const styles: string[] = [];
        
        // Timestamp
        if (this.config.enableTimestamp) {
            parts.push(`[${this.formatTimestamp(entry.timestamp)}]`);
            styles.push('color: #666');
        }
        
        // Level
        parts.push(`[${this.levelNames[entry.level]}]`);
        styles.push(this.config.enableColors ? this.colors[entry.level] : '');
        
        // Category
        if (entry.category) {
            parts.push(`[${entry.category}]`);
            styles.push('color: #9C27B0');
        }
        
        // Message
        parts.push(entry.message);
        styles.push(this.config.enableColors ? this.colors[entry.level] : '');
        
        // Format for console
        const format = parts.map(() => '%c%s').join(' ');
        const args: any[] = [format];
        
        parts.forEach((part, index) => {
            args.push(styles[index]);
            args.push(part);
        });
        
        // Output based on level
        switch (entry.level) {
            case LogLevel.DEBUG:
                console.debug(...args);
                break;
            case LogLevel.INFO:
                console.info(...args);
                break;
            case LogLevel.WARN:
                console.warn(...args);
                break;
            case LogLevel.ERROR:
            case LogLevel.FATAL:
                console.error(...args);
                break;
        }
        
        // Log data if present
        if (entry.data !== undefined) {
            console.log('Data:', entry.data);
        }
        
        // Log stack if present
        if (entry.stack) {
            console.error('Stack trace:', entry.stack);
        }
    }

    /**
     * Format timestamp
     */
    private formatTimestamp(date: Date): string {
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const seconds = date.getSeconds().toString().padStart(2, '0');
        const ms = date.getMilliseconds().toString().padStart(3, '0');
        
        return `${hours}:${minutes}:${seconds}.${ms}`;
    }

    /**
     * Add log listener
     */
    public addListener(listener: (entry: LogEntry) => void): void {
        this.listeners.push(listener);
    }

    /**
     * Remove log listener
     */
    public removeListener(listener: (entry: LogEntry) => void): void {
        const index = this.listeners.indexOf(listener);
        if (index !== -1) {
            this.listeners.splice(index, 1);
        }
    }

    /**
     * Notify listeners
     */
    private notifyListeners(entry: LogEntry): void {
        this.listeners.forEach(listener => {
            try {
                listener(entry);
            } catch (error) {
                console.error('Error in log listener:', error);
            }
        });
    }

    /**
     * Get logs
     */
    public getLogs(level?: LogLevel, category?: string, limit?: number): LogEntry[] {
        let filtered = this.logs;
        
        // Filter by level
        if (level !== undefined) {
            filtered = filtered.filter(log => log.level >= level);
        }
        
        // Filter by category
        if (category) {
            filtered = filtered.filter(log => log.category === category);
        }
        
        // Apply limit
        if (limit && limit > 0) {
            filtered = filtered.slice(-limit);
        }
        
        return filtered;
    }

    /**
     * Clear logs
     */
    public clearLogs(): void {
        this.logs = [];
    }

    /**
     * Export logs
     */
    public exportLogs(format: 'json' | 'csv' = 'json'): string {
        if (format === 'json') {
            return JSON.stringify(this.logs, null, 2);
        } else {
            // CSV format
            const headers = ['Timestamp', 'Level', 'Category', 'Message', 'Data'];
            const rows = [headers];
            
            this.logs.forEach(log => {
                rows.push([
                    log.timestamp.toISOString(),
                    this.levelNames[log.level],
                    log.category || '',
                    log.message,
                    log.data ? JSON.stringify(log.data) : ''
                ]);
            });
            
            return rows.map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
        }
    }

    /**
     * Create performance logger
     */
    public startTimer(label: string): () => void {
        const start = performance.now();
        
        return () => {
            const duration = performance.now() - start;
            this.debug(`${label}: ${duration.toFixed(2)}ms`, { duration }, 'performance');
        };
    }

    /**
     * Log group (for better organization)
     */
    public group(label: string): void {
        if (this.config.enableConsole) {
            console.group(label);
        }
    }

    /**
     * End log group
     */
    public groupEnd(): void {
        if (this.config.enableConsole) {
            console.groupEnd();
        }
    }

    /**
     * Assert (log if condition is false)
     */
    public assert(condition: boolean, message: string, data?: any): void {
        if (!condition) {
            this.error(`Assertion failed: ${message}`, data, 'assertion');
        }
    }

    /**
     * Count occurrences
     */
    private counts: Map<string, number> = new Map();
    
    public count(label: string): void {
        const count = (this.counts.get(label) || 0) + 1;
        this.counts.set(label, count);
        this.debug(`${label}: ${count}`, { count }, 'counter');
    }

    /**
     * Reset count
     */
    public countReset(label: string): void {
        this.counts.delete(label);
    }

    /**
     * Table output (for structured data)
     */
    public table(data: any[], columns?: string[]): void {
        if (this.config.enableConsole && console.table) {
            console.table(data, columns);
        } else {
            this.info('Table data:', data);
        }
    }
}

==== FILE: src\core\ProjectManager.ts ====

import { Wall } from '../models/Wall';
import { BuildingElement } from '../models/BuildingElement';
import { Vector3 } from 'three';

export interface ProjectData {
    version: string;
    name: string;
    createdAt: string;
    modifiedAt: string;
    walls: any[];
    elements: any[];
}

export class ProjectManager {
    saveProjectAs(projectData: string) {
        throw new Error('Method not implemented.');
    }
    private static readonly VERSION = '1.0.0';
    openProject: any;

    // Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
    static saveProject(walls: Wall[], elements: BuildingElement[], projectName: string = 'Untitled Project'): string {
        const projectData: ProjectData = {
            version: this.VERSION,
            name: projectName,
            createdAt: new Date().toISOString(),
            modifiedAt: new Date().toISOString(),
            walls: walls.map(wall => wall.toJSON()),
            elements: elements.map(element => element.toJSON())
        };

        return JSON.stringify(projectData, null, 2);
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
    static loadProject(jsonData: string): { walls: Wall[], elements: BuildingElement[] } {
        try {
            const data: ProjectData = JSON.parse(jsonData);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥ØµØ¯Ø§Ø±
            if (!this.isVersionCompatible(data.version)) {
                throw new Error(`Incompatible project version: ${data.version}`);
            }

            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
            const walls = data.walls.map(wallData => Wall.fromJSON(wallData));

            // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¹Ù†Ø§ØµØ± (Ø³ÙŠØªÙ… ØªÙ†ÙÙŠØ°Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)
            const elements: BuildingElement[] = [];

            return { walls, elements };
        } catch (error) {
            throw new Error(`Failed to load project: ${error}`);
        }
    }

    // ØªØµØ¯ÙŠØ± ÙƒÙ…Ù„Ù
    static exportToFile(projectData: string, filename: string = 'project.json'): void {
        const blob = new Blob([projectData], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }

    // Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù† Ù…Ù„Ù
    static importFromFile(): Promise<string> {
        return new Promise((resolve, reject) => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (event) => {
                const file = (event.target as HTMLInputElement).files?.[0];
                if (!file) {
                    reject(new Error('No file selected'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target?.result as string;
                    resolve(content);
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            };

            input.click();
        });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆØ§ÙÙ‚ Ø§Ù„Ø¥ØµØ¯Ø§Ø±
    private static isVersionCompatible(version: string): boolean {
        const [major] = version.split('.');
        const [currentMajor] = this.VERSION.split('.');
        return major === currentMajor;
    }
}

==== FILE: src\core\Viewer.ts ====

import {
    WebGLRenderer, Scene, PerspectiveCamera, OrthographicCamera,
    GridHelper, AxesHelper, AmbientLight, DirectionalLight,
    Vector3, Vector2, Raycaster, Color, Line as ThreeLine, BufferGeometry,
    MeshStandardMaterial, Mesh,
    TextureLoader, Object3D, Plane, Fog,
    BufferAttribute
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Ø§Ù„ÙˆØ§Ø±Ø¯Ø§Øª Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { GeometryEngine, TessellationParams } from '../core/GeometryEngine';
import { Logger } from '../core/Logger';
import { GeometricObject } from '../models/GeometricObject';
import { Line } from '../models/Line';
import { Wall } from '../models/Wall';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Constants } from '../core/Constants';
import { CommandManager } from '../core/CommandManager';
import { BuildingElement } from '../models/BuildingElement';

// Ù†ÙˆØ¹ Ø¯Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ø£Ø­Ø¯Ø§Ø«
type EventListener = (data: any) => void;

// ÙˆØ§Ø¬Ù‡Ø© Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù‚Ø±Ø¨ Ø¬Ø¯Ø§Ø±
interface WallIntersection {
    wall: Wall;
    point: Vector3;
    distance: number;
}

export enum ViewMode {
    WIREFRAME = 'wireframe',
    SHADED = 'shaded',
    RENDERED = 'rendered',
    XRAY = 'xray'
}

export enum ViewOrientation {
    TOP = 'top',
    BOTTOM = 'bottom',
    FRONT = 'front',
    BACK = 'back',
    LEFT = 'left',
    RIGHT = 'right',
    ISOMETRIC = 'isometric'
}

/**
 * Viewer - Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ø¹Ø±Ø¶ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
 * 
 * Ù‡Ø°Ø§ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ø³Ø¤ÙˆÙ„ Ø¹Ù†:
 * - Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© ÙÙŠ Ù…Ø´Ù‡Ø¯ Three.js
 * - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„Ù…Ø§ÙˆØ³ØŒ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­)
 * - Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ GeometryEngine Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø´ÙƒØ§Ù„
 * - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª ÙˆØ§Ù„Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ§Ù„Ù…ÙˆØ§Ø¯
 */
export class Viewer {
    getPerformanceStats() {
        throw new Error('Method not implemented.');
    }
    updateViewSettings(_arg0: { showGrid: boolean; showAxes: boolean; }) {
        throw new Error('Method not implemented.');
    }
    private container: HTMLElement;
    private renderer!: WebGLRenderer;
    private scene2D!: Scene;
    private scene3D!: Scene;
    private camera2D!: OrthographicCamera;
    private camera3D!: PerspectiveCamera;
    private controls2D!: OrbitControls;
    private controls3D!: OrbitControls;
    private is2D: boolean = true;
    
    // Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ÙˆÙ†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    private geometryEngine: GeometryEngine;
    private logger: Logger;
    
    // Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
    private geometricObjects: Map<string, GeometricObject> = new Map();
    // Ù†Ø³ØªØ®Ø¯Ù… Mesh Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Object3D Ù„Ø£Ù†Ù†Ø§ Ù†ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø®ØµØ§Ø¦Øµ geometry Ùˆ material
    private objectMeshes2D: Map<string, Mesh[]> = new Map();
    private objectMeshes3D: Map<string, Mesh> = new Map();
    
    // Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ù†Ø§Ø¡ (Ø£Ø¨ÙˆØ§Ø¨ ÙˆÙ†ÙˆØ§ÙØ°)
    private buildingElements: Map<string, BuildingElement> = new Map();
    private elementMeshes2D: Map<string, Mesh> = new Map();
    private elementMeshes3D: Map<string, Mesh> = new Map();
    
    // Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ù…
    private isDrawing: boolean = false;
    private currentStartPoint: Vector3 | null = null;
    private previewLine: ThreeLine | null = null;
    
    // Ø£Ù†Ø¸Ù…Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©
    private commandManager: CommandManager = new CommandManager();
    private currentTool: 'line' | 'wall' | 'door' | 'window' = 'line';
    private snapSystem: SnapSystem | undefined;
    private measurementSystem!: MeasurementSystem;
    private raycaster: Raycaster = new Raycaster();
    private mouse: Vector2 = new Vector2();
    private intersectionPlane: Plane;
    
    // Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private eventListeners: Map<string, EventListener[]> = new Map();
    
    // Ù…Ø­Ù…Ù„ Ø§Ù„Ù†Ø³ÙŠØ¬
    private textureLoader: TextureLoader = new TextureLoader();
    
    // Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
    private initialized: boolean = false;

    constructor(container: HTMLElement) {
        console.log("CORE VIEWER: Constructor called.");
        this.container = container;
        this.intersectionPlane = new Plane(new Vector3(0, 0, 1), 0);
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø«ÙŠÙ„Ø§Øª
        this.geometryEngine = GeometryEngine.getInstance();
        this.logger = Logger.getInstance();
        this.commandManager = new CommandManager();
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        console.log("CORE VIEWER: Instance partially created, 'this' is:", this);
        this.initializeAsync().then(() => {
            console.log("CORE VIEWER: initializeAsync completed successfully.");
        }).catch(err => {
            console.error("CORE VIEWER: initializeAsync FAILED:", err);
        });
    }

    /**
     * Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ØºÙŠØ± Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø©
     * Ù†Ù†ØªØ¸Ø± ØªÙ‡ÙŠØ¦Ø© GeometryEngine Ù‚Ø¨Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
     */
    private async initializeAsync(): Promise<void> {
        try {
            console.log("CORE VIEWER: initializeAsync - START");
            this.logger.info('Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© Viewer...');
            
            // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
            await this.geometryEngine.initialize();
            console.log("CORE VIEWER: initializeAsync - GeometryEngine initialized.");
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
            this.renderer = this.createRenderer();
            console.log("CORE VIEWER: initializeAsync - Renderer created.");
            this.scene2D = this.createScene2D();
            this.scene3D = this.createScene3D();
            console.log("CORE VIEWER: initializeAsync - Scenes created.");
            this.camera2D = this.createCamera2D();
            this.camera3D = this.createCamera3D();
            console.log("CORE VIEWER: initializeAsync - Cameras created. camera2D:", this.camera2D, "camera3D:", this.camera3D);
            this.controls2D = this.createControls2D();
            this.controls3D = this.createControls3D();
            console.log("CORE VIEWER: initializeAsync - Controls created.");
            console.log("CORE VIEWER: initializeAsync - Lighting created.");
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
            this.snapSystem = new SnapSystem();
            this.measurementSystem = new MeasurementSystem(
                this.container,
                this.is2D ? this.camera2D : this.camera3D
            );
            console.log("CORE VIEWER: initializeAsync - Internal systems created.");
            
            // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ÙˆÙ„ÙŠ
            this.setup();
            this.animate();
            console.log("CORE VIEWER: initializeAsync - Setup methods called.");
            
            this.initialized = true;
            console.log("CORE VIEWER: initializeAsync - COMPLETING. 'initialized' flag set to true. Instance 'this':", this);
            console.log("CORE VIEWER: initializeAsync - typeof this.getCurrentCamera:", typeof this.getCurrentCamera);
            this.logger.info('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Viewer Ø¨Ù†Ø¬Ø§Ø­');
            
            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
            this.addTestShapes();
            
        } catch (error) {
            console.error("Viewer initializeAsync ERROR:", error);
            this.logger.error('ÙØ´Ù„Øª ØªÙ‡ÙŠØ¦Ø© Viewer:', error);
            this.initialized = false;
            throw error;
        }
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    private setup(): void {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø­Ø±Ùƒ Ù„Ù„Ø­Ø§ÙˆÙŠ
        this.container.appendChild(this.renderer.domElement);
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³
        this.setupMouseEvents();
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        this.setupKeyboardEvents();
        
        // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø´Ù‡Ø¯
        this.setupScenes();
        
        // Ù…Ø¹Ø§Ù„Ø¬ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        window.addEventListener('resize', this.onWindowResize.bind(this));
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø±Ùƒ
    private createRenderer(): WebGLRenderer {
        const renderer = new WebGLRenderer({ antialias: true });
        renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        return renderer;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ù‡Ø¯ 2D
    private createScene2D(): Scene {
        const scene = new Scene();
        scene.background = new Color(0xf5f5f5);
        return scene;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ù‡Ø¯ 3D
    private createScene3D(): Scene {
        const scene = new Scene();
        scene.background = new Color(0x222222);
        scene.fog = new Fog(0x222222, 50, 200);
        return scene;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ù…ÙŠØ±Ø§ 2D
    private createCamera2D(): OrthographicCamera {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        const frustumSize = Constants.CAMERA.FRUSTUM_SIZE_2D;
        const camera = new OrthographicCamera(
            -frustumSize * aspect / 2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            -frustumSize / 2,
            Constants.CAMERA.NEAR,
            Constants.CAMERA.FAR
        );
        camera.position.set(0, 0, 10);
        return camera;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ù…ÙŠØ±Ø§ 3D
    private createCamera3D(): PerspectiveCamera {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        const camera = new PerspectiveCamera(
            Constants.CAMERA.FOV_3D,
            aspect,
            Constants.CAMERA.NEAR,
            Constants.CAMERA.FAR
        );
        camera.position.set(30, 30, 30);
        camera.lookAt(0, 0, 0);
        return camera;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… 2D
    private createControls2D(): OrbitControls {
        const controls = new OrbitControls(this.camera2D, this.renderer.domElement);
        controls.enableRotate = false;
        controls.enablePan = true;
        controls.panSpeed = Constants.CONTROLS.PAN_SPEED;
        controls.zoomSpeed = Constants.CONTROLS.ZOOM_SPEED;
        controls.update();
        return controls;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… 3D
    private createControls3D(): OrbitControls {
        const controls = new OrbitControls(this.camera3D, this.renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = Constants.CONTROLS.DAMPING_FACTOR;
        controls.panSpeed = Constants.CONTROLS.PAN_SPEED;
        controls.zoomSpeed = Constants.CONTROLS.ZOOM_SPEED;
        controls.update();
        return controls;
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    private setupScenes(): void {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø´Ø¨ÙƒØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ± Ù„ÙƒÙ„Ø§ Ø§Ù„Ù…Ø´Ù‡Ø¯ÙŠÙ†
        [this.scene2D, this.scene3D].forEach(scene => {
            // Ø´Ø¨ÙƒØ©
            const grid = new GridHelper(
                Constants.GRID.DIVISIONS,
                Constants.GRID.DIVISIONS,
                Constants.GRID.COLOR,
                Constants.GRID.COLOR
            );
            
            if (scene === this.scene2D) {
                grid.rotation.x = Math.PI / 2;
            }
            
            scene.add(grid);
            
            // Ù…Ø­Ø§ÙˆØ±
            const axes = new AxesHelper(5);
            scene.add(axes);
            
            // Ø¥Ø¶Ø§Ø¡Ø©
            const ambientLight = new AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
        });
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ Ù„Ù„Ù…Ø´Ù‡Ø¯
     * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø¨ÙŠÙ† GeometricObject Ùˆ Three.js
     */
    private async addGeometricObject(object: GeometricObject): Promise<void> {
        try {
            // Ø­ÙØ¸ Ø§Ù„ÙƒØ§Ø¦Ù†
            this.geometricObjects.set(object.id, object);
            
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„ Ù…Ù† OpenCASCADE
            const ocHandle = object.getOCShape();
            
            // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø´Ø¨ÙƒØ© Ù…Ø«Ù„Ø«ÙŠØ©
            const tessellationParams: TessellationParams = {
                deflection: 0.1,
                angleDeflection: 0.5
            };
            
            const meshData = this.geometryEngine.tessellateShape(ocHandle, tessellationParams);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ù†Ø¯Ø³Ø© Three.js
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new BufferAttribute(meshData.vertices, 3));
            geometry.setIndex(Array.from(meshData.indices));
            
            if (meshData.normals) {
                geometry.setAttribute('normal', new BufferAttribute(meshData.normals, 3));
            } else {
                geometry.computeVertexNormals();
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒØ§Ø¦Ù†
            const visualProps = object.visualProperties;
            const material = new MeshStandardMaterial({
                color: visualProps.color,
                opacity: visualProps.opacity,
                transparent: visualProps.opacity < 1
            });
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø¨ÙƒØ©
            const mesh = new Mesh(geometry, material);
            mesh.userData.objectId = object.id;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª
            const transform = object.transform;
            mesh.position.set(
                transform.translation.x,
                transform.translation.y,
                transform.translation.z
            );
            
            // Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
            if (this.is2D) {
                this.scene2D.add(mesh);
                this.objectMeshes2D.set(object.id, [mesh]);
            } else {
                this.scene3D.add(mesh);
                this.objectMeshes3D.set(object.id, mesh);
            }
            
            this.logger.debug(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ Ù„Ù„Ù…Ø´Ù‡Ø¯: ${object.id}`);
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø­Ø¯Ø«
            this.emit('objectAdded', object);
            
        } catch (error) {
            this.logger.error(`ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ: ${object.id}`, error);
            throw error;
        }
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© Ø£Ø´ÙƒØ§Ù„ Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©
     * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙˆØ¶Ø­ ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
     */
    private async addTestShapes(): Promise<void> {
        try {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø¨Ø³ÙŠØ·
            const line1 = new Line(
                { x: -10, y: -10, z: 0 },
                { x: 10, y: -10, z: 0 }
            );
            
            const line2 = new Line(
                { x: 10, y: -10, z: 0 },
                { x: 10, y: 10, z: 0 }
            );
            
            const line3 = new Line(
                { x: 10, y: 10, z: 0 },
                { x: -10, y: 10, z: 0 }
            );
            
            const line4 = new Line(
                { x: -10, y: 10, z: 0 },
                { x: -10, y: -10, z: 0 }
            );
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø·ÙˆØ· Ù„Ù„Ù…Ø´Ù‡Ø¯
            await this.addGeometricObject(line1);
            await this.addGeometricObject(line2);
            await this.addGeometricObject(line3);
            await this.addGeometricObject(line4);
            
            this.logger.info('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©');
            
        } catch (error) {
            this.logger.error('ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©:', error);
        }
    }

    // Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©...
    
    private setupMouseEvents(): void {
        this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
        this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
        this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    private setupKeyboardEvents(): void {
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isDrawing) {
                this.cancelDrawing();
            }
            
            if (e.key === 'Delete') {
                this.deleteSelectedObjects();
            }
        });
    }

    private onMouseMove(e: MouseEvent): void {
        this.updateMousePosition(e);
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„ØªÙ…ÙŠÙŠØ²...
    }

    private onMouseDown(e: MouseEvent): void {
        if (e.button === 0 && this.is2D) {
            this.handleLeftClick();
        } else if (e.button === 2) {
            if (this.isDrawing) {
                this.cancelDrawing();
            } else {
                this.handleRightClick();
            }
        }
    }

    private onMouseUp(_e: MouseEvent): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø±ÙØ¹ Ø§Ù„Ù…Ø§ÙˆØ³
    }

    private handleLeftClick(): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø£ÙŠØ³Ø±
    }

    private handleRightClick(): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø£ÙŠÙ…Ù†
    }

    private cancelDrawing(): void {
        this.isDrawing = false;
        this.currentStartPoint = null;
        
        if (this.previewLine) {
            this.scene2D.remove(this.previewLine);
            this.previewLine = null;
        }
    }

    private deleteSelectedObjects(): void {
        this.geometricObjects.forEach(obj => {
            if (obj.selected) {
                this.removeGeometricObject(obj.id);
            }
        });
    }

    private removeGeometricObject(objectId: string): void {
        const object = this.geometricObjects.get(objectId);
        if (!object) return;
        
        // Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        this.geometricObjects.delete(objectId);
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù…Ø±Ø¦ÙŠ
        const meshes2D = this.objectMeshes2D.get(objectId);
        if (meshes2D) {
            meshes2D.forEach(mesh => {
                this.scene2D.remove(mesh);
                mesh.geometry.dispose();
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            });
            this.objectMeshes2D.delete(objectId);
        }
        
        const mesh3D = this.objectMeshes3D.get(objectId);
        if (mesh3D) {
            this.scene3D.remove(mesh3D);
            mesh3D.geometry.dispose();
            if (Array.isArray(mesh3D.material)) {
                mesh3D.material.forEach(m => m.dispose());
            } else {
                mesh3D.material.dispose();
            }
            this.objectMeshes3D.delete(objectId);
        }
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù†
        object.dispose();
        
        this.emit('objectRemoved', object);
    }

    private updateMousePosition(e: MouseEvent): void {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    private animate(): void {
        requestAnimationFrame(this.animate.bind(this));
        
        if (this.is2D) {
            this.controls2D.update();
        } else {
            this.controls3D.update();
        }
        
        this.render();
    }

    private render(): void {
        if (this.is2D) {
            this.renderer.render(this.scene2D, this.camera2D);
        } else {
            this.renderer.render(this.scene3D, this.camera3D);
        }
    }

    private onWindowResize(): void {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        const aspect = width / height;
        
        this.renderer.setSize(width, height);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ 2D
        const frustumSize = Constants.CAMERA.FRUSTUM_SIZE_2D;
        this.camera2D.left = -frustumSize * aspect / 2;
        this.camera2D.right = frustumSize * aspect / 2;
        this.camera2D.top = frustumSize / 2;
        this.camera2D.bottom = -frustumSize / 2;
        this.camera2D.updateProjectionMatrix();
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ 3D
        this.camera3D.aspect = aspect;
        this.camera3D.updateProjectionMatrix();
        
        this.render();
    }

    // Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    public on(event: string, listener: EventListener): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event)!.push(listener);
    }

    public off(event: string, listener: EventListener): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
    }

    private emit(event: string, data: any): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.forEach(listener => listener(data));
        }
    }

    // Ø¯ÙˆØ§Ù„ Ø¹Ø§Ù…Ø©
    public setView(is2D: boolean): void {
        this.is2D = is2D;
        this.measurementSystem.updateCamera(is2D ? this.camera2D : this.camera3D);
        this.emit('viewChanged', is2D);
    }

    public setCurrentTool(tool: 'line' | 'wall' | 'door' | 'window'): void {
        this.currentTool = tool;
        this.cancelDrawing();
    }

    /**
     * ØªØ¹ÙŠÙŠÙ† Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
     */
    public setViewOrientation(orientation: ViewOrientation): void {
        const distance = 50;
        let position: Vector3;
        let up = new Vector3(0, 1, 0);

        switch (orientation) {
            case ViewOrientation.TOP:
                position = new Vector3(0, distance, 0);
                up = new Vector3(0, 0, -1);
                break;
            case ViewOrientation.BOTTOM:
                position = new Vector3(0, -distance, 0);
                up = new Vector3(0, 0, 1);
                break;
            case ViewOrientation.FRONT:
                position = new Vector3(0, 0, distance);
                break;
            case ViewOrientation.BACK:
                position = new Vector3(0, 0, -distance);
                break;
            case ViewOrientation.LEFT:
                position = new Vector3(-distance, 0, 0);
                break;
            case ViewOrientation.RIGHT:
                position = new Vector3(distance, 0, 0);
                break;
            case ViewOrientation.ISOMETRIC:
                position = new Vector3(distance, distance, distance);
                break;
        }

        if (this.is2D && this.camera2D) {
            this.camera2D.position.copy(position);
            this.camera2D.up.copy(up);
            this.camera2D.lookAt(0, 0, 0);
            this.camera2D.updateProjectionMatrix();
            this.controls2D.update();
        } else if (!this.is2D && this.camera3D) {
            this.camera3D.position.copy(position);
            this.camera3D.up.copy(up);
            this.camera3D.lookAt(0, 0, 0);
            this.camera3D.updateProjectionMatrix();
            this.controls3D.update();
        }

        this.render();
        this.emit('viewOrientationChanged', orientation);
    }

    public isInitialized(): boolean {
        return this.initialized;
    }

    public getCurrentCamera(): PerspectiveCamera | OrthographicCamera {
        return this.is2D ? this.camera2D : this.camera3D;
    }
}

==== FILE: src\drawing_tools\AbstractDrawTool.ts ====

/**
 * AbstractDrawTool - Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„Ù„Ø±Ø³Ù…
 * ÙØ¦Ø© Ø£Ø³Ø§Ø³ÙŠØ© Ù…ØªØ·ÙˆØ±Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù… ÙˆØ§Ù„ØªØµÙ…ÙŠÙ…
 */

import { Vector3, Object3D, Mesh, BufferGeometry, Material } from 'three';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { Logger } from '../core/Logger';
import { CommandManager, Command } from '../core/CommandManager';
import { SnapSystem, SnapResult, SnapType } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { GeometricObject } from '../models/GeometricObject';

// Ø­Ø§Ù„Ø§Øª Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
export enum DrawToolState {
    IDLE = 'idle',
    ACTIVE = 'active',
    DRAWING = 'drawing',
    PREVIEW = 'preview',
    COMPLETED = 'completed',
    CANCELLED = 'cancelled',
    ERROR = 'error'
}

// Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø±Ø³Ù…
export enum DrawMode {
    SINGLE = 'single',           // Ø±Ø³Ù… ÙˆØ§Ø­Ø¯
    CONTINUOUS = 'continuous',   // Ø±Ø³Ù… Ù…ØªØªØ§Ø¨Ø¹
    CHAIN = 'chain',            // Ø±Ø³Ù… Ù…ØªØ³Ù„Ø³Ù„
    ARRAY = 'array'             // Ø±Ø³Ù… Ù…ØµÙÙˆÙØ©
}

// Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
export enum InputType {
    POINT = 'point',
    DISTANCE = 'distance',
    ANGLE = 'angle',
    TEXT = 'text',
    SELECTION = 'selection'
}

// Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
export interface DrawToolOptions {
    snapEnabled?: boolean;
    measurementEnabled?: boolean;
    previewEnabled?: boolean;
    autoComplete?: boolean;
    undoEnabled?: boolean;
    constraintsEnabled?: boolean;
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
    precision?: number;
    tolerance?: number;
    maxPoints?: number;
    minPoints?: number;
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ØµØ±ÙŠØ©
    previewColor?: string;
    previewOpacity?: number;
    highlightColor?: string;
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø³Ù„ÙˆÙƒ
    drawMode?: DrawMode;
    continuousMode?: boolean;
    chainMode?: boolean;
    orthoMode?: boolean;
    polarMode?: boolean;
}

// Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
export interface DrawResult {
    success: boolean;
    objectId?: string;
    objects?: GeometricObject[];
    error?: string;
    warnings?: string[];
    metrics?: {
        pointCount: number;
        totalLength?: number;
        area?: number;
        executionTime: number;
    };
}

// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
export interface InputPoint {
    position: Vector3;
    snapResult?: SnapResult;
    timestamp: number;
    inputType: InputType;
    metadata?: any;
}

// Ù‚ÙŠÙˆØ¯ Ø§Ù„Ø±Ø³Ù…
export interface DrawConstraints {
    minDistance?: number;
    maxDistance?: number;
    angleConstraint?: number[];  // Ø²ÙˆØ§ÙŠØ§ Ù…Ø³Ù…ÙˆØ­Ø©
    gridConstraint?: boolean;
    heightConstraint?: number;
    planeConstraint?: Vector3;   // Ø§Ù„ØªÙ‚ÙŠÙŠØ¯ Ù„Ù…Ø³ØªÙˆÙ‰ Ù…Ø¹ÙŠÙ†
}

// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
export interface PreviewInfo {
    isActive: boolean;
    geometry?: BufferGeometry;
    material?: Material;
    position?: Vector3;
    rotation?: Vector3;
    scale?: Vector3;
    metadata?: any;
}

// Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø©
export interface ToolStats {
    activationCount: number;
    completionCount: number;
    cancellationCount: number;
    errorCount: number;
    averageExecutionTime: number;
    totalPointsInput: number;
    averagePointsPerOperation: number;
}

/**
 * Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù…
 */
export abstract class AbstractDrawTool {
    protected geometryEngine: GeometryEngine;
    protected logger: Logger;
    protected commandManager: CommandManager;
    protected snapSystem: SnapSystem;
    protected measurementSystem: MeasurementSystem;
    
    // Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø¯Ø§Ø©
    protected state: DrawToolState = DrawToolState.IDLE;
    protected options: DrawToolOptions;
    protected constraints: DrawConstraints = {};
    
    // Ù†Ù‚Ø§Ø· Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
    protected inputPoints: InputPoint[] = [];
    protected currentPoint: Vector3 | null = null;
    protected lastSnapResult: SnapResult | null = null;
    
    // ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
    protected previewObjects: Object3D[] = [];
    protected previewInfo: PreviewInfo = { isActive: false };
    
    // Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø¯Ø§Ø© ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
    protected toolId: string;
    protected toolName: string;
    protected toolDescription: string;
    protected toolVersion: string = '1.0.0';
    
    // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private eventListeners: Map<string, Function[]> = new Map();
    
    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
    protected stats: ToolStats = {
        activationCount: 0,
        completionCount: 0,
        cancellationCount: 0,
        errorCount: 0,
        averageExecutionTime: 0,
        totalPointsInput: 0,
        averagePointsPerOperation: 0
    };
    
    // ØªÙˆÙ‚ÙŠØª Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    private operationStartTime: number = 0;
    private lastOperationTime: number = 0;
    
    // Ø°Ø§ÙƒØ±Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù…Ø¤Ù‚Øª
    private geometryCache: Map<string, any> = new Map();
    private resultCache: Map<string, DrawResult> = new Map();

    constructor(
        toolId: string,
        toolName: string,
        geometryEngine: GeometryEngine,
        commandManager: CommandManager,
        snapSystem: SnapSystem,
        measurementSystem: MeasurementSystem,
        options: DrawToolOptions = {}
    ) {
        this.toolId = toolId;
        this.toolName = toolName;
        this.toolDescription = `Ø£Ø¯Ø§Ø© ${toolName} Ù„Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…`;
        
        this.geometryEngine = geometryEngine;
        this.commandManager = commandManager;
        this.snapSystem = snapSystem;
        this.measurementSystem = measurementSystem;
        this.logger = Logger.getInstance();
        
        // Ø¯Ù…Ø¬ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        this.options = {
            snapEnabled: true,
            measurementEnabled: true,
            previewEnabled: true,
            autoComplete: false,
            undoEnabled: true,
            constraintsEnabled: true,
            precision: 0.001,
            tolerance: 0.1,
            maxPoints: 100,
            minPoints: 1,
            previewColor: '#2196F3',
            previewOpacity: 0.7,
            highlightColor: '#FF9800',
            drawMode: DrawMode.SINGLE,
            continuousMode: false,
            chainMode: false,
            orthoMode: false,
            polarMode: false,
            ...options
        };
        
        this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©: ${this.toolName} (${this.toolId})`);
    }

    // ==================== Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© ====================
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
     */
    protected abstract getRequiredPointCount(): number;
    
    /**
     * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
     */
    protected abstract validatePoints(): boolean;
    
    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù‡Ù†Ø¯Ø³Ø© Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·
     */
    protected abstract createGeometry(): GeometricObject | GeometricObject[] | null;
    
    /**
     * ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø±Ø³Ù…
     */
    protected abstract updatePreview(): void;
    
    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ø£Ø¯Ø§Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶
     */
    protected abstract getDisplayName(): string;
    
    /**
     * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø±Ø³Ù…
     */
    protected abstract canComplete(): boolean;

    // ==================== Ø¥Ø¯Ø§Ø±Ø© Ø¯ÙˆØ±Ø© Ø­ÙŠØ§Ø© Ø§Ù„Ø£Ø¯Ø§Ø© ====================
    
    /**
     * ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø©
     */
    public activate(): void {
        this.state = DrawToolState.ACTIVE;
        this.stats.activationCount++;
        this.operationStartTime = performance.now();
        
        this.resetTool();
        this.setupEventHandlers();
        
        this.emit('activated', { 
            toolId: this.toolId, 
            toolName: this.toolName,
            timestamp: Date.now()
        });
        
        this.logger.info(`ØªÙ… ØªÙØ¹ÙŠÙ„ Ø£Ø¯Ø§Ø©: ${this.getDisplayName()}`);
    }

    /**
     * Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø©
     */
    public deactivate(): void {
        this.cancelDrawing();
        this.cleanup();
        
        this.state = DrawToolState.IDLE;
        
        this.emit('deactivated', { 
            toolId: this.toolId,
            stats: this.getStats(),
            timestamp: Date.now()
        });
        
        this.logger.info(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„ Ø£Ø¯Ø§Ø©: ${this.getDisplayName()}`);
    }

    /**
     * ØªØ¹Ù„ÙŠÙ‚ Ø§Ù„Ø£Ø¯Ø§Ø© Ù…Ø¤Ù‚ØªØ§Ù‹
     */
    public suspend(): void {
        if (this.state === DrawToolState.ACTIVE || this.state === DrawToolState.DRAWING) {
            this.clearPreview();
            this.emit('suspended', { toolId: this.toolId });
        }
    }

    /**
     * Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ø£Ø¯Ø§Ø©
     */
    public resume(): void {
        if (this.state !== DrawToolState.IDLE) {
            this.updatePreview();
            this.emit('resumed', { toolId: this.toolId });
        }
    }

    // ==================== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ====================
    
    /**
     * Ù…Ø¹Ø§Ù„Ø¬ Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø§ÙˆØ³ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
     */
    public onMouseMove(point: Vector3, existingObjects: any[] = []): void {
        if (!this.isActiveState()) return;

        const startTime = performance.now();
        
        try {
            let finalPoint = point.clone();
            this.lastSnapResult = null;

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙŠÙˆØ¯
            finalPoint = this.applyConstraints(finalPoint);
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
            if (this.options.snapEnabled) {
                const snapResult = this.performSnapping(finalPoint, existingObjects);
                if (snapResult.snapped) {
                    finalPoint = snapResult.point.clone();
                    this.lastSnapResult = snapResult;
                    this.emit('snap', { 
                        snapResult, 
                        point: finalPoint,
                        snapType: snapResult.type 
                    });
                }
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            this.currentPoint = finalPoint;

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
            if (this.options.previewEnabled && this.shouldShowPreview()) {
                this.updatePreview();
            }

            // Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª
            if (this.options.measurementEnabled && this.shouldShowMeasurements()) {
                this.updateMeasurements();
            }

            // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø©
            this.updateStatusInfo();

            this.emit('mousemove', { 
                point: finalPoint, 
                originalPoint: point,
                snapResult: this.lastSnapResult,
                processingTime: performance.now() - startTime
            });
            
        } catch (error) {
            this.handleError('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø§ÙˆØ³', error);
        }
    }

    /**
     * Ù…Ø¹Ø§Ù„Ø¬ Ù†Ù‚Ø±Ø© Ø§Ù„Ù…Ø§ÙˆØ³ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
     */
    public onMouseClick(point: Vector3, existingObjects: any[] = []): DrawResult {
        if (!this.isActiveState()) {
            return { success: false, error: 'Ø§Ù„Ø£Ø¯Ø§Ø© ØºÙŠØ± Ù†Ø´Ø·Ø©' };
        }

        const startTime = performance.now();
        
        try {
            let finalPoint = point.clone();

            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙŠÙˆØ¯ ÙˆØ§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
            finalPoint = this.applyConstraints(finalPoint);
            
            if (this.options.snapEnabled) {
                const snapResult = this.performSnapping(finalPoint, existingObjects);
                if (snapResult.snapped) {
                    finalPoint = snapResult.point.clone();
                }
            }

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ù†Ù‚Ø·Ø©
            if (!this.isValidPoint(finalPoint)) {
                return { 
                    success: false, 
                    error: 'Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
                    warnings: ['ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙˆØ¯ ÙˆØ§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª']
                };
            }

            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø·Ø©
            const inputPoint: InputPoint = {
                position: finalPoint,
                snapResult: this.lastSnapResult || undefined,
                timestamp: Date.now(),
                inputType: InputType.POINT,
                metadata: this.gatherPointMetadata(finalPoint)
            };

            this.inputPoints.push(inputPoint);
            this.state = DrawToolState.DRAWING;
            this.stats.totalPointsInput++;

            this.logger.debug(`Ù†Ù‚Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø©: (${finalPoint.x.toFixed(3)}, ${finalPoint.y.toFixed(3)}, ${finalPoint.z.toFixed(3)})`);

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„
            if (this.canComplete() && 
                (this.options.autoComplete || this.inputPoints.length >= this.getRequiredPointCount())) {
                return this.completeDraw();
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ù„Ù„Ù†Ù‚Ø·Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
            this.updatePreview();

            const executionTime = performance.now() - startTime;
            this.emit('pointAdded', { 
                point: finalPoint, 
                pointIndex: this.inputPoints.length - 1,
                totalPoints: this.inputPoints.length,
                requiredPoints: this.getRequiredPointCount(),
                canComplete: this.canComplete(),
                executionTime
            });
            
            return { 
                success: true,
                metrics: {
                    pointCount: this.inputPoints.length,
                    executionTime
                }
            };
            
        } catch (error) {
            this.stats.errorCount++;
            return this.handleError('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Ù‚Ø±Ø©', error);
        }
    }

    /**
     * Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
     */
    public completeDraw(): DrawResult {
        const startTime = performance.now();
        
        try {
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø§Ù„Ø©
            if (!this.canComplete()) {
                return { 
                    success: false, 
                    error: 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø±Ø³Ù… ÙÙŠ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©',
                    warnings: ['ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª']
                };
            }

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            if (!this.validatePoints()) {
                return { 
                    success: false, 
                    error: 'Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©',
                    warnings: ['ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ÙˆØ§Ø¶Ø¹ ÙˆØ§Ù„Ù‚ÙŠÙˆØ¯']
                };
            }

            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
            const geometryResult = this.createGeometry();
            
            if (!geometryResult) {
                throw new Error('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ');
            }

            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØªÙŠØ¬Ø© (ÙƒØ§Ø¦Ù† ÙˆØ§Ø­Ø¯ Ø£Ùˆ Ù…ØªØ¹Ø¯Ø¯)
            const objects = Array.isArray(geometryResult) ? geometryResult : [geometryResult];
            const objectIds = objects.map(obj => obj.id);

            // Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªÙ†ÙÙŠØ° Ø§Ù„Ø£ÙˆØ§Ù…Ø±
            if (this.options.undoEnabled) {
                const commands = objects.map(obj => this.createAddCommand(obj));
                commands.forEach(cmd => this.commandManager.execute(cmd));
            }

            // ØªÙ†Ø¸ÙŠÙ ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†
            this.state = DrawToolState.COMPLETED;
            this.stats.completionCount++;
            
            const executionTime = performance.now() - startTime;
            this.updateExecutionStats(executionTime);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†ØªÙŠØ¬Ø©
            const result: DrawResult = {
                success: true,
                objectId: objects.length === 1 ? objects[0].id : undefined,
                objects: objects,
                metrics: {
                    pointCount: this.inputPoints.length,
                    executionTime,
                    totalLength: this.calculateTotalLength(),
                    area: this.calculateArea()
                }
            };

            // ØªÙ†Ø¸ÙŠÙ Ø£Ùˆ Ù…ØªØ§Ø¨Ø¹Ø© Ø­Ø³Ø¨ Ø§Ù„Ù†Ù…Ø·
            if (this.options.continuousMode) {
                this.prepareForNextDraw();
            } else {
                this.resetTool();
            }
            
            this.emit('completed', {
                result,
                toolId: this.toolId,
                objects,
                stats: this.getStats()
            });
            
            this.logger.info(`ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø±Ø³Ù… ${this.getDisplayName()}: ${objectIds.join(', ')}`);
            
            return result;
            
        } catch (error) {
            this.stats.errorCount++;
            return this.handleError('ÙØ´Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø±Ø³Ù…', error);
        }
    }

    /**
     * Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±Ø³Ù…
     */
    public cancelDrawing(): void {
        try {
            this.state = DrawToolState.CANCELLED;
            this.stats.cancellationCount++;
            
            this.clearPreview();
            this.clearMeasurements();
            this.resetTool();
            
            this.emit('cancelled', { 
                toolId: this.toolId,
                pointsEntered: this.inputPoints.length,
                timestamp: Date.now()
            });
            
            this.logger.debug(`ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø±Ø³Ù… ${this.getDisplayName()}`);
            
        } catch (error) {
            this.handleError('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø³Ù…', error);
        }
    }

    // ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ====================
    
    private performSnapping(point: Vector3, existingObjects: any[]): SnapResult {
        try {
            const referencePoint = this.inputPoints.length > 0 ? 
                this.inputPoints[this.inputPoints.length - 1].position : undefined;
            
            return this.snapSystem.snap(point, existingObjects, referencePoint);
            
        } catch (error) {
            this.logger.warn('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨:', error);
            return { point: point.clone(), snapped: false };
        }
    }

    // ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠÙˆØ¯ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ====================
    
    private applyConstraints(point: Vector3): Vector3 {
        let constrainedPoint = point.clone();
        
        try {
            // Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
            if (this.constraints.planeConstraint) {
                constrainedPoint = this.constrainToPlane(constrainedPoint, this.constraints.planeConstraint);
            }
            
            // Ù‚ÙŠØ¯ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
            if (this.constraints.heightConstraint !== undefined) {
                constrainedPoint.z = this.constraints.heightConstraint;
            }
            
            // Ù‚ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§ÙØ©
            if (this.inputPoints.length > 0 && this.constraints.minDistance) {
                const lastPoint = this.inputPoints[this.inputPoints.length - 1].position;
                const distance = constrainedPoint.distanceTo(lastPoint);
                
                if (distance < this.constraints.minDistance) {
                    const direction = constrainedPoint.clone().sub(lastPoint).normalize();
                    constrainedPoint = lastPoint.clone().add(direction.multiplyScalar(this.constraints.minDistance));
                }
            }
            
            // Ù‚ÙŠØ¯ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
            if (this.options.orthoMode) {
                constrainedPoint = this.constrainToOrtho(constrainedPoint);
            }
            
            if (this.options.polarMode) {
                constrainedPoint = this.constrainToPolar(constrainedPoint);
            }
            
        } catch (error) {
            this.logger.warn('Ø®Ø·Ø£ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙŠÙˆØ¯:', error);
        }
        
        return constrainedPoint;
    }

    private constrainToPlane(point: Vector3, planeNormal: Vector3): Vector3 {
        // Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
        const distance = point.dot(planeNormal);
        return point.clone().sub(planeNormal.clone().multiplyScalar(distance));
    }

    private constrainToOrtho(point: Vector3): Vector3 {
        if (this.inputPoints.length === 0) return point;
        
        const lastPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const diff = point.clone().sub(lastPoint);
        
        // Ø§Ø®ØªÙŠØ§Ø± Ø£Ù‚Ø±Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø£ÙˆØ±Ø«ÙˆØºÙˆÙ†Ø§Ù„ÙŠ
        const absX = Math.abs(diff.x);
        const absY = Math.abs(diff.y);
        const absZ = Math.abs(diff.z);
        
        if (absX >= absY && absX >= absZ) {
            return new Vector3(lastPoint.x + diff.x, lastPoint.y, lastPoint.z);
        } else if (absY >= absZ) {
            return new Vector3(lastPoint.x, lastPoint.y + diff.y, lastPoint.z);
        } else {
            return new Vector3(lastPoint.x, lastPoint.y, lastPoint.z + diff.z);
        }
    }

    private constrainToPolar(point: Vector3): Vector3 {
        if (this.inputPoints.length === 0) return point;
        
        const lastPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const diff = point.clone().sub(lastPoint);
        const angle = Math.atan2(diff.y, diff.x);
        const distance = diff.length();
        
        // Ø§Ù†Ø¬Ø°Ø§Ø¨ Ù„Ø£Ù‚Ø±Ø¨ Ø²Ø§ÙˆÙŠØ© 15 Ø¯Ø±Ø¬Ø©
        const snapAngle = Math.round(angle * 12 / Math.PI) * Math.PI / 12;
        
        return lastPoint.clone().add(new Vector3(
            Math.cos(snapAngle) * distance,
            Math.sin(snapAngle) * distance,
            0
        ));
    }

    // ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ====================
    
    protected shouldShowPreview(): boolean {
        return (this.options.previewEnabled ?? true) && 
               this.inputPoints.length > 0 && 
               this.currentPoint !== null &&
               this.state === DrawToolState.DRAWING;
    }

    protected shouldShowMeasurements(): boolean {
        return (this.options.measurementEnabled ?? true) && 
               this.inputPoints.length > 0 && 
               this.currentPoint !== null;
    }

    protected clearPreview(): void {
        try {
            this.previewObjects.forEach(obj => {
                if (obj.parent) {
                    obj.parent.remove(obj);
                }
                this.disposeObject(obj);
            });
            
            this.previewObjects = [];
            this.previewInfo = { isActive: false };
            
            this.emit('previewCleared', { toolId: this.toolId });
            
        } catch (error) {
            this.logger.warn('Ø®Ø·Ø£ ÙÙŠ Ù…Ø³Ø­ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©:', error);
        }
    }

    protected clearMeasurements(): void {
        try {
            this.measurementSystem.hidePreviewDimension();
        } catch (error) {
            this.logger.warn('Ø®Ø·Ø£ ÙÙŠ Ù…Ø³Ø­ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª:', error);
        }
    }

    private updateMeasurements(): void {
        if (this.inputPoints.length > 0 && this.currentPoint) {
            const lastPoint = this.inputPoints[this.inputPoints.length - 1].position;
            this.measurementSystem.showPreviewDimension(lastPoint, this.currentPoint);
        }
    }

    private updateStatusInfo(): void {
        const info = {
            toolName: this.getDisplayName(),
            state: this.state,
            pointCount: this.inputPoints.length,
            requiredPoints: this.getRequiredPointCount(),
            canComplete: this.canComplete(),
            currentPoint: this.currentPoint?.clone(),
            lastSnap: this.lastSnapResult
        };
        
        this.emit('statusUpdate', info);
    }

    // ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡ ====================
    
    private disposeObject(obj: Object3D): void {
        try {
            if (obj instanceof Mesh) {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            }
            
            obj.children.forEach(child => this.disposeObject(child));
            
        } catch (error) {
            this.logger.warn('Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù†:', error);
        }
    }

    private updateExecutionStats(executionTime: number): void {
        const totalOperations = this.stats.completionCount;
        this.stats.averageExecutionTime = 
            (this.stats.averageExecutionTime * (totalOperations - 1) + executionTime) / totalOperations;
        
        this.stats.averagePointsPerOperation = 
            this.stats.totalPointsInput / totalOperations;
        
        this.lastOperationTime = executionTime;
    }

    // ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================
    
    protected resetTool(): void {
        this.inputPoints = [];
        this.currentPoint = null;
        this.lastSnapResult = null;
        this.clearPreview();
        this.clearMeasurements();
        
        if (this.state === DrawToolState.DRAWING || this.state === DrawToolState.COMPLETED) {
            this.state = DrawToolState.ACTIVE;
        }
    }

    protected prepareForNextDraw(): void {
        // ÙÙŠ Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ù…ØªØªØ§Ø¨Ø¹ØŒ Ø§Ø­ØªÙØ¸ Ø¨Ø¨Ø¹Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
        const lastPoint = this.inputPoints.length > 0 ? 
            this.inputPoints[this.inputPoints.length - 1] : null;
        
        this.inputPoints = [];
        this.currentPoint = null;
        this.lastSnapResult = null;
        this.clearPreview();
        
        // ÙÙŠ Ù†Ù…Ø· Ø§Ù„Ø³Ù„Ø³Ù„Ø©ØŒ Ø§Ø¨Ø¯Ø£ Ø¨Ø¢Ø®Ø± Ù†Ù‚Ø·Ø©
        if (this.options.chainMode && lastPoint) {
            this.inputPoints.push(lastPoint);
        }
        
        this.state = DrawToolState.ACTIVE;
    }

    private isActiveState(): boolean {
        return this.state === DrawToolState.ACTIVE || this.state === DrawToolState.DRAWING;
    }

    private isValidPoint(point: Vector3): boolean {
        if (!point || !isFinite(point.x) || !isFinite(point.y) || !isFinite(point.z)) {
            return false;
        }
        
        // ÙØ­Øµ Ø§Ù„ØªÙƒØ±Ø§Ø±
        const tolerance = this.options.tolerance || 0.1;
        return !this.inputPoints.some(inputPoint => 
            inputPoint.position.distanceTo(point) < tolerance
        );
    }

    private gatherPointMetadata(_point: Vector3): any {
        return {
            snapType: this.lastSnapResult?.type,
            constraints: { ...this.constraints },
            timestamp: Date.now(),
            precision: this.options.precision
        };
    }

    private calculateTotalLength(): number {
        if (this.inputPoints.length < 2) return 0;
        
        let totalLength = 0;
        for (let i = 1; i < this.inputPoints.length; i++) {
            totalLength += this.inputPoints[i].position.distanceTo(this.inputPoints[i - 1].position);
        }
        
        return totalLength;
    }

    private calculateArea(): number {
        // ØªÙ†ÙÙŠØ° Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù…ØºÙ„Ù‚Ø©
        if (this.inputPoints.length < 3) return 0;
        
        // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø¶Ù„Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØµÙŠØºØ© Ø§Ù„Ø­Ø°Ø§Ø¡
        let area = 0;
        const points = this.inputPoints.map(ip => ip.position);
        
        for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
        }
        
        return Math.abs(area) / 2;
    }

    private setupEventHandlers(): void {
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø£Ø¯Ø§Ø©
    }

    private cleanup(): void {
        this.clearPreview();
        this.clearMeasurements();
        this.geometryCache.clear();
        this.resultCache.clear();
    }

    private handleError(message: string, error: any): DrawResult {
        this.logger.error(`${message} ÙÙŠ ${this.getDisplayName()}:`, error);
        this.state = DrawToolState.ERROR;
        
        return {
            success: false,
            error: `${message}: ${error instanceof Error ? error.message : 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`
        };
    }

    protected abstract createAddCommand(object: GeometricObject): Command;

    // ==================== ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø§Ù…Ø© ====================
    
    public getToolInfo(): { 
        id: string; 
        name: string; 
        displayName: string;
        description: string;
        version: string;
        state: DrawToolState; 
        pointCount: number; 
        requiredPoints: number;
        canComplete: boolean;
        options: DrawToolOptions;
        constraints: DrawConstraints;
    } {
        return {
            id: this.toolId,
            name: this.toolName,
            displayName: this.getDisplayName(),
            description: this.toolDescription,
            version: this.toolVersion,
            state: this.state,
            pointCount: this.inputPoints.length,
            requiredPoints: this.getRequiredPointCount(),
            canComplete: this.canComplete(),
            options: { ...this.options },
            constraints: { ...this.constraints }
        };
    }

    public updateOptions(newOptions: Partial<DrawToolOptions>): void {
        this.options = { ...this.options, ...newOptions };
        this.emit('optionsUpdated', { toolId: this.toolId, options: this.options });
        this.logger.debug(`ØªÙ… ØªØ­Ø¯ÙŠØ« Ø®ÙŠØ§Ø±Ø§Øª ${this.getDisplayName()}`, newOptions);
    }

    public setConstraints(constraints: Partial<DrawConstraints>): void {
        this.constraints = { ...this.constraints, ...constraints };
        this.emit('constraintsUpdated', { toolId: this.toolId, constraints: this.constraints });
        this.logger.debug(`ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚ÙŠÙˆØ¯ ${this.getDisplayName()}`, constraints);
    }

    public getStats(): ToolStats {
        return { ...this.stats };
    }

    public resetStats(): void {
        this.stats = {
            activationCount: 0,
            completionCount: 0,
            cancellationCount: 0,
            errorCount: 0,
            averageExecutionTime: 0,
            totalPointsInput: 0,
            averagePointsPerOperation: 0
        };
        
        this.emit('statsReset', { toolId: this.toolId });
    }

    // ==================== Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ====================
    
    public on(event: string, listener: Function): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event)!.push(listener);
    }

    public off(event: string, listener: Function): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
    }

    protected emit(event: string, data: any): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.forEach(listener => {
                try {
                    listener(data);
                } catch (error) {
                    this.logger.error(`Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø­Ø¯Ø« ${event} Ù„Ø£Ø¯Ø§Ø© ${this.toolId}:`, error);
                }
            });
        }
    }

    // ==================== ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ ====================
    
    public dispose(): void {
        try {
            this.cancelDrawing();
            this.cleanup();
            this.eventListeners.clear();
            
            this.logger.debug(`ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø£Ø¯Ø§Ø© Ø§Ù„Ø±Ø³Ù…: ${this.toolId}`);
            
        } catch (error) {
            this.logger.error(`Ø®Ø·Ø£ ÙÙŠ ØªÙ†Ø¸ÙŠÙ Ø£Ø¯Ø§Ø© ${this.toolId}:`, error);
        }
    }
}

==== FILE: src\drawing_tools\DrawArcTool.ts ====

/**
 * DrawArcTool - Arc Drawing Tool
 * Tool for drawing arcs with multiple methods
 */

import { Vector3, BufferGeometry, LineBasicMaterial, Line as ThreeLine, EllipseCurve } from 'three';
import { AbstractDrawTool, DrawToolOptions, DrawResult, DrawMode } from './AbstractDrawTool';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { CommandManager, Command } from '../core/CommandManager';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Arc } from '../models/Arc';
import { GeometricObject } from '../models/GeometricObject';

// Arc drawing modes
export enum ArcDrawMode {
    THREE_POINTS = 'three-points',          // Three points on arc
    CENTER_START_END = 'center-start-end',  // Center + start + end points
    CENTER_START_ANGLE = 'center-start-angle', // Center + start + angle
    START_END_RADIUS = 'start-end-radius',  // Start + end + radius
    TANGENT = 'tangent'                     // Tangent to existing curves
}

// Arc-specific options
export interface ArcToolOptions extends DrawToolOptions {
    arcDrawMode?: ArcDrawMode;
    showRadius?: boolean;
    showAngle?: boolean;
    showArcLength?: boolean;
    showChordLength?: boolean;
    angleIncrement?: number;
    defaultAngle?: number;
    clockwise?: boolean;
}

// Arc information
export interface ArcInfo {
    center: Point3D;
    radius: number;
    startAngle: number;
    endAngle: number;
    sweepAngle: number;
    arcLength: number;
    chordLength: number;
    startPoint: Point3D;
    endPoint: Point3D;
    midPoint: Point3D;
}

// Add arc command
class AddArcCommand implements Command {
    private arc: Arc;
    private viewer: any;

    constructor(arc: Arc, viewer: any) {
        this.arc = arc;
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer?.addGeometricObject(this.arc);
    }

    undo(): void {
        this.viewer?.removeGeometricObject(this.arc.id);
    }

    getDescription(): string {
        return `Add arc: ${this.arc.id}`;
    }
}

/**
 * Arc Drawing Tool
 */
export class DrawArcTool extends AbstractDrawTool {
    private arcDrawMode: ArcDrawMode = ArcDrawMode.THREE_POINTS;
    private previewArc: ThreeLine | null = null;
    private currentArcInfo: ArcInfo | null = null;
    private viewer: any = null;

    // Arc-specific settings
    private arcOptions: ArcToolOptions;
    
    // Helper lines
    private helperLines: ThreeLine[] = [];

    constructor(
        geometryEngine: GeometryEngine,
        commandManager: CommandManager,
        snapSystem: SnapSystem,
        measurementSystem: MeasurementSystem,
        options: ArcToolOptions = {},
        mode: ArcDrawMode = ArcDrawMode.THREE_POINTS
    ) {
        super(
            'draw-arc',
            'Draw Arc',
            geometryEngine,
            commandManager,
            snapSystem,
            measurementSystem,
            {
                snapEnabled: true,
                measurementEnabled: true,
                previewEnabled: true,
                autoComplete: true,
                undoEnabled: true,
                constraintsEnabled: true,
                precision: 0.001,
                tolerance: 0.1,
                maxPoints: 3,
                minPoints: 3,
                drawMode: DrawMode.SINGLE,
                ...options
            }
        );

        this.arcDrawMode = mode;
        this.arcOptions = {
            ...this.options,
            arcDrawMode: mode,
            showRadius: true,
            showAngle: true,
            showArcLength: true,
            showChordLength: false,
            angleIncrement: 15,
            defaultAngle: 90,
            clockwise: false,
            ...options
        } as ArcToolOptions;
    }

    // ==================== Required Abstract Functions ====================

    protected getRequiredPointCount(): number {
        switch (this.arcDrawMode) {
            case ArcDrawMode.THREE_POINTS:
                return 3;
            case ArcDrawMode.CENTER_START_END:
                return 3;
            case ArcDrawMode.CENTER_START_ANGLE:
                return 2; // Center + start (angle via mouse)
            case ArcDrawMode.START_END_RADIUS:
                return 3; // Start + end + radius point
            case ArcDrawMode.TANGENT:
                return 3;
            default:
                return 3;
        }
    }

    protected validatePoints(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        switch (this.arcDrawMode) {
            case ArcDrawMode.THREE_POINTS:
                return this.validateThreePoints();
            case ArcDrawMode.CENTER_START_END:
                return this.validateCenterStartEnd();
            case ArcDrawMode.CENTER_START_ANGLE:
                return this.validateCenterStartAngle();
            case ArcDrawMode.START_END_RADIUS:
                return this.validateStartEndRadius();
            default:
                return false;
        }
    }

    protected createGeometry(): GeometricObject | null {
        if (!this.validatePoints()) {
            return null;
        }

        try {
            switch (this.arcDrawMode) {
                case ArcDrawMode.THREE_POINTS:
                    return this.createThreePointsArc();
                case ArcDrawMode.CENTER_START_END:
                    return this.createCenterStartEndArc();
                case ArcDrawMode.CENTER_START_ANGLE:
                    return this.createCenterStartAngleArc();
                case ArcDrawMode.START_END_RADIUS:
                    return this.createStartEndRadiusArc();
                default:
                    return null;
            }
        } catch (error) {
            this.logger.error('Failed to create arc:', error);
            return null;
        }
    }

    protected updatePreview(): void {
        if (!this.shouldShowPreview()) {
            this.clearPreview();
            return;
        }

        try {
            this.clearPreview();
            
            if (this.inputPoints.length > 0 && this.currentPoint) {
                this.calculateCurrentArcInfo();
                
                if (this.currentArcInfo) {
                    this.createArcPreview();
                    this.showHelperLines();
                    this.updateMeasurementDisplay();
                }
            }
        } catch (error) {
            this.logger.error('Failed to update arc preview:', error);
        }
    }

    protected getDisplayName(): string {
        const modeNames = {
            [ArcDrawMode.THREE_POINTS]: 'Arc (Three Points)',
            [ArcDrawMode.CENTER_START_END]: 'Arc (Center, Start, End)',
            [ArcDrawMode.CENTER_START_ANGLE]: 'Arc (Center, Start, Angle)',
            [ArcDrawMode.START_END_RADIUS]: 'Arc (Start, End, Radius)',
            [ArcDrawMode.TANGENT]: 'Arc (Tangent)'
        };
        
        return modeNames[this.arcDrawMode] || 'Draw Arc';
    }

    protected canComplete(): boolean {
        return this.inputPoints.length >= this.getRequiredPointCount() && 
               this.validatePoints() && 
               this.currentArcInfo !== null;
    }

    protected createAddCommand(object: GeometricObject): Command {
        return new AddArcCommand(object as Arc, this.viewer);
    }

    // ==================== Validation Methods ====================

    private validateThreePoints(): boolean {
        if (this.inputPoints.length < 3) return false;
        
        const [p1, p2, p3] = this.inputPoints.map(ip => ip.position);
        
        // Check if points are collinear
        const area = this.calculateTriangleArea(p1, p2, p3);
        if (Math.abs(area) < this.options.tolerance!) {
            this.logger.warn('Three points are collinear');
            return false;
        }

        return true;
    }

    private validateCenterStartEnd(): boolean {
        if (this.inputPoints.length < 3) return false;
        
        const center = this.inputPoints[0].position;
        const start = this.inputPoints[1].position;
        const end = this.inputPoints[2].position;
        
        const radius1 = center.distanceTo(start);
        const radius2 = center.distanceTo(end);
        
        // Check if points are equidistant from center
        if (Math.abs(radius1 - radius2) > this.options.tolerance!) {
            this.logger.warn('Start and end points must be equidistant from center');
            return false;
        }

        return radius1 > this.options.tolerance!;
    }

    private validateCenterStartAngle(): boolean {
        if (this.inputPoints.length < 2) return false;
        
        const center = this.inputPoints[0].position;
        const start = this.inputPoints[1].position;
        const radius = center.distanceTo(start);
        
        return radius > this.options.tolerance!;
    }

    private validateStartEndRadius(): boolean {
        if (this.inputPoints.length < 3) return false;
        
        const start = this.inputPoints[0].position;
        const end = this.inputPoints[1].position;
        const distance = start.distanceTo(end);
        
        return distance > this.options.tolerance!;
    }

    // ==================== Arc Creation Methods ====================

    private createThreePointsArc(): Arc {
        const [p1, p2, p3] = this.inputPoints.map(ip => ip.position);
        
        const circleInfo = this.calculateCircleFromThreePoints(p1, p2, p3);
        if (!circleInfo) {
            throw new Error('Failed to calculate arc from three points');
        }
        
        const center = circleInfo.center;
        const radius = circleInfo.radius;
        
        const startAngle = Math.atan2(p1.y - center.y, p1.x - center.x);
        const endAngle = Math.atan2(p3.y - center.y, p3.x - center.x);
        
        const arc = new Arc(
            { x: center.x, y: center.y, z: center.z },
            radius,
            startAngle,
            endAngle
        );
        
        this.logger.info(`Created three-point arc: ${arc.id}`);
        return arc;
    }

    private createCenterStartEndArc(): Arc {
        const center = this.inputPoints[0].position;
        const startPoint = this.inputPoints[1].position;
        const endPoint = this.inputPoints[2].position;
        
        const radius = center.distanceTo(startPoint);
        const startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
        const endAngle = Math.atan2(endPoint.y - center.y, endPoint.x - center.x);
        
        const arc = new Arc(
            { x: center.x, y: center.y, z: center.z },
            radius,
            startAngle,
            endAngle
        );
        
        this.logger.info(`Created center-start-end arc: ${arc.id}`);
        return arc;
    }

    private createCenterStartAngleArc(): Arc {
        // This method would need angle input from current mouse position
        const center = this.inputPoints[0].position;
        const startPoint = this.inputPoints[1].position;
        
        const radius = center.distanceTo(startPoint);
        const startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
        
        // Calculate end angle based on current arc info
        if (!this.currentArcInfo) {
            throw new Error('No arc info available');
        }
        
        const arc = new Arc(
            { x: center.x, y: center.y, z: center.z },
            radius,
            startAngle,
            this.currentArcInfo.endAngle
        );
        
        this.logger.info(`Created center-start-angle arc: ${arc.id}`);
        return arc;
    }

    private createStartEndRadiusArc(): Arc {
        const start = this.inputPoints[0].position;
        const end = this.inputPoints[1].position;
        const radiusPoint = this.inputPoints[2].position;
        
        // Calculate center and radius from three constraints
        const centerInfo = this.calculateCenterFromStartEndRadius(start, end, radiusPoint);
        if (!centerInfo) {
            throw new Error('Failed to calculate arc center');
        }
        
        const startAngle = Math.atan2(start.y - centerInfo.center.y, start.x - centerInfo.center.x);
        const endAngle = Math.atan2(end.y - centerInfo.center.y, end.x - centerInfo.center.x);
        
        const arc = new Arc(
            { x: centerInfo.center.x, y: centerInfo.center.y, z: centerInfo.center.z },
            centerInfo.radius,
            startAngle,
            endAngle
        );
        
        this.logger.info(`Created start-end-radius arc: ${arc.id}`);
        return arc;
    }

    // ==================== Arc Calculations ====================

    private calculateCurrentArcInfo(): void {
        this.currentArcInfo = null;
        
        try {
            let center: Vector3;
            let radius: number;
            let startAngle: number;
            let endAngle: number;

            switch (this.arcDrawMode) {
                case ArcDrawMode.THREE_POINTS:
                    if (this.inputPoints.length >= 2 && this.currentPoint) {
                        const p1 = this.inputPoints[0].position;
                        const p2 = this.inputPoints[1].position;
                        const circleInfo = this.calculateCircleFromThreePoints(p1, p2, this.currentPoint);
                        if (!circleInfo) return;
                        
                        center = circleInfo.center;
                        radius = circleInfo.radius;
                        startAngle = Math.atan2(p1.y - center.y, p1.x - center.x);
                        endAngle = Math.atan2(this.currentPoint.y - center.y, this.currentPoint.x - center.x);
                    } else {
                        return;
                    }
                    break;

                case ArcDrawMode.CENTER_START_END:
                    if (this.inputPoints.length >= 2 && this.currentPoint) {
                        center = this.inputPoints[0].position;
                        const startPoint = this.inputPoints[1].position;
                        radius = center.distanceTo(startPoint);
                        startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
                        endAngle = Math.atan2(this.currentPoint.y - center.y, this.currentPoint.x - center.x);
                    } else if (this.inputPoints.length >= 1 && this.currentPoint) {
                        center = this.inputPoints[0].position;
                        radius = center.distanceTo(this.currentPoint);
                        startAngle = 0;
                        endAngle = Math.PI / 2;
                    } else {
                        return;
                    }
                    break;

                case ArcDrawMode.CENTER_START_ANGLE:
                    if (this.inputPoints.length >= 1 && this.currentPoint) {
                        center = this.inputPoints[0].position;
                        radius = center.distanceTo(this.currentPoint);
                        startAngle = Math.atan2(this.currentPoint.y - center.y, this.currentPoint.x - center.x);
                        
                        if (this.inputPoints.length >= 2) {
                            const startPoint = this.inputPoints[1].position;
                            radius = center.distanceTo(startPoint);
                            startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
                            endAngle = Math.atan2(this.currentPoint.y - center.y, this.currentPoint.x - center.x);
                        } else {
                            endAngle = startAngle + (this.arcOptions.defaultAngle || 90) * Math.PI / 180;
                        }
                    } else {
                        return;
                    }
                    break;

                default:
                    return;
            }

            const sweepAngle = this.calculateSweepAngle(startAngle, endAngle);
            const arcLength = radius * Math.abs(sweepAngle);
            
            const startPoint = new Vector3(
                center.x + radius * Math.cos(startAngle),
                center.y + radius * Math.sin(startAngle),
                center.z
            );
            
            const endPoint = new Vector3(
                center.x + radius * Math.cos(endAngle),
                center.y + radius * Math.sin(endAngle),
                center.z
            );
            
            const midAngle = startAngle + sweepAngle / 2;
            const midPoint = new Vector3(
                center.x + radius * Math.cos(midAngle),
                center.y + radius * Math.sin(midAngle),
                center.z
            );
            
            const chordLength = startPoint.distanceTo(endPoint);

            this.currentArcInfo = {
                center: { x: center.x, y: center.y, z: center.z },
                radius,
                startAngle,
                endAngle,
                sweepAngle,
                arcLength,
                chordLength,
                startPoint: { x: startPoint.x, y: startPoint.y, z: startPoint.z },
                endPoint: { x: endPoint.x, y: endPoint.y, z: endPoint.z },
                midPoint: { x: midPoint.x, y: midPoint.y, z: midPoint.z }
            };

            this.emit('arcInfoUpdated', this.currentArcInfo);

        } catch (error) {
            this.logger.error('Failed to calculate arc info:', error);
        }
    }

    private calculateSweepAngle(startAngle: number, endAngle: number): number {
        let sweep = endAngle - startAngle;
        
        if (this.arcOptions.clockwise) {
            if (sweep > 0) sweep -= 2 * Math.PI;
        } else {
            if (sweep < 0) sweep += 2 * Math.PI;
        }
        
        return sweep;
    }

    private calculateCircleFromThreePoints(p1: Vector3, p2: Vector3, p3: Vector3): { center: Vector3; radius: number } | null {
        const ax = p1.x, ay = p1.y;
        const bx = p2.x, by = p2.y;
        const cx = p3.x, cy = p3.y;

        const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
        
        if (Math.abs(d) < this.options.tolerance!) {
            return null;
        }

        const ux = ((ax * ax + ay * ay) * (by - cy) + 
                    (bx * bx + by * by) * (cy - ay) + 
                    (cx * cx + cy * cy) * (ay - by)) / d;
        
        const uy = ((ax * ax + ay * ay) * (cx - bx) + 
                    (bx * bx + by * by) * (ax - cx) + 
                    (cx * cx + cy * cy) * (bx - ax)) / d;

        const center = new Vector3(ux, uy, p1.z);
        const radius = center.distanceTo(p1);

        return { center, radius };
    }

    private calculateCenterFromStartEndRadius(start: Vector3, end: Vector3, radiusPoint: Vector3): { center: Vector3; radius: number } | null {
        // Calculate midpoint
        const mid = new Vector3().addVectors(start, end).multiplyScalar(0.5);
        
        // Calculate chord length
        const chordLength = start.distanceTo(end);
        
        // Calculate perpendicular direction
        const chordDir = new Vector3().subVectors(end, start).normalize();
        const perpDir = new Vector3(-chordDir.y, chordDir.x, 0);
        
        // Estimate radius from mouse position
        const estimatedRadius = mid.distanceTo(radiusPoint);
        
        // Calculate center offset
        const halfChord = chordLength / 2;
        if (estimatedRadius < halfChord) return null;
        
        const offset = Math.sqrt(estimatedRadius * estimatedRadius - halfChord * halfChord);
        
        // Determine which side of chord
        const toPoint = new Vector3().subVectors(radiusPoint, mid);
        const side = toPoint.dot(perpDir) > 0 ? 1 : -1;
        
        const center = mid.clone().add(perpDir.multiplyScalar(offset * side));
        
        return { center, radius: estimatedRadius };
    }

    private calculateTriangleArea(p1: Vector3, p2: Vector3, p3: Vector3): number {
        return 0.5 * Math.abs(
            (p2.x - p1.x) * (p3.y - p1.y) - 
            (p3.x - p1.x) * (p2.y - p1.y)
        );
    }

    // ==================== Preview Methods ====================

    private createArcPreview(): void {
        if (!this.currentArcInfo) return;

        const { center, radius, startAngle, endAngle } = this.currentArcInfo;
        
        // Create arc curve
        const curve = new EllipseCurve(
            center.x, center.y,
            radius, radius,
            startAngle, endAngle,
            false,
            0
        );
        
        const points = curve.getPoints(64);
        const geometry = new BufferGeometry().setFromPoints(points);
        
        const material = new LineBasicMaterial({
            color: this.arcOptions.previewColor || '#2196F3',
            linewidth: 2
        });
        
        this.previewArc = new ThreeLine(geometry, material);
        this.previewArc.position.z = center.z;
        
        this.previewObjects.push(this.previewArc);
        this.emit('previewObjectCreated', this.previewArc);
    }

    private showHelperLines(): void {
        if (!this.currentArcInfo) return;
        
        const { center, radius, startPoint, endPoint } = this.currentArcInfo;
        const centerVec = new Vector3(center.x, center.y, center.z);
        
        // Create radius lines
        if (this.arcOptions.showRadius) {
            const startVec = new Vector3(startPoint.x, startPoint.y, startPoint.z);
            const endVec = new Vector3(endPoint.x, endPoint.y, endPoint.z);
            
            [startVec, endVec].forEach(point => {
                const geometry = new BufferGeometry().setFromPoints([centerVec, point]);
                const material = new LineBasicMaterial({
                    color: '#FF9800',
                    opacity: 0.6,
                    transparent: true
                });
                
                const radiusLine = new ThreeLine(geometry, material);
                this.helperLines.push(radiusLine);
                this.previewObjects.push(radiusLine);
                this.emit('previewObjectCreated', radiusLine);
            });
        }
    }

    private updateMeasurementDisplay(): void {
        if (!this.currentArcInfo) return;
        
        const { center, radius, sweepAngle, arcLength, chordLength } = this.currentArcInfo;
        
        // Show radius
        if (this.arcOptions.showRadius) {
            this.emit('measurementUpdate', {
                type: 'radius',
                value: `R: ${this.formatLength(radius)}`,
                position: center
            });
        }
        
        // Show angle
        if (this.arcOptions.showAngle) {
            const angleDegrees = Math.abs(sweepAngle) * 180 / Math.PI;
            this.emit('measurementUpdate', {
                type: 'angle',
                value: `${angleDegrees.toFixed(1)}Â°`,
                position: center
            });
        }
        
        // Show arc length
        if (this.arcOptions.showArcLength) {
            this.emit('measurementUpdate', {
                type: 'arcLength',
                value: `Arc: ${this.formatLength(arcLength)}`,
                position: this.currentArcInfo.midPoint
            });
        }
        
        // Show chord length
        if (this.arcOptions.showChordLength) {
            this.emit('measurementUpdate', {
                type: 'chordLength',
                value: `Chord: ${this.formatLength(chordLength)}`,
                position: this.currentArcInfo.midPoint
            });
        }
    }

    // ==================== Helper Methods ====================

    private formatLength(length: number): string {
        if (length < 0.01) return '0.00m';
        
        if (length < 1) {
            return `${(length * 100).toFixed(0)}cm`;
        } else if (length < 1000) {
            return `${length.toFixed(2)}m`;
        } else {
            return `${(length / 1000).toFixed(3)}km`;
        }
    }

    // ==================== Public Interface ====================

    public setArcDrawMode(mode: ArcDrawMode): void {
        if (this.state === 'drawing') {
            this.logger.warn('Cannot change drawing mode while drawing');
            return;
        }
        
        this.arcDrawMode = mode;
        this.resetTool();
        
        this.emit('drawModeChanged', { mode, toolId: this.toolId });
        this.logger.info(`Changed arc drawing mode to: ${mode}`);
    }

    public setViewer(viewer: any): void {
        this.viewer = viewer;
    }

    protected clearPreview(): void {
        super.clearPreview();
        
        this.helperLines.forEach(line => {
            this.emit('previewObjectRemoved', line);
        });
        this.helperLines = [];
        
        if (this.previewArc) {
            this.emit('previewObjectRemoved', this.previewArc);
            this.previewArc = null;
        }
    }
}

==== FILE: src\drawing_tools\DrawCircleTool.ts ====

/**
 * DrawCircleTool - Advanced Circle and Arc Drawing Tool
 * Comprehensive tool for drawing circles and arcs with advanced features
 */

import { Vector3, BufferGeometry, LineBasicMaterial, Line as ThreeLine, RingGeometry, MeshBasicMaterial, Mesh, EllipseCurve, BufferAttribute } from 'three';
import { AbstractDrawTool, DrawToolOptions, DrawResult, DrawMode, InputType } from './AbstractDrawTool';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { CommandManager, Command } from '../core/CommandManager';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Circle } from '../models/Circle';
import { GeometricObject } from '../models/GeometricObject';

// Circle drawing modes
export enum CircleDrawMode {
    CENTER_RADIUS = 'center-radius',        // Center + point on circumference
    TWO_POINTS = 'two-points',              // Two points on diameter
    THREE_POINTS = 'three-points',          // Three points on circumference
    TANGENT_TANGENT_RADIUS = 'tangent-tangent-radius', // Two tangents and radius
    CONCENTRIC = 'concentric',              // Concentric circles
    ARC_THREE_POINTS = 'arc-three-points',  // Arc with three points
    ARC_CENTER = 'arc-center'               // Arc from center
}

// Circle-specific settings
export interface CircleToolOptions extends DrawToolOptions {
    circleDrawMode?: CircleDrawMode;
    showRadius?: boolean;
    showDiameter?: boolean;
    showCenter?: boolean;
    showQuadrants?: boolean;
    showCircumference?: boolean;
    showArea?: boolean;
    createAsArc?: boolean;
    defaultRadius?: number;
    radiusIncrement?: number;
    angleIncrement?: number;
    concentricStep?: number;
}

// Circle information
export interface CircleInfo {
    center: Point3D;
    radius: number;
    diameter: number;
    circumference: number;
    area: number;
    normal: Point3D;
    startAngle?: number;    // For arcs
    endAngle?: number;      // For arcs
    arcLength?: number;     // For arcs
    isArc: boolean;
    quadrantPoints?: Point3D[]; // Quadrant points
}

// Preview information
export interface CirclePreviewInfo {
    geometry?: BufferGeometry;
    centerPoint?: Vector3;
    radiusLine?: ThreeLine;
    quadrantLines?: ThreeLine[];
    dimensionLabels?: any[];
}

// Add circle command
class AddCircleCommand implements Command {
    private circle: Circle;
    private viewer: any;

    constructor(circle: Circle, viewer: any) {
        this.circle = circle;
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer?.addGeometricObject(this.circle);
    }

    undo(): void {
        this.viewer?.removeGeometricObject(this.circle.id);
    }

    getDescription(): string {
        return `Add circle: ${this.circle.id}`;
    }
}

/**
 * Advanced Circle Drawing Tool
 */
export class DrawCircleTool extends AbstractDrawTool {
    private circleDrawMode: CircleDrawMode = CircleDrawMode.CENTER_RADIUS;
    private previewCircle: Mesh | null = null;
    private currentCircleInfo: CircleInfo | null = null;
    private viewer: any = null;

    // Special settings
    private circleOptions: CircleToolOptions;
    
    // Reference circles for snapping
    private referenceCircles: Circle[] = [];
    
    // Temporary calculation cache
    private calculationCache: Map<string, any> = new Map();

    constructor(
        geometryEngine: GeometryEngine,
        commandManager: CommandManager,
        snapSystem: SnapSystem,
        measurementSystem: MeasurementSystem,
        options: CircleToolOptions = {},
        mode: CircleDrawMode = CircleDrawMode.CENTER_RADIUS
    ) {
        super(
            'draw-circle',
            'Draw Circle',
            geometryEngine,
            commandManager,
            snapSystem,
            measurementSystem,
            {
                snapEnabled: true,
                measurementEnabled: true,
                previewEnabled: true,
                autoComplete: true,
                undoEnabled: true,
                constraintsEnabled: true,
                precision: 0.001,
                tolerance: 0.1,
                maxPoints: 10,
                minPoints: 1,
                drawMode: DrawMode.SINGLE,
                ...options
            }
        );

        this.circleDrawMode = mode;
        this.circleOptions = {
            ...this.options,
            showRadius: true,
            showDiameter: false,
            showCenter: true,
            showQuadrants: false,
            showCircumference: true,
            showArea: false,
            createAsArc: false,
            defaultRadius: 1,
            radiusIncrement: 0.5,
            angleIncrement: 15,
            concentricStep: 0.5,
            ...options
        } as CircleToolOptions;

        this.setupCircleSpecificOptions();
    }

    // ==================== Required Abstract Functions ====================

    protected getRequiredPointCount(): number {
        switch (this.circleDrawMode) {
            case CircleDrawMode.CENTER_RADIUS:
                return 2;
            case CircleDrawMode.TWO_POINTS:
                return 2;
            case CircleDrawMode.THREE_POINTS:
            case CircleDrawMode.ARC_THREE_POINTS:
                return 3;
            case CircleDrawMode.TANGENT_TANGENT_RADIUS:
                return 3; // Two points for tangents + point for radius
            case CircleDrawMode.CONCENTRIC:
                return 2; // Reference circle center + radius point
            case CircleDrawMode.ARC_CENTER:
                return 3; // Center + start point + end point
            default:
                return 2;
        }
    }

    protected validatePoints(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        switch (this.circleDrawMode) {
            case CircleDrawMode.CENTER_RADIUS:
                return this.validateCenterRadius();
            case CircleDrawMode.TWO_POINTS:
                return this.validateTwoPoints();
            case CircleDrawMode.THREE_POINTS:
            case CircleDrawMode.ARC_THREE_POINTS:
                return this.validateThreePoints();
            case CircleDrawMode.TANGENT_TANGENT_RADIUS:
                return this.validateTangentTangentRadius();
            case CircleDrawMode.CONCENTRIC:
                return this.validateConcentric();
            case CircleDrawMode.ARC_CENTER:
                return this.validateArcCenter();
            default:
                return false;
        }
    }

    protected createGeometry(): GeometricObject | GeometricObject[] | null {
        if (!this.validatePoints()) {
            return null;
        }

        try {
            switch (this.circleDrawMode) {
                case CircleDrawMode.CENTER_RADIUS:
                    return this.createCenterRadiusCircle();
                
                case CircleDrawMode.TWO_POINTS:
                    return this.createTwoPointsCircle();
                
                case CircleDrawMode.THREE_POINTS:
                    return this.createThreePointsCircle();
                
                case CircleDrawMode.TANGENT_TANGENT_RADIUS:
                    return this.createTangentTangentRadiusCircle();
                
                case CircleDrawMode.CONCENTRIC:
                    return this.createConcentricCircle();
                
                case CircleDrawMode.ARC_THREE_POINTS:
                    return this.createThreePointsArc();
                
                case CircleDrawMode.ARC_CENTER:
                    return this.createCenterArc();
                
                default:
                    return this.createCenterRadiusCircle();
            }
        } catch (error) {
            this.logger.error('Failed to create circle:', error);
            return null;
        }
    }

    protected updatePreview(): void {
        if (!this.shouldShowPreview()) {
            this.clearPreview();
            return;
        }

        try {
            this.clearPreview();
            
            if (this.inputPoints.length > 0 && this.currentPoint) {
                this.calculateCurrentCircleInfo();
                
                if (this.currentCircleInfo) {
                    this.createCirclePreview();
                    this.showCircleHelpers();
                    this.updateMeasurementDisplay();
                }
            }
        } catch (error) {
            this.logger.error('Failed to update circle preview:', error);
        }
    }

    protected getDisplayName(): string {
        const modeNames = {
            [CircleDrawMode.CENTER_RADIUS]: 'Circle (Center + Radius)',
            [CircleDrawMode.TWO_POINTS]: 'Circle (Two Points)',
            [CircleDrawMode.THREE_POINTS]: 'Circle (Three Points)',
            [CircleDrawMode.TANGENT_TANGENT_RADIUS]: 'Circle (Tangents + Radius)',
            [CircleDrawMode.CONCENTRIC]: 'Concentric Circle',
            [CircleDrawMode.ARC_THREE_POINTS]: 'Arc (Three Points)',
            [CircleDrawMode.ARC_CENTER]: 'Arc (From Center)'
        };
        
        return modeNames[this.circleDrawMode] || 'Draw Circle';
    }

    protected canComplete(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        // Additional validation
        return this.validatePoints() && this.currentCircleInfo !== null;
    }

    protected createAddCommand(object: GeometricObject): Command {
        return new AddCircleCommand(object as Circle, this.viewer);
    }

    // ==================== Point Validation ====================

    private validateCenterRadius(): boolean {
        if (this.inputPoints.length < 2) return false;
        
        const center = this.inputPoints[0].position;
        const radiusPoint = this.inputPoints[1].position;
        const radius = center.distanceTo(radiusPoint);
        
        if (radius < this.options.tolerance!) {
            this.logger.warn('Circle radius too small');
            return false;
        }

        return true;
    }

    private validateTwoPoints(): boolean {
        if (this.inputPoints.length < 2) return false;
        
        const p1 = this.inputPoints[0].position;
        const p2 = this.inputPoints[1].position;
        const diameter = p1.distanceTo(p2);
        
        if (diameter < 2 * this.options.tolerance!) {
            this.logger.warn('Circle diameter too small');
            return false;
        }

        return true;
    }

    private validateThreePoints(): boolean {
        if (this.inputPoints.length < 3) return false;
        
        const [p1, p2, p3] = this.inputPoints.map(ip => ip.position);
        
        // Check if points are collinear
        const area = this.calculateTriangleArea(p1, p2, p3);
        if (Math.abs(area) < this.options.tolerance!) {
            this.logger.warn('Three points are collinear');
            return false;
        }

        return true;
    }

    private validateTangentTangentRadius(): boolean {
        // TODO: Implement tangent validation
        return this.inputPoints.length >= 3;
    }

    private validateConcentric(): boolean {
        if (this.inputPoints.length < 2) return false;
        
        // Check for reference circle
        if (this.referenceCircles.length === 0) {
            this.logger.warn('No reference circle for concentric circles');
            return false;
        }

        return true;
    }

    private validateArcCenter(): boolean {
        if (this.inputPoints.length < 3) return false;
        
        const center = this.inputPoints[0].position;
        const start = this.inputPoints[1].position;
        const end = this.inputPoints[2].position;
        
        const radius1 = center.distanceTo(start);
        const radius2 = center.distanceTo(end);
        
        // Check if points are equidistant from center
        if (Math.abs(radius1 - radius2) > this.options.tolerance!) {
            this.logger.warn('Points are not equidistant from center');
            return false;
        }

        return true;
    }

    // ==================== Circle Creation ====================

    private createCenterRadiusCircle(): Circle {
        const center = this.inputPoints[0].position;
        const radiusPoint = this.inputPoints[1].position;
        const radius = center.distanceTo(radiusPoint);
        
        const circle = new Circle(
            { x: center.x, y: center.y, z: center.z },
            radius
        );
        
        this.applyCircleProperties(circle);
        
        this.logger.info(`Created center-radius circle: ${circle.id}`);
        return circle;
    }

    private createTwoPointsCircle(): Circle {
        const p1 = this.inputPoints[0].position;
        const p2 = this.inputPoints[1].position;
        
        const center = new Vector3().addVectors(p1, p2).multiplyScalar(0.5);
        const radius = p1.distanceTo(p2) / 2;
        
        const circle = new Circle(
            { x: center.x, y: center.y, z: center.z },
            radius
        );
        
        this.applyCircleProperties(circle);
        
        this.logger.info(`Created two-point circle: ${circle.id}`);
        return circle;
    }

    private createThreePointsCircle(): Circle {
        const [p1, p2, p3] = this.inputPoints.map(ip => ip.position);
        
        const circleInfo = this.calculateCircleFromThreePoints(p1, p2, p3);
        if (!circleInfo) {
            throw new Error('Failed to calculate circle from three points');
        }
        
        const circle = new Circle(
            { x: circleInfo.center.x, y: circleInfo.center.y, z: circleInfo.center.z },
            circleInfo.radius
        );
        
        this.applyCircleProperties(circle);
        
        this.logger.info(`Created three-point circle: ${circle.id}`);
        return circle;
    }

    private createTangentTangentRadiusCircle(): Circle {
        // TODO: Implement tangent circle creation
        return this.createCenterRadiusCircle();
    }

    private createConcentricCircle(): Circle {
        const referenceCircle = this.referenceCircles[0];
        const newRadiusPoint = this.inputPoints[1].position;
        const newRadius = new Vector3(
            referenceCircle.center.x,
            referenceCircle.center.y,
            referenceCircle.center.z
        ).distanceTo(newRadiusPoint);
        
        const circle = new Circle(referenceCircle.center, newRadius);
        
        circle.setMetadata('isConcentric', true);
        circle.setMetadata('referenceCircle', referenceCircle.id);
        
        this.applyCircleProperties(circle);
        
        this.logger.info(`Created concentric circle: ${circle.id}`);
        return circle;
    }

    private createThreePointsArc(): Circle {
        // Create arc from three points
        const arc = this.createThreePointsCircle();
        
        // Calculate start and end angles
        const [p1, p2, p3] = this.inputPoints.map(ip => ip.position);
        const center = new Vector3(arc.center.x, arc.center.y, arc.center.z);
        
        const startAngle = Math.atan2(p1.y - center.y, p1.x - center.x);
        const endAngle = Math.atan2(p3.y - center.y, p3.x - center.x);
        
        arc.setMetadata('isArc', true);
        arc.setMetadata('startAngle', startAngle);
        arc.setMetadata('endAngle', endAngle);
        arc.setMetadata('middlePoint', { x: p2.x, y: p2.y, z: p2.z });
        
        this.logger.info(`Created three-point arc: ${arc.id}`);
        return arc;
    }

    private createCenterArc(): Circle {
        const center = this.inputPoints[0].position;
        const startPoint = this.inputPoints[1].position;
        const endPoint = this.inputPoints[2].position;
        
        const radius = center.distanceTo(startPoint);
        
        const startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
        const endAngle = Math.atan2(endPoint.y - center.y, endPoint.x - center.x);
        
        const arc = new Circle(
            { x: center.x, y: center.y, z: center.z },
            radius
        );
        
        arc.setMetadata('isArc', true);
        arc.setMetadata('startAngle', startAngle);
        arc.setMetadata('endAngle', endAngle);
        
        this.applyCircleProperties(arc);
        
        this.logger.info(`Created center arc: ${arc.id}`);
        return arc;
    }

    // ==================== Circle Information Calculation ====================

    private calculateCurrentCircleInfo(): void {
        this.currentCircleInfo = null;
        
        try {
            let center: Vector3;
            let radius: number;
            let isArc = false;
            let startAngle: number | undefined;
            let endAngle: number | undefined;

            switch (this.circleDrawMode) {
                case CircleDrawMode.CENTER_RADIUS:
                    if (this.inputPoints.length >= 1 && this.currentPoint) {
                        center = this.inputPoints[0].position;
                        radius = center.distanceTo(this.currentPoint);
                    } else {
                        return;
                    }
                    break;

                case CircleDrawMode.TWO_POINTS:
                    if (this.inputPoints.length >= 1 && this.currentPoint) {
                        const p1 = this.inputPoints[0].position;
                        center = new Vector3().addVectors(p1, this.currentPoint).multiplyScalar(0.5);
                        radius = p1.distanceTo(this.currentPoint) / 2;
                    } else {
                        return;
                    }
                    break;

                case CircleDrawMode.THREE_POINTS:
                    if (this.inputPoints.length >= 2 && this.currentPoint) {
                        const p1 = this.inputPoints[0].position;
                        const p2 = this.inputPoints[1].position;
                        const circleInfo = this.calculateCircleFromThreePoints(p1, p2, this.currentPoint);
                        if (!circleInfo) return;
                        center = circleInfo.center;
                        radius = circleInfo.radius;
                    } else {
                        return;
                    }
                    break;

                case CircleDrawMode.ARC_CENTER:
                    if (this.inputPoints.length >= 2 && this.currentPoint) {
                        center = this.inputPoints[0].position;
                        const startPoint = this.inputPoints[1].position;
                        radius = center.distanceTo(startPoint);
                        isArc = true;
                        startAngle = Math.atan2(startPoint.y - center.y, startPoint.x - center.x);
                        endAngle = Math.atan2(this.currentPoint.y - center.y, this.currentPoint.x - center.x);
                    } else {
                        return;
                    }
                    break;

                default:
                    return;
            }

            // Create circle info
            this.currentCircleInfo = {
                center: { x: center.x, y: center.y, z: center.z },
                radius,
                diameter: radius * 2,
                circumference: 2 * Math.PI * radius,
                area: Math.PI * radius * radius,
                normal: { x: 0, y: 0, z: 1 },
                isArc,
                startAngle,
                endAngle,
                arcLength: isArc && startAngle !== undefined && endAngle !== undefined 
                    ? this.calculateArcLength(radius, startAngle, endAngle) 
                    : undefined,
                quadrantPoints: this.calculateQuadrantPoints(center, radius)
            };

            this.emit('circleInfoUpdated', this.currentCircleInfo);

        } catch (error) {
            this.logger.error('Failed to calculate circle info:', error);
        }
    }

    private calculateCircleFromThreePoints(p1: Vector3, p2: Vector3, p3: Vector3): { center: Vector3; radius: number } | null {
        // Calculate center and radius of circle passing through three points
        const ax = p1.x, ay = p1.y;
        const bx = p2.x, by = p2.y;
        const cx = p3.x, cy = p3.y;

        const d = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));
        
        if (Math.abs(d) < this.options.tolerance!) {
            return null; // Points are collinear
        }

        const ux = ((ax * ax + ay * ay) * (by - cy) + 
                    (bx * bx + by * by) * (cy - ay) + 
                    (cx * cx + cy * cy) * (ay - by)) / d;
        
        const uy = ((ax * ax + ay * ay) * (cx - bx) + 
                    (bx * bx + by * by) * (ax - cx) + 
                    (cx * cx + cy * cy) * (bx - ax)) / d;

        const center = new Vector3(ux, uy, p1.z);
        const radius = center.distanceTo(p1);

        return { center, radius };
    }

    private calculateTriangleArea(p1: Vector3, p2: Vector3, p3: Vector3): number {
        return 0.5 * Math.abs(
            (p2.x - p1.x) * (p3.y - p1.y) - 
            (p3.x - p1.x) * (p2.y - p1.y)
        );
    }

    private calculateArcLength(radius: number, startAngle: number, endAngle: number): number {
        let angleDiff = endAngle - startAngle;
        if (angleDiff < 0) angleDiff += 2 * Math.PI;
        return radius * angleDiff;
    }

    private calculateQuadrantPoints(center: Vector3, radius: number): Point3D[] {
        return [
            { x: center.x + radius, y: center.y, z: center.z },      // 0Â°
            { x: center.x, y: center.y + radius, z: center.z },      // 90Â°
            { x: center.x - radius, y: center.y, z: center.z },      // 180Â°
            { x: center.x, y: center.y - radius, z: center.z }       // 270Â°
        ];
    }

    // ==================== Preview and Display ====================

    private createCirclePreview(): void {
        if (!this.currentCircleInfo) return;

        const { center, radius, isArc, startAngle, endAngle } = this.currentCircleInfo;

        if (isArc && startAngle !== undefined && endAngle !== undefined) {
            this.createArcPreview(center, radius, startAngle, endAngle);
        } else {
            this.createFullCirclePreview(center, radius);
        }
    }

    private createFullCirclePreview(center: Point3D, radius: number): void {
        // Create circle geometry
        const geometry = new RingGeometry(radius * 0.98, radius * 1.02, 64);
        
        // Create preview material
        const material = new MeshBasicMaterial({
            color: this.circleOptions.previewColor || '#2196F3',
            opacity: this.circleOptions.previewOpacity || 0.3,
            transparent: true,
            side: 2 // DoubleSide
        });
        
        this.previewCircle = new Mesh(geometry, material);
        this.previewCircle.position.set(center.x, center.y, center.z);
        
        this.previewObjects.push(this.previewCircle);
        this.emit('previewObjectCreated', this.previewCircle);
        
        // Create circle outline
        this.createCircleOutline(center, radius);
    }

    private createArcPreview(center: Point3D, radius: number, startAngle: number, endAngle: number): void {
        // Create arc geometry
        const curve = new EllipseCurve(
            center.x, center.y,
            radius, radius,
            startAngle, endAngle,
            false,
            0
        );
        
        const points = curve.getPoints(64);
        const geometry = new BufferGeometry().setFromPoints(points);
        
        const material = new LineBasicMaterial({
            color: this.circleOptions.previewColor || '#2196F3',
            linewidth: 2
        });
        
        const arcLine = new ThreeLine(geometry, material);
        arcLine.position.z = center.z;
        
        this.previewObjects.push(arcLine);
        this.emit('previewObjectCreated', arcLine);
        
        // Add radius lines for arc
        this.createRadiusLines(center, radius, startAngle, endAngle);
    }

    private createCircleOutline(center: Point3D, radius: number): void {
        const segments = 64;
        const points: Vector3[] = [];
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = center.x + Math.cos(angle) * radius;
            const y = center.y + Math.sin(angle) * radius;
            points.push(new Vector3(x, y, center.z));
        }
        
        const geometry = new BufferGeometry().setFromPoints(points);
        const material = new LineBasicMaterial({
            color: this.circleOptions.previewColor || '#2196F3',
            opacity: 0.8,
            transparent: true
        });
        
        const outline = new ThreeLine(geometry, material);
        this.previewObjects.push(outline);
        this.emit('previewObjectCreated', outline);
    }

    private createRadiusLines(center: Point3D, radius: number, startAngle: number, endAngle: number): void {
        const centerVec = new Vector3(center.x, center.y, center.z);
        
        // Start radius line
        const startPoint = new Vector3(
            center.x + Math.cos(startAngle) * radius,
            center.y + Math.sin(startAngle) * radius,
            center.z
        );
        
        // End radius line
        const endPoint = new Vector3(
            center.x + Math.cos(endAngle) * radius,
            center.y + Math.sin(endAngle) * radius,
            center.z
        );
        
        // Create lines
        [startPoint, endPoint].forEach(point => {
            const geometry = new BufferGeometry().setFromPoints([centerVec, point]);
            const material = new LineBasicMaterial({
                color: '#FF9800',
                opacity: 0.6,
                transparent: true
            });
            
            const radiusLine = new ThreeLine(geometry, material);
            this.previewObjects.push(radiusLine);
            this.emit('previewObjectCreated', radiusLine);
        });
    }

    private showCircleHelpers(): void {
        if (!this.currentCircleInfo) return;
        
        const { center, radius } = this.currentCircleInfo;
        
        // Show center point
        if (this.circleOptions.showCenter) {
            this.createCenterPoint(center);
        }
        
        // Show quadrant lines
        if (this.circleOptions.showQuadrants) {
            this.createQuadrantLines(center, radius);
        }
        
        // Show radius line
        if (this.circleOptions.showRadius && this.inputPoints.length > 0) {
            this.createRadiusLine(center, this.currentPoint!);
        }
    }

    private createCenterPoint(center: Point3D): void {
        const geometry = new BufferGeometry();
        const vertices = new Float32Array([center.x, center.y, center.z]);
        geometry.setAttribute('position', new BufferAttribute(vertices, 3));
        
        const material = new LineBasicMaterial({
            color: '#FF0000',
            opacity: 0.8,
            transparent: true
        });
        
        // Create small cross for center
        const size = this.currentCircleInfo!.radius * 0.05;
        const crossPoints = [
            new Vector3(center.x - size, center.y, center.z),
            new Vector3(center.x + size, center.y, center.z),
            new Vector3(center.x, center.y - size, center.z),
            new Vector3(center.x, center.y + size, center.z)
        ];
        
        const crossGeometry = new BufferGeometry().setFromPoints(crossPoints);
        const centerCross = new ThreeLine(crossGeometry, material);
        
        this.previewObjects.push(centerCross);
        this.emit('previewObjectCreated', centerCross);
    }

    private createQuadrantLines(center: Point3D, radius: number): void {
        const quadrantPoints = this.calculateQuadrantPoints(new Vector3(center.x, center.y, center.z), radius);
        const centerVec = new Vector3(center.x, center.y, center.z);
        
        quadrantPoints.forEach(point => {
            const geometry = new BufferGeometry().setFromPoints([
                centerVec,
                new Vector3(point.x, point.y, point.z)
            ]);
            
            const material = new LineBasicMaterial({
                color: '#888888',
                opacity: 0.4,
                transparent: true
            });
            
            const quadrantLine = new ThreeLine(geometry, material);
            this.previewObjects.push(quadrantLine);
            this.emit('previewObjectCreated', quadrantLine);
        });
    }

    private createRadiusLine(center: Point3D, endPoint: Vector3): void {
        const geometry = new BufferGeometry().setFromPoints([
            new Vector3(center.x, center.y, center.z),
            endPoint
        ]);
        
        const material = new LineBasicMaterial({
            color: '#4CAF50',
            opacity: 0.7,
            transparent: true,
            linewidth: 2
        });
        
        const radiusLine = new ThreeLine(geometry, material);
        this.previewObjects.push(radiusLine);
        this.emit('previewObjectCreated', radiusLine);
    }

    private updateMeasurementDisplay(): void {
        if (!this.currentCircleInfo) return;
        
        const { center, radius, diameter, circumference, area, arcLength, isArc } = this.currentCircleInfo;
        
        // Show radius
        if (this.circleOptions.showRadius) {
            this.emit('measurementUpdate', {
                type: 'radius',
                value: this.formatLength(radius),
                position: center
            });
        }
        
        // Show diameter
        if (this.circleOptions.showDiameter) {
            this.emit('measurementUpdate', {
                type: 'diameter',
                value: this.formatLength(diameter),
                position: center
            });
        }
        
        // Show circumference or arc length
        if (this.circleOptions.showCircumference) {
            const length = isArc && arcLength ? arcLength : circumference;
            const label = isArc ? 'Arc Length' : 'Circumference';
            
            this.emit('measurementUpdate', {
                type: 'circumference',
                value: `${label}: ${this.formatLength(length)}`,
                position: { x: center.x + radius, y: center.y, z: center.z }
            });
        }
        
        // Show area
        if (this.circleOptions.showArea && !isArc) {
            this.emit('measurementUpdate', {
                type: 'area',
                value: this.formatArea(area),
                position: center
            });
        }
    }

    // ==================== Advanced Snapping ====================

    public onMouseMove(point: Vector3, existingObjects: any[] = []): void {
        let enhancedPoint = point.clone();
        
        // Radius snapping
        if (this.inputPoints.length > 0 && this.circleOptions.radiusIncrement) {
            enhancedPoint = this.applyRadiusSnap(enhancedPoint);
        }
        
        // Angle snapping for arcs
        if (this.isArcMode() && this.inputPoints.length > 1 && this.circleOptions.angleIncrement) {
            enhancedPoint = this.applyAngleSnap(enhancedPoint);
        }
        
        // Circle snapping
        enhancedPoint = this.applyCircleSnap(enhancedPoint, existingObjects);
        
        super.onMouseMove(enhancedPoint, existingObjects);
    }

    private applyRadiusSnap(point: Vector3): Vector3 {
        if (this.inputPoints.length === 0) return point;
        
        const center = this.inputPoints[0].position;
        const direction = point.clone().sub(center);
        const radius = direction.length();
        
        if (radius < 0.001) return point;
        
        // Radius snapping
        const increment = this.circleOptions.radiusIncrement || 0.5;
        const snappedRadius = Math.round(radius / increment) * increment;
        
        return center.clone().add(direction.normalize().multiplyScalar(snappedRadius));
    }

    private applyAngleSnap(point: Vector3): Vector3 {
        if (this.inputPoints.length < 2) return point;
        
        const center = this.inputPoints[0].position;
        const direction = point.clone().sub(center);
        const angle = Math.atan2(direction.y, direction.x);
        const radius = direction.length();
        
        // Angle snapping
        const increment = (this.circleOptions.angleIncrement || 15) * (Math.PI / 180);
        const snappedAngle = Math.round(angle / increment) * increment;
        
        return center.clone().add(new Vector3(
            Math.cos(snappedAngle) * radius,
            Math.sin(snappedAngle) * radius,
            0
        ));
    }

    private applyCircleSnap(point: Vector3, existingObjects: any[]): Vector3 {
        // Snap to centers and circumferences of existing circles
        // TODO: Implement advanced circle snapping
        return point;
    }

    // ==================== Helper Functions ====================

    private setupCircleSpecificOptions(): void {
        if (this.isArcMode()) {
            this.circleOptions.createAsArc = true;
        }
    }

    private isArcMode(): boolean {
        return this.circleDrawMode === CircleDrawMode.ARC_THREE_POINTS ||
               this.circleDrawMode === CircleDrawMode.ARC_CENTER;
    }

    private applyCircleProperties(circle: Circle): void {
        // Apply special properties
        if (this.circleOptions.createAsArc || this.isArcMode()) {
            circle.setMetadata('isArc', true);
        }
        
        circle.setMetadata('drawMode', this.circleDrawMode);
        circle.setMetadata('toolVersion', this.toolVersion);
        
        if (this.currentCircleInfo) {
            circle.setMetadata('circleInfo', this.currentCircleInfo);
        }
    }

    private formatLength(length: number): string {
        if (length < 0.01) return '0.00m';
        
        if (length < 1) {
            return `${(length * 100).toFixed(0)}cm`;
        } else if (length < 1000) {
            return `${length.toFixed(2)}m`;
        } else {
            return `${(length / 1000).toFixed(3)}km`;
        }
    }

    private formatArea(area: number): string {
        if (area < 1) {
            return `${(area * 10000).toFixed(0)}cmÂ²`;
        } else if (area < 10000) {
            return `${area.toFixed(2)}mÂ²`;
        } else {
            return `${(area / 10000).toFixed(3)}hectares`;
        }
    }

    // ==================== Public Interface ====================

    /**
     * Change circle drawing mode
     */
    public setCircleDrawMode(mode: CircleDrawMode): void {
        if (this.state === 'drawing') {
            this.logger.warn('Cannot change drawing mode while drawing');
            return;
        }
        
        this.circleDrawMode = mode;
        this.setupCircleSpecificOptions();
        this.resetTool();
        
        this.emit('drawModeChanged', { mode, toolId: this.toolId });
        this.logger.info(`Changed circle drawing mode to: ${mode}`);
    }

    /**
     * Get current drawing mode
     */
    public getCircleDrawMode(): CircleDrawMode {
        return this.circleDrawMode;
    }

    /**
     * Get current circle info
     */
    public getCurrentCircleInfo(): CircleInfo | null {
        return this.currentCircleInfo ? { ...this.currentCircleInfo } : null;
    }

    /**
     * Set reference circles for snapping
     */
    public setReferenceCircles(circles: Circle[]): void {
        this.referenceCircles = [...circles];
    }

    /**
     * Set viewer reference
     */
    public setViewer(viewer: any): void {
        this.viewer = viewer;
    }

    /**
     * Get detailed statistics
     */
    public getDetailedStats(): any {
        const baseStats = this.getStats();
        
        return {
            ...baseStats,
            circleDrawMode: this.circleDrawMode,
            totalCirclesDrawn: baseStats.completionCount,
            averageRadius: this.calculateAverageRadius(),
            arcsDrawn: this.countArcs(),
            concentricCircles: this.countConcentricCircles()
        };
    }

    private calculateAverageRadius(): number {
        // TODO: Calculate average radius
        return 0;
    }

    private countArcs(): number {
        // TODO: Count drawn arcs
        return 0;
    }

    private countConcentricCircles(): number {
        // TODO: Count concentric circles
        return 0;
    }

    /**
     * Enhanced cleanup
     */
    public dispose(): void {
        this.clearPreview();
        this.calculationCache.clear();
        
        // Clear references
        this.previewCircle = null;
        this.currentCircleInfo = null;
        this.viewer = null;
        this.referenceCircles = [];
        
        super.dispose();
    }

    /**
     * Enhanced preview clearing
     */
    protected clearPreview(): void {
        super.clearPreview();
        
        if (this.previewCircle) {
            this.emit('previewObjectRemoved', this.previewCircle);
            this.previewCircle = null;
        }
        
    }
}

==== FILE: src\drawing_tools\DrawLineTool.ts ====

/**
 * DrawLineTool - Ø£Ø¯Ø§Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
 * Ø£Ø¯Ø§Ø© Ù…ØªÙƒØ§Ù…Ù„Ø© Ù„Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø© Ù…Ø¹ Ù…ÙŠØ²Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
 */

import { Vector3, BufferGeometry, LineBasicMaterial, Line as ThreeLine, BufferAttribute } from 'three';
import { AbstractDrawTool, DrawToolOptions, DrawResult, DrawMode, InputType } from './AbstractDrawTool';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { CommandManager, Command } from '../core/CommandManager';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Line } from '../models/Line';
import { GeometricObject } from '../models/GeometricObject';

// Ø£Ù†Ù…Ø§Ø· Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ·
export enum LineDrawMode {
    SINGLE = 'single',           // Ø®Ø· ÙˆØ§Ø­Ø¯ Ø¨ÙŠÙ† Ù†Ù‚Ø·ØªÙŠÙ†
    CONTINUOUS = 'continuous',   // Ø®Ø·ÙˆØ· Ù…ØªØªØ§Ø¨Ø¹Ø©
    POLYLINE = 'polyline',       // Ø®Ø· Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹
    CONSTRUCTION = 'construction', // Ø®Ø·ÙˆØ· Ø¥Ù†Ø´Ø§Ø¦ÙŠØ©
    INFINITE = 'infinite',       // Ø®Ø·ÙˆØ· Ù„Ø§ Ù†Ù‡Ø§Ø¦ÙŠØ©
    RAY = 'ray'                 // Ø£Ø´Ø¹Ø© (Ù†ØµÙ Ø®Ø·)
}

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø®Ø·ÙˆØ·
export interface LineToolOptions extends DrawToolOptions {
    lineDrawMode?: LineDrawMode;
    showLength?: boolean;
    showAngle?: boolean;
    showMidpoint?: boolean;
    constructionLines?: boolean;
    infiniteExtension?: boolean;
    angleIncrement?: number;     // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù„Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
    lengthIncrement?: number;    // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø·ÙˆÙ„ Ù„Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
}

// Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø®Ø·
export interface LineInfo {
    length: number;
    angle: number;              // Ø¨Ø§Ù„Ø±Ø§Ø¯ÙŠØ§Ù†
    angleDegrees: number;       // Ø¨Ø§Ù„Ø¯Ø±Ø¬Ø§Øª
    startPoint: Point3D;
    endPoint: Point3D;
    midPoint: Point3D;
    direction: Vector3;
    slope?: number;             // Ø§Ù„Ù…ÙŠÙ„ (Ù„Ù„Ø®Ø·ÙˆØ· Ø«Ù†Ø§Ø¦ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯)
    isHorizontal: boolean;
    isVertical: boolean;
    isDiagonal: boolean;
}

// Ø£Ù…Ø± Ø¥Ø¶Ø§ÙØ© Ø®Ø·
class AddLineCommand implements Command {
    private line: Line;
    private viewer: any;

    constructor(line: Line, viewer: any) {
        this.line = line;
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer?.addGeometricObject(this.line);
    }

    undo(): void {
        this.viewer?.removeGeometricObject(this.line.id);
    }

    getDescription(): string {
        return `Ø¥Ø¶Ø§ÙØ© Ø®Ø·: ${this.line.id}`;
    }
}

/**
 * Ø£Ø¯Ø§Ø© Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
 */
export class DrawLineTool extends AbstractDrawTool {
    private lineDrawMode: LineDrawMode = LineDrawMode.SINGLE;
    private previewLine: ThreeLine | null = null;
    private constructionLines: ThreeLine[] = [];
    private currentLineInfo: LineInfo | null = null;
    private viewer: any = null;

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø®Ø§ØµØ©
    private lineOptions: LineToolOptions;
    
    // Ø®Ø·ÙˆØ· Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
    private helperLines: {
        horizontal?: ThreeLine;
        vertical?: ThreeLine;
        angleReference?: ThreeLine;
        lengthReference?: ThreeLine;
    } = {};

    constructor(
        geometryEngine: GeometryEngine,
        commandManager: CommandManager,
        snapSystem: SnapSystem,
        measurementSystem: MeasurementSystem,
        options: LineToolOptions = {},
        mode: LineDrawMode = LineDrawMode.SINGLE
    ) {
        super(
            'draw-line',
            'Ø±Ø³Ù… Ø®Ø·',
            geometryEngine,
            commandManager,
            snapSystem,
            measurementSystem,
            {
                snapEnabled: true,
                measurementEnabled: true,
                previewEnabled: true,
                autoComplete: true,
                undoEnabled: true,
                constraintsEnabled: true,
                precision: 0.001,
                tolerance: 0.1,
                maxPoints: 1000,
                minPoints: 2,
                drawMode: DrawMode.CONTINUOUS,
                ...options
            }
        );

        this.lineDrawMode = mode;
        this.lineOptions = {
            ...this.options,
            showLength: true,
            showAngle: true,
            showMidpoint: false,
            constructionLines: false,
            infiniteExtension: false,
            angleIncrement: 15,      // Ø¯Ø±Ø¬Ø§Øª
            lengthIncrement: 1,      // Ù…ØªØ±
            ...options
        } as LineToolOptions;

        this.setupLineSpecificOptions();
    }

    // ==================== Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ====================

    protected getRequiredPointCount(): number {
        switch (this.lineDrawMode) {
            case LineDrawMode.SINGLE:
                return 2;
            case LineDrawMode.CONTINUOUS:
            case LineDrawMode.POLYLINE:
                return 2; // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ØŒ ÙŠÙ…ÙƒÙ† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
            case LineDrawMode.CONSTRUCTION:
                return 2;
            case LineDrawMode.INFINITE:
            case LineDrawMode.RAY:
                return 2;
            default:
                return 2;
        }
    }

    protected validatePoints(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        // ÙØ­Øµ Ø®Ø§Øµ Ù„Ù„Ø®Ø·ÙˆØ·
        for (let i = 1; i < this.inputPoints.length; i++) {
            const prevPoint = this.inputPoints[i - 1].position;
            const currentPoint = this.inputPoints[i].position;
            
            const distance = prevPoint.distanceTo(currentPoint);
            if (distance < (this.options.tolerance || 0.001)) {
                this.logger.warn('Ù†Ù‚Ø§Ø· Ù…ØªÙ‚Ø§Ø±Ø¨Ø© Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„Ø®Ø·');
                return false;
            }
        }

        return true;
    }

    protected createGeometry(): GeometricObject | GeometricObject[] | null {
        if (!this.validatePoints()) {
            return null;
        }

        try {
            switch (this.lineDrawMode) {
                case LineDrawMode.SINGLE:
                    return this.createSingleLine();
                
                case LineDrawMode.CONTINUOUS:
                    return this.createContinuousLines();
                
                case LineDrawMode.POLYLINE:
                    return this.createPolyline();
                
                case LineDrawMode.CONSTRUCTION:
                    return this.createConstructionLine();
                
                case LineDrawMode.INFINITE:
                    return this.createInfiniteLine();
                
                case LineDrawMode.RAY:
                    return this.createRay();
                
                default:
                    return this.createSingleLine();
            }
        } catch (error) {
            this.logger.error('ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ø·:', error);
            return null;
        }
    }

    protected updatePreview(): void {
        if (!this.shouldShowPreview()) {
            this.clearPreview();
            return;
        }

        try {
            this.clearPreview();
            
            if (this.inputPoints.length > 0 && this.currentPoint) {
                this.createLinePreview();
                this.updateLineInfo();
                this.showHelperLines();
                
                if (this.lineOptions.showLength || this.lineOptions.showAngle) {
                    this.updateMeasurementDisplay();
                }
            }
        } catch (error) {
            this.logger.error('ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø®Ø·:', error);
        }
    }

    protected getDisplayName(): string {
        const modeNames = {
            [LineDrawMode.SINGLE]: 'Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…',
            [LineDrawMode.CONTINUOUS]: 'Ø®Ø·ÙˆØ· Ù…ØªØªØ§Ø¨Ø¹Ø©',
            [LineDrawMode.POLYLINE]: 'Ø®Ø· Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹',
            [LineDrawMode.CONSTRUCTION]: 'Ø®Ø· Ø¥Ù†Ø´Ø§Ø¦ÙŠ',
            [LineDrawMode.INFINITE]: 'Ø®Ø· Ù„Ø§ Ù†Ù‡Ø§Ø¦ÙŠ',
            [LineDrawMode.RAY]: 'Ø´Ø¹Ø§Ø¹'
        };
        
        return modeNames[this.lineDrawMode] || 'Ø±Ø³Ù… Ø®Ø·';
    }

    protected canComplete(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        switch (this.lineDrawMode) {
            case LineDrawMode.SINGLE:
            case LineDrawMode.CONSTRUCTION:
            case LineDrawMode.INFINITE:
            case LineDrawMode.RAY:
                return this.inputPoints.length >= 2;
            
            case LineDrawMode.CONTINUOUS:
            case LineDrawMode.POLYLINE:
                return this.inputPoints.length >= 2; // ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„ ÙÙŠ Ø£ÙŠ ÙˆÙ‚Øª
            
            default:
                return this.inputPoints.length >= 2;
        }
    }

    protected createAddCommand(object: GeometricObject): Command {
        return new AddLineCommand(object as Line, this.viewer);
    }

    // ==================== Ø¥Ù†Ø´Ø§Ø¡ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø®Ø·ÙˆØ· ====================

    private createSingleLine(): Line {
        const startPoint = this.inputPoints[0].position;
        const endPoint = this.inputPoints[1].position;
        
        const line = new Line(
            { x: startPoint.x, y: startPoint.y, z: startPoint.z },
            { x: endPoint.x, y: endPoint.y, z: endPoint.z }
        );
        
        this.applyLineProperties(line);
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…: ${line.id}`);
        return line;
    }

    private createContinuousLines(): Line[] {
        const lines: Line[] = [];
        
        for (let i = 1; i < this.inputPoints.length; i++) {
            const startPoint = this.inputPoints[i - 1].position;
            const endPoint = this.inputPoints[i].position;
            
            const line = new Line(
                { x: startPoint.x, y: startPoint.y, z: startPoint.z },
                { x: endPoint.x, y: endPoint.y, z: endPoint.z }
            );
            
            this.applyLineProperties(line);
            lines.push(line);
        }
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ${lines.length} Ø®Ø· Ù…ØªØªØ§Ø¨Ø¹`);
        return lines;
    }

    private createPolyline(): Line {
        // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù…ØªØ¹Ø¯Ø¯ Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹ ÙƒØ®Ø· ÙˆØ§Ø­Ø¯ Ù…Ø±ÙƒØ¨
        // TODO: ØªÙ†ÙÙŠØ° Polyline ÙƒÙØ¦Ø© Ù…Ù†ÙØµÙ„Ø©
        return this.createSingleLine();
    }

    private createConstructionLine(): Line {
        const line = this.createSingleLine();
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø®ØµØ§Ø¦Øµ Ø®Ø· Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
        line.visualProperties = {
            ...line.visualProperties,
            color: '#888888',
            lineStyle: 'dashed',
            opacity: 0.5
        };
        
        line.setMetadata('isConstruction', true);
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ø¥Ù†Ø´Ø§Ø¦ÙŠ: ${line.id}`);
        return line;
    }

    private createInfiniteLine(): Line {
        const line = this.createSingleLine();
        
        // ØªÙ…Ø¯ÙŠØ¯ Ø§Ù„Ø®Ø· Ù„Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
        const direction = new Vector3()
            .subVectors(this.inputPoints[1].position, this.inputPoints[0].position)
            .normalize();
        
        const extensionLength = 1000; // Ø·ÙˆÙ„ ÙƒØ¨ÙŠØ± Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        
        const extendedStart = this.inputPoints[0].position.clone()
            .sub(direction.clone().multiplyScalar(extensionLength));
        const extendedEnd = this.inputPoints[1].position.clone()
            .add(direction.clone().multiplyScalar(extensionLength));
        
        line.startPoint = { x: extendedStart.x, y: extendedStart.y, z: extendedStart.z };
        line.endPoint = { x: extendedEnd.x, y: extendedEnd.y, z: extendedEnd.z };
        
        line.setMetadata('isInfinite', true);
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù„Ø§ Ù†Ù‡Ø§Ø¦ÙŠ: ${line.id}`);
        return line;
    }

    private createRay(): Line {
        const line = this.createSingleLine();
        
        // ØªÙ…Ø¯ÙŠØ¯ Ù…Ù† Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙÙŠ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©
        const direction = new Vector3()
            .subVectors(this.inputPoints[1].position, this.inputPoints[0].position)
            .normalize();
        
        const extensionLength = 1000;
        const extendedEnd = this.inputPoints[0].position.clone()
            .add(direction.clone().multiplyScalar(extensionLength));
        
        line.endPoint = { x: extendedEnd.x, y: extendedEnd.y, z: extendedEnd.z };
        line.setMetadata('isRay', true);
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¹Ø§Ø¹: ${line.id}`);
        return line;
    }

    // ==================== Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„Ø¹Ø±Ø¶ ====================

    private createLinePreview(): void {
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const endPoint = this.currentPoint!;
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ù†Ø¯Ø³Ø© Ø§Ù„Ø®Ø·
        const geometry = new BufferGeometry();
        const points = [startPoint, endPoint];
        geometry.setFromPoints(points);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø§Ø¯Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
        const material = new LineBasicMaterial({
            color: this.lineOptions.previewColor || '#2196F3',
            opacity: this.lineOptions.previewOpacity || 0.7,
            transparent: true,
            linewidth: 2
        });
        
        // ØªØ·Ø¨ÙŠÙ‚ Ù†Ù…Ø· Ø§Ù„Ø®Ø· Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
        if (this.lineDrawMode === LineDrawMode.CONSTRUCTION) {
            material.opacity = 0.3;
            // material.lineDashSize = 0.1;
            // material.lineGapSize = 0.05;
        }
        
        this.previewLine = new ThreeLine(geometry, material);
        this.previewObjects.push(this.previewLine);
        
        // Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø´Ù‡Ø¯ (Ø³ÙŠØ­ØªØ§Ø¬ Ø±Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø¹Ø§Ø±Ø¶)
        this.emit('previewObjectCreated', this.previewLine);
    }

    private updateLineInfo(): void {
        if (this.inputPoints.length === 0 || !this.currentPoint) {
            this.currentLineInfo = null;
            return;
        }
        
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const endPoint = this.currentPoint;
        
        // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø·
        const direction = new Vector3().subVectors(endPoint, startPoint);
        const length = direction.length();
        const angle = Math.atan2(direction.y, direction.x);
        const angleDegrees = angle * (180 / Math.PI);
        
        const midPoint = new Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
        
        this.currentLineInfo = {
            length,
            angle,
            angleDegrees,
            startPoint: { x: startPoint.x, y: startPoint.y, z: startPoint.z },
            endPoint: { x: endPoint.x, y: endPoint.y, z: endPoint.z },
            midPoint: { x: midPoint.x, y: midPoint.y, z: midPoint.z },
            direction: direction.normalize(),
            slope: direction.x !== 0 ? direction.y / direction.x : undefined,
            isHorizontal: Math.abs(direction.y) < 0.001,
            isVertical: Math.abs(direction.x) < 0.001,
            isDiagonal: Math.abs(Math.abs(direction.x) - Math.abs(direction.y)) < 0.001
        };
        
        // Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ø­Ø¯Ø«Ø©
        this.emit('lineInfoUpdated', this.currentLineInfo);
    }

    private showHelperLines(): void {
        if (!(this.lineOptions.constructionLines ?? false) || !this.currentLineInfo) {
            return;
        }
        
        this.clearHelperLines();
        
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const endPoint = this.currentPoint!;
        
        // Ø®Ø· Ø£ÙÙ‚ÙŠ Ù…Ø³Ø§Ø¹Ø¯
        if (this.shouldShowHorizontalHelper()) {
            this.helperLines.horizontal = this.createHelperLine(
                startPoint,
                new Vector3(endPoint.x, startPoint.y, startPoint.z),
                '#FF9800',
                0.3
            );
        }
        
        // Ø®Ø· Ø¹Ù…ÙˆØ¯ÙŠ Ù…Ø³Ø§Ø¹Ø¯
        if (this.shouldShowVerticalHelper()) {
            this.helperLines.vertical = this.createHelperLine(
                startPoint,
                new Vector3(startPoint.x, endPoint.y, startPoint.z),
                '#FF9800',
                0.3
            );
        }
        
        // Ø®Ø· Ù…Ø±Ø¬Ø¹ÙŠ Ù„Ù„Ø²Ø§ÙˆÙŠØ©
        if (this.shouldShowAngleHelper()) {
            this.helperLines.angleReference = this.createAngleHelper();
        }
    }

    private createHelperLine(start: Vector3, end: Vector3, color: string, opacity: number): ThreeLine {
        const geometry = new BufferGeometry();
        geometry.setFromPoints([start, end]);
        
        const material = new LineBasicMaterial({
            color,
            opacity,
            transparent: true,
            linewidth: 1
        });
        
        const line = new ThreeLine(geometry, material);
        this.previewObjects.push(line);
        this.emit('previewObjectCreated', line);
        
        return line;
    }

    private createAngleHelper(): ThreeLine | undefined {
        if (!this.currentLineInfo || this.inputPoints.length < 1) {
            return undefined;
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù‚ÙˆØ³ Ù„Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø²Ø§ÙˆÙŠØ©
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const radius = Math.min(this.currentLineInfo.length * 0.2, 2);
        
        const points: Vector3[] = [];
        const segments = 16;
        
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * this.currentLineInfo.angle;
            const x = startPoint.x + Math.cos(angle) * radius;
            const y = startPoint.y + Math.sin(angle) * radius;
            points.push(new Vector3(x, y, startPoint.z));
        }
        
        const geometry = new BufferGeometry();
        geometry.setFromPoints(points);
        
        const material = new LineBasicMaterial({
            color: '#4CAF50',
            opacity: 0.6,
            transparent: true
        });
        
        const arc = new ThreeLine(geometry, material);
        this.previewObjects.push(arc);
        this.emit('previewObjectCreated', arc);
        
        return arc;
    }

    private updateMeasurementDisplay(): void {
        if (!this.currentLineInfo) return;
        
        // Ø¹Ø±Ø¶ Ø§Ù„Ø·ÙˆÙ„
        if (this.lineOptions.showLength) {
            const lengthText = this.formatLength(this.currentLineInfo.length);
            this.emit('measurementUpdate', {
                type: 'length',
                value: lengthText,
                position: this.currentLineInfo.midPoint
            });
        }
        
        // Ø¹Ø±Ø¶ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
        if (this.lineOptions.showAngle) {
            const angleText = this.formatAngle(this.currentLineInfo.angleDegrees);
            this.emit('measurementUpdate', {
                type: 'angle',
                value: angleText,
                position: this.currentLineInfo.startPoint
            });
        }
    }

    // ==================== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… ====================

    public onMouseMove(point: Vector3, existingObjects: any[] = []): void {
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø®Ø§Øµ Ø¨Ø§Ù„Ø®Ø·ÙˆØ·
        let enhancedPoint = point.clone();
        
        // Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ©
        if (this.inputPoints.length > 0 && this.lineOptions.angleIncrement) {
            enhancedPoint = this.applyAngleSnap(enhancedPoint);
        }
        
        // Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ø·ÙˆÙ„
        if (this.inputPoints.length > 0 && this.lineOptions.lengthIncrement) {
            enhancedPoint = this.applyLengthSnap(enhancedPoint);
        }
        
        // Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
        super.onMouseMove(enhancedPoint, existingObjects);
    }

    private applyAngleSnap(point: Vector3): Vector3 {
        if (this.inputPoints.length === 0) return point;
        
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const direction = point.clone().sub(startPoint);
        const length = direction.length();
        
        if (length < 0.001) return point;
        
        const angle = Math.atan2(direction.y, direction.x);
        const angleDegrees = angle * (180 / Math.PI);
        
        // Ø§Ù†Ø¬Ø°Ø§Ø¨ Ù„Ø£Ù‚Ø±Ø¨ Ø²Ø§ÙˆÙŠØ©
        const increment = this.lineOptions.angleIncrement || 15;
        const snappedAngleDegrees = Math.round(angleDegrees / increment) * increment;
        const snappedAngle = snappedAngleDegrees * (Math.PI / 180);
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        return startPoint.clone().add(new Vector3(
            Math.cos(snappedAngle) * length,
            Math.sin(snappedAngle) * length,
            0
        ));
    }

    private applyLengthSnap(point: Vector3): Vector3 {
        if (this.inputPoints.length === 0) return point;
        
        const startPoint = this.inputPoints[this.inputPoints.length - 1].position;
        const direction = point.clone().sub(startPoint);
        const length = direction.length();
        
        if (length < 0.001) return point;
        
        // Ø§Ù†Ø¬Ø°Ø§Ø¨ Ù„Ø£Ù‚Ø±Ø¨ Ø·ÙˆÙ„
        const increment = this.lineOptions.lengthIncrement || 1;
        const snappedLength = Math.round(length / increment) * increment;
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        return startPoint.clone().add(direction.normalize().multiplyScalar(snappedLength));
    }

    // ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================

    private setupLineSpecificOptions(): void {
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø®ÙŠØ§Ø±Ø§Øª Ø®Ø§ØµØ© Ø¨Ø£Ø¯Ø§Ø© Ø§Ù„Ø®Ø·
        if (this.lineDrawMode === LineDrawMode.CONTINUOUS || 
            this.lineDrawMode === LineDrawMode.POLYLINE) {
            this.options.continuousMode = true;
            this.options.autoComplete = false;
        }
    }

    private applyLineProperties(line: Line): void {
        // ØªØ·Ø¨ÙŠÙ‚ Ø®ØµØ§Ø¦Øµ Ø®Ø§ØµØ© Ø¨Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·
        if (this.lineOptions.constructionLines && 
            this.lineDrawMode === LineDrawMode.CONSTRUCTION) {
            line.visualProperties = {
                ...line.visualProperties,
                color: '#888888',
                lineStyle: 'dashed',
                opacity: 0.5
            };
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
        line.setMetadata('drawMode', this.lineDrawMode);
        line.setMetadata('toolVersion', this.toolVersion);
        
        if (this.currentLineInfo) {
            line.setMetadata('lineInfo', this.currentLineInfo);
        }
    }

    private shouldShowHorizontalHelper(): boolean {
        return (this.lineOptions.constructionLines === true) && 
               !!this.currentLineInfo && 
               !this.currentLineInfo.isHorizontal &&
               Math.abs(this.currentLineInfo.angleDegrees) > 5;
    }

    private shouldShowVerticalHelper(): boolean {
        return (this.lineOptions.constructionLines === true) && 
               !!this.currentLineInfo && 
               !this.currentLineInfo.isVertical &&
               Math.abs(Math.abs(this.currentLineInfo.angleDegrees) - 90) > 5;
    }

    private shouldShowAngleHelper(): boolean {
        return (this.lineOptions.showAngle === true) && 
               !!this.currentLineInfo && 
               this.currentLineInfo.length > 0.5;
    }

    private clearHelperLines(): void {
        Object.values(this.helperLines).forEach(line => {
            if (line) {
                const index = this.previewObjects.indexOf(line);
                if (index !== -1) {
                    this.previewObjects.splice(index, 1);
                }
                this.emit('previewObjectRemoved', line);
            }
        });
        
        this.helperLines = {};
    }

    private formatLength(length: number): string {
        if (length < 0.01) return '0.00Ù…';
        
        if (length < 1) {
            return `${(length * 100).toFixed(0)}Ø³Ù…`;
        } else if (length < 1000) {
            return `${length.toFixed(2)}Ù…`;
        } else {
            return `${(length / 1000).toFixed(3)}ÙƒÙ…`;
        }
    }

    private formatAngle(degrees: number): string {
        const normalized = ((degrees % 360) + 360) % 360;
        return `${normalized.toFixed(1)}Â°`;
    }

    // ==================== ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø§Ù…Ø© ====================

    /**
     * ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø±Ø³Ù… Ø§Ù„Ø®Ø·
     */
    public setLineDrawMode(mode: LineDrawMode): void {
        if (this.state === 'drawing') {
            this.logger.warn('Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø§Ù„Ø±Ø³Ù… Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ù…');
            return;
        }
        
        this.lineDrawMode = mode;
        this.setupLineSpecificOptions();
        this.resetTool();
        
        this.emit('drawModeChanged', { mode, toolId: this.toolId });
        this.logger.info(`ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…Ø· Ø±Ø³Ù… Ø§Ù„Ø®Ø· Ø¥Ù„Ù‰: ${mode}`);
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Ù…Ø· Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
     */
    public getLineDrawMode(): LineDrawMode {
        return this.lineDrawMode;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ
     */
    public getCurrentLineInfo(): LineInfo | null {
        return this.currentLineInfo ? { ...this.currentLineInfo } : null;
    }

    /**
     * ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
     */
    public setConstructionLinesEnabled(enabled: boolean): void {
        this.lineOptions.constructionLines = enabled;
        
        if (!enabled) {
            this.clearHelperLines();
        }
        
        this.emit('constructionLinesToggled', { enabled, toolId: this.toolId });
    }

    /**
     * ØªØ¹ÙŠÙŠÙ† Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠ
     */
    public setAngleIncrement(degrees: number): void {
        this.lineOptions.angleIncrement = Math.max(1, Math.min(90, degrees));
        this.emit('angleIncrementChanged', { 
            increment: this.lineOptions.angleIncrement, 
            toolId: this.toolId 
        });
    }

    /**
     * ØªØ¹ÙŠÙŠÙ† Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨ Ù„Ù„Ø·ÙˆÙ„
     */
    public setLengthIncrement(length: number): void {
        this.lineOptions.lengthIncrement = Math.max(0.001, length);
        this.emit('lengthIncrementChanged', { 
            increment: this.lineOptions.lengthIncrement, 
            toolId: this.toolId 
        });
    }

    /**
     * Ø±Ø¨Ø· Ø§Ù„Ø¹Ø§Ø±Ø¶ Ù„Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
     */
    public setViewer(viewer: any): void {
        this.viewer = viewer;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©
     */
    public getDetailedStats(): any {
        const baseStats = this.getStats();
        
        return {
            ...baseStats,
            lineDrawMode: this.lineDrawMode,
            totalLinesDrawn: baseStats.completionCount,
            averageLineLength: this.calculateAverageLineLength(),
            mostUsedAngles: this.getMostUsedAngles(),
            constructionLinesUsed: this.lineOptions.constructionLines
        };
    }

    private calculateAverageLineLength(): number {
        // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø·ÙˆÙ„ Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ù…Ø±Ø³ÙˆÙ…Ø©
        // TODO: ØªÙ†ÙÙŠØ° Ø­Ø³Ø§Ø¨ ÙØ¹Ù„ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ§Ø±ÙŠØ®
        return 0;
    }

    private getMostUsedAngles(): number[] {
        // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ø£ÙƒØ«Ø± Ø§Ø³ØªØ®Ø¯Ø§Ù…Ø§Ù‹
        // TODO: ØªÙ†ÙÙŠØ° ØªØªØ¨Ø¹ ÙØ¹Ù„ÙŠ Ù„Ù„Ø²ÙˆØ§ÙŠØ§
        return [0, 45, 90, 135, 180];
    }

    /**
     * ØªÙ†Ø¸ÙŠÙ Ù…Ø­Ø³Ù†
     */
    public dispose(): void {
        this.clearPreview();
        this.clearHelperLines();
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹
        this.previewLine = null;
        this.currentLineInfo = null;
        this.viewer = null;
        
        super.dispose();
    }

    /**
     * Ù…Ø³Ø­ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø­Ø³Ù†
     */
    protected clearPreview(): void {
        super.clearPreview();
        this.clearHelperLines();
        
        if (this.previewLine) {
            this.emit('previewObjectRemoved', this.previewLine);
            this.previewLine = null;
        }
    }
}

==== FILE: src\drawing_tools\DrawPolylineTool.ts ====

/**
 * DrawPolylineTool - Polyline Drawing Tool
 * Tool for drawing multi-segment lines (polylines)
 */

import { Vector3, BufferGeometry, LineBasicMaterial, Line as ThreeLine } from 'three';
import { AbstractDrawTool, DrawToolOptions, DrawResult, DrawMode } from './AbstractDrawTool';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { CommandManager, Command } from '../core/CommandManager';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Polyline } from '../models/Polyline';
import { GeometricObject } from '../models/GeometricObject';

// Polyline drawing modes
export enum PolylineDrawMode {
    OPEN = 'open',                   // Open polyline
    CLOSED = 'closed',               // Closed polyline (polygon)
    RECTANGLE = 'rectangle',         // Rectangle mode
    REGULAR_POLYGON = 'regular-polygon', // Regular polygon
    FREEHAND = 'freehand'           // Freehand drawing
}

// Polyline-specific options
export interface PolylineToolOptions extends Omit<DrawToolOptions, 'drawMode'> {
    polylineMode?: PolylineDrawMode;
    showLength?: boolean;
    showSegmentLengths?: boolean;
    showArea?: boolean;
    showAngles?: boolean;
    autoClose?: boolean;
    closeThreshold?: number;
    minSegmentLength?: number;
    smoothing?: boolean;
    polygonSides?: number;
}

// Polyline information
export interface PolylineInfo {
    vertices: Point3D[];
    totalLength: number;
    segmentLengths: number[];
    isClosed: boolean;
    area?: number;
    perimeter?: number;
    boundingBox: { min: Point3D; max: Point3D };
    centroid?: Point3D;
}

// Add polyline command
class AddPolylineCommand implements Command {
    private polyline: Polyline;
    private viewer: any;

    constructor(polyline: Polyline, viewer: any) {
        this.polyline = polyline;
        this.viewer = viewer;
    }

    execute(): void {
        this.viewer?.addGeometricObject(this.polyline);
    }

    undo(): void {
        this.viewer?.removeGeometricObject(this.polyline.id);
    }

    getDescription(): string {
        return `Add polyline: ${this.polyline.id}`;
    }
}

/**
 * Polyline Drawing Tool
 */
export class DrawPolylineTool extends AbstractDrawTool {
    private polylineDrawMode: PolylineDrawMode = PolylineDrawMode.OPEN;
    private previewPolyline: ThreeLine | null = null;
    private currentPolylineInfo: PolylineInfo | null = null;
    private viewer: any = null;

    // Polyline-specific settings
    private polylineOptions: PolylineToolOptions;
    
    // Helper elements
    private vertexMarkers: ThreeLine[] = [];
    private segmentLabels: any[] = [];

    constructor(
        geometryEngine: GeometryEngine,
        commandManager: CommandManager,
        snapSystem: SnapSystem,
        measurementSystem: MeasurementSystem,
        options: PolylineToolOptions = {},
        mode: PolylineDrawMode = PolylineDrawMode.OPEN
    ) {
        super(
            'draw-polyline',
            'Draw Polyline',
            geometryEngine,
            commandManager,
            snapSystem,
            measurementSystem,
            {
                snapEnabled: true,
                measurementEnabled: true,
                previewEnabled: true,
                autoComplete: false,
                undoEnabled: true,
                constraintsEnabled: true,
                precision: 0.001,
                tolerance: 0.1,
                maxPoints: 1000,
                minPoints: 2,
                drawMode: DrawMode.CONTINUOUS,
                ...options
            }
        );

        this.polylineDrawMode = mode;
        this.polylineOptions = {
            ...this.options,
            showLength: true,
            showSegmentLengths: false,
            showArea: false,
            showAngles: false,
            autoClose: false,
            closeThreshold: 0.5,
            minSegmentLength: 0.1,
            smoothing: false,
            polygonSides: 6,
            ...options
        } as PolylineToolOptions;
    }

    // ==================== Required Abstract Functions ====================

    protected getRequiredPointCount(): number {
        switch (this.polylineDrawMode) {
            case PolylineDrawMode.RECTANGLE:
                return 2; // Two corners
            case PolylineDrawMode.REGULAR_POLYGON:
                return 2; // Center and radius point
            case PolylineDrawMode.FREEHAND:
                return 1; // Start point
            default:
                return 2; // Minimum for open/closed polylines
        }
    }

    protected validatePoints(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        // Check for minimum segment length
        if (this.polylineOptions.minSegmentLength) {
            for (let i = 1; i < this.inputPoints.length; i++) {
                const dist = this.inputPoints[i-1].position.distanceTo(this.inputPoints[i].position);
                if (dist < this.polylineOptions.minSegmentLength) {
                    this.logger.warn('Segment too short');
                    return false;
                }
            }
        }

        return true;
    }

    protected createGeometry(): GeometricObject | null {
        if (!this.validatePoints()) {
            return null;
        }

        try {
            switch (this.polylineDrawMode) {
                case PolylineDrawMode.OPEN:
                    return this.createOpenPolyline();
                case PolylineDrawMode.CLOSED:
                    return this.createClosedPolyline();
                case PolylineDrawMode.RECTANGLE:
                    return this.createRectangle();
                case PolylineDrawMode.REGULAR_POLYGON:
                    return this.createRegularPolygon();
                case PolylineDrawMode.FREEHAND:
                    return this.createFreehandPolyline();
                default:
                    return null;
            }
        } catch (error) {
            this.logger.error('Failed to create polyline:', error);
            return null;
        }
    }

    protected updatePreview(): void {
        if (!this.shouldShowPreview()) {
            this.clearPreview();
            return;
        }

        try {
            this.clearPreview();
            
            if (this.inputPoints.length > 0 && this.currentPoint) {
                this.calculateCurrentPolylineInfo();
                
                if (this.currentPolylineInfo) {
                    this.createPolylinePreview();
                    this.showVertexMarkers();
                    this.updateMeasurementDisplay();
                }
            }
        } catch (error) {
            this.logger.error('Failed to update polyline preview:', error);
        }
    }

    protected getDisplayName(): string {
        const modeNames = {
            [PolylineDrawMode.OPEN]: 'Polyline (Open)',
            [PolylineDrawMode.CLOSED]: 'Polyline (Closed)',
            [PolylineDrawMode.RECTANGLE]: 'Rectangle',
            [PolylineDrawMode.REGULAR_POLYGON]: 'Regular Polygon',
            [PolylineDrawMode.FREEHAND]: 'Freehand Polyline'
        };
        
        return modeNames[this.polylineDrawMode] || 'Draw Polyline';
    }

    protected canComplete(): boolean {
        if (this.inputPoints.length < this.getRequiredPointCount()) {
            return false;
        }

        // Special completion for different modes
        switch (this.polylineDrawMode) {
            case PolylineDrawMode.RECTANGLE:
            case PolylineDrawMode.REGULAR_POLYGON:
                return this.inputPoints.length >= this.getRequiredPointCount();
            default:
                return this.inputPoints.length >= 2;
        }
    }

    protected createAddCommand(object: GeometricObject): Command {
        return new AddPolylineCommand(object as Polyline, this.viewer);
    }

    // ==================== Polyline Creation Methods ====================

    private createOpenPolyline(): Polyline {
        const vertices = this.inputPoints.map(ip => ({
            x: ip.position.x,
            y: ip.position.y,
            z: ip.position.z
        }));
        
        const polyline = new Polyline(vertices, false);
        
        this.logger.info(`Created open polyline: ${polyline.id}`);
        return polyline;
    }

    private createClosedPolyline(): Polyline {
        const vertices = this.inputPoints.map(ip => ({
            x: ip.position.x,
            y: ip.position.y,
            z: ip.position.z
        }));
        
        const polyline = new Polyline(vertices, true);
        
        this.logger.info(`Created closed polyline: ${polyline.id}`);
        return polyline;
    }

    private createRectangle(): Polyline {
        if (this.inputPoints.length < 2) return this.createOpenPolyline();
        
        const p1 = this.inputPoints[0].position;
        const p2 = this.inputPoints[1].position;
        
        const vertices: Point3D[] = [
            { x: p1.x, y: p1.y, z: p1.z },
            { x: p2.x, y: p1.y, z: p1.z },
            { x: p2.x, y: p2.y, z: p1.z },
            { x: p1.x, y: p2.y, z: p1.z }
        ];
        
        const polyline = new Polyline(vertices, true);
        polyline.setMetadata('isRectangle', true);
        
        this.logger.info(`Created rectangle: ${polyline.id}`);
        return polyline;
    }

    private createRegularPolygon(): Polyline {
        if (this.inputPoints.length < 2) return this.createOpenPolyline();
        
        const center = this.inputPoints[0].position;
        const radiusPoint = this.inputPoints[1].position;
        const radius = center.distanceTo(radiusPoint);
        const sides = this.polylineOptions.polygonSides || 6;
        
        const vertices: Point3D[] = [];
        const angleStep = (2 * Math.PI) / sides;
        const startAngle = Math.atan2(radiusPoint.y - center.y, radiusPoint.x - center.x);
        
        for (let i = 0; i < sides; i++) {
            const angle = startAngle + i * angleStep;
            vertices.push({
                x: center.x + radius * Math.cos(angle),
                y: center.y + radius * Math.sin(angle),
                z: center.z
            });
        }
        
        const polyline = new Polyline(vertices, true);
        polyline.setMetadata('isRegularPolygon', true);
        polyline.setMetadata('sides', sides);
        polyline.setMetadata('center', { x: center.x, y: center.y, z: center.z });
        polyline.setMetadata('radius', radius);
        
        this.logger.info(`Created regular polygon (${sides} sides): ${polyline.id}`);
        return polyline;
    }

    private createFreehandPolyline(): Polyline {
        // For freehand, we might want to smooth the points
        let vertices = this.inputPoints.map(ip => ({
            x: ip.position.x,
            y: ip.position.y,
            z: ip.position.z
        }));
        
        if (this.polylineOptions.smoothing) {
            vertices = this.smoothVertices(vertices);
        }
        
        const polyline = new Polyline(vertices, false);
        polyline.setMetadata('isFreehand', true);
        
        this.logger.info(`Created freehand polyline: ${polyline.id}`);
        return polyline;
    }

    // ==================== Polyline Calculations ====================

    private calculateCurrentPolylineInfo(): void {
        this.currentPolylineInfo = null;
        
        try {
            let vertices: Point3D[] = [];
            
            // Build vertex list based on mode
            switch (this.polylineDrawMode) {
                case PolylineDrawMode.RECTANGLE:
                    if (this.inputPoints.length >= 1 && this.currentPoint) {
                        const p1 = this.inputPoints[0].position;
                        vertices = [
                            { x: p1.x, y: p1.y, z: p1.z },
                            { x: this.currentPoint.x, y: p1.y, z: p1.z },
                            { x: this.currentPoint.x, y: this.currentPoint.y, z: p1.z },
                            { x: p1.x, y: this.currentPoint.y, z: p1.z }
                        ];
                    }
                    break;
                    
                case PolylineDrawMode.REGULAR_POLYGON:
                    if (this.inputPoints.length >= 1 && this.currentPoint) {
                        const center = this.inputPoints[0].position;
                        const radius = center.distanceTo(this.currentPoint);
                        const sides = this.polylineOptions.polygonSides || 6;
                        const angleStep = (2 * Math.PI) / sides;
                        const startAngle = Math.atan2(
                            this.currentPoint.y - center.y,
                            this.currentPoint.x - center.x
                        );
                        
                        vertices = [];
                        for (let i = 0; i < sides; i++) {
                            const angle = startAngle + i * angleStep;
                            vertices.push({
                                x: center.x + radius * Math.cos(angle),
                                y: center.y + radius * Math.sin(angle),
                                z: center.z
                            });
                        }
                    }
                    break;
                    
                default:
                    vertices = this.inputPoints.map(ip => ({
                        x: ip.position.x,
                        y: ip.position.y,
                        z: ip.position.z
                    }));
                    
                    if (this.currentPoint) {
                        vertices.push({
                            x: this.currentPoint.x,
                            y: this.currentPoint.y,
                            z: this.currentPoint.z
                        });
                    }
            }
            
            if (vertices.length < 2) return;
            
            // Calculate properties
            const segmentLengths: number[] = [];
            let totalLength = 0;
            
            for (let i = 1; i < vertices.length; i++) {
                const length = this.calculateDistance(vertices[i-1], vertices[i]);
                segmentLengths.push(length);
                totalLength += length;
            }
            
            const isClosed = this.shouldBeClosed(vertices);
            if (isClosed && vertices.length > 2) {
                const closingLength = this.calculateDistance(
                    vertices[vertices.length - 1],
                    vertices[0]
                );
                segmentLengths.push(closingLength);
                totalLength += closingLength;
            }
            
            // Calculate bounds
            const xs = vertices.map(v => v.x);
            const ys = vertices.map(v => v.y);
            const zs = vertices.map(v => v.z);
            
            const boundingBox = {
                min: { x: Math.min(...xs), y: Math.min(...ys), z: Math.min(...zs) },
                max: { x: Math.max(...xs), y: Math.max(...ys), z: Math.max(...zs) }
            };
            
            // Calculate area and centroid for closed polylines
            let area: number | undefined;
            let centroid: Point3D | undefined;
            
            if (isClosed && vertices.length > 2) {
                area = this.calculatePolygonArea(vertices);
                centroid = this.calculateCentroid(vertices);
            }
            
            this.currentPolylineInfo = {
                vertices,
                totalLength,
                segmentLengths,
                isClosed,
                area,
                perimeter: isClosed ? totalLength : undefined,
                boundingBox,
                centroid
            };

            this.emit('polylineInfoUpdated', this.currentPolylineInfo);

        } catch (error) {
            this.logger.error('Failed to calculate polyline info:', error);
        }
    }

    private shouldBeClosed(vertices: Point3D[]): boolean {
        if (this.polylineDrawMode === PolylineDrawMode.CLOSED ||
            this.polylineDrawMode === PolylineDrawMode.RECTANGLE ||
            this.polylineDrawMode === PolylineDrawMode.REGULAR_POLYGON) {
            return true;
        }
        
        // Auto-close if near first point
        if (this.polylineOptions.autoClose && vertices.length > 2) {
            const dist = this.calculateDistance(
                vertices[vertices.length - 1],
                vertices[0]
            );
            return dist < (this.polylineOptions.closeThreshold || 0.5);
        }
        
        return false;
    }

    private calculateDistance(p1: Point3D, p2: Point3D): number {
        return Math.sqrt(
            Math.pow(p2.x - p1.x, 2) +
            Math.pow(p2.y - p1.y, 2) +
            Math.pow(p2.z - p1.z, 2)
        );
    }

    private calculatePolygonArea(vertices: Point3D[]): number {
        let area = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
        }
        
        return Math.abs(area) / 2;
    }

    private calculateCentroid(vertices: Point3D[]): Point3D {
        let cx = 0, cy = 0;
        const n = vertices.length;
        
        for (let i = 0; i < n; i++) {
            cx += vertices[i].x;
            cy += vertices[i].y;
        }
        
        return {
            x: cx / n,
            y: cy / n,
            z: vertices[0].z
        };
    }

    private smoothVertices(vertices: Point3D[]): Point3D[] {
        if (vertices.length < 3) return vertices;
        
        const smoothed: Point3D[] = [vertices[0]];
        
        for (let i = 1; i < vertices.length - 1; i++) {
            smoothed.push({
                x: (vertices[i-1].x + vertices[i].x + vertices[i+1].x) / 3,
                y: (vertices[i-1].y + vertices[i].y + vertices[i+1].y) / 3,
                z: (vertices[i-1].z + vertices[i].z + vertices[i+1].z) / 3
            });
        }
        
        smoothed.push(vertices[vertices.length - 1]);
        return smoothed;
    }

    // ==================== Preview Methods ====================

    private createPolylinePreview(): void {
        if (!this.currentPolylineInfo) return;

        const { vertices, isClosed } = this.currentPolylineInfo;
        
        const points = vertices.map(v => new Vector3(v.x, v.y, v.z));
        
        if (isClosed && points.length > 2) {
            points.push(points[0].clone());
        }
        
        const geometry = new BufferGeometry().setFromPoints(points);
        
        const material = new LineBasicMaterial({
            color: this.polylineOptions.previewColor || '#2196F3',
            linewidth: 2
        });
        
        this.previewPolyline = new ThreeLine(geometry, material);
        this.previewObjects.push(this.previewPolyline);
        this.emit('previewObjectCreated', this.previewPolyline);
    }

    private showVertexMarkers(): void {
        if (!this.currentPolylineInfo) return;
        
        const { vertices } = this.currentPolylineInfo;
        
        vertices.forEach((vertex, index) => {
            const size = 0.1;
            const points = [
                new Vector3(vertex.x - size, vertex.y, vertex.z),
                new Vector3(vertex.x + size, vertex.y, vertex.z),
                new Vector3(vertex.x, vertex.y - size, vertex.z),
                new Vector3(vertex.x, vertex.y + size, vertex.z)
            ];
            
            const geometry = new BufferGeometry().setFromPoints(points);
            const material = new LineBasicMaterial({
                color: index === 0 ? '#4CAF50' : '#FF9800',
                opacity: 0.8,
                transparent: true
            });
            
            const marker = new ThreeLine(geometry, material);
            this.vertexMarkers.push(marker);
            this.previewObjects.push(marker);
            this.emit('previewObjectCreated', marker);
        });
    }

    private updateMeasurementDisplay(): void {
        if (!this.currentPolylineInfo) return;
        
        const { totalLength, area, perimeter, centroid } = this.currentPolylineInfo;
        
        // Show total length
        if (this.polylineOptions.showLength) {
            this.emit('measurementUpdate', {
                type: 'length',
                value: `Length: ${this.formatLength(totalLength)}`,
                position: centroid || this.currentPolylineInfo.vertices[0]
            });
        }
        
        // Show area for closed polylines
        if (this.polylineOptions.showArea && area !== undefined) {
            this.emit('measurementUpdate', {
                type: 'area',
                value: `Area: ${this.formatArea(area)}`,
                position: centroid
            });
        }
    }

    // ==================== Event Handlers ====================

    public onMouseClick(point: Vector3, existingObjects: any[] = []): DrawResult {
        const result = super.onMouseClick(point, existingObjects);
        
        // Handle auto-close
        if (result.success && this.polylineOptions.autoClose && 
            this.inputPoints.length > 2) {
            const firstPoint = this.inputPoints[0].position;
            const distance = point.distanceTo(firstPoint);
            
            if (distance < (this.polylineOptions.closeThreshold || 0.5)) {
                return this.completeDraw();
            }
        }
        
        return result;
    }

    public onDoubleClick(event: MouseEvent): void {
        // Complete polyline on double-click
        if (this.canComplete()) {
            this.completeDraw();
        }
    }

    // ==================== Helper Methods ====================

    private formatLength(length: number): string {
        if (length < 0.01) return '0.00m';
        if (length < 1) return `${(length * 100).toFixed(0)}cm`;
        if (length < 1000) return `${length.toFixed(2)}m`;
        return `${(length / 1000).toFixed(3)}km`;
    }

    private formatArea(area: number): string {
        if (area < 1) return `${(area * 10000).toFixed(0)}cmÂ²`;
        if (area < 10000) return `${area.toFixed(2)}mÂ²`;
        return `${(area / 10000).toFixed(3)}hectares`;
    }

    // ==================== Public Interface ====================

    public setPolylineDrawMode(mode: PolylineDrawMode): void {
        if (this.state === 'drawing') {
            this.logger.warn('Cannot change drawing mode while drawing');
            return;
        }
        
        this.polylineDrawMode = mode;
        this.resetTool();
        
        this.emit('drawModeChanged', { mode, toolId: this.toolId });
        this.logger.info(`Changed polyline drawing mode to: ${mode}`);
    }

    public setPolygonSides(sides: number): void {
        this.polylineOptions.polygonSides = Math.max(3, Math.min(20, sides));
        this.updatePreview();
    }

    public setViewer(viewer: any): void {
        this.viewer = viewer;
    }

    public undoLastVertex(): void {
        if (this.inputPoints.length > 1) {
            this.inputPoints.pop();
            this.updatePreview();
            this.emit('vertexRemoved', { count: this.inputPoints.length });
        }
    }

    protected clearPreview(): void {
        super.clearPreview();
        
        this.vertexMarkers.forEach(marker => {
            this.emit('previewObjectRemoved', marker);
        });
        this.vertexMarkers = [];
        
        if (this.previewPolyline) {
            this.emit('previewObjectRemoved', this.previewPolyline);
            this.previewPolyline = null;
        }
    }
}

==== FILE: src\editing_tools\AbstractEditTool.ts ====



==== FILE: src\editing_tools\MoveTool.ts ====

import { Vector3 } from 'three';
import { GeometricObject } from '../models/GeometricObject';
import { Logger } from '../core/Logger';
import { CommandManager } from '../core/CommandManager';

export class MoveTool {
    private logger: Logger;
    private commandManager: CommandManager;
    private selectedObjects: GeometricObject[] = [];
    private isMoving: boolean = false;
    private startPoint: Vector3 | null = null;

    constructor(commandManager: CommandManager) {
        this.logger = Logger.getInstance();
        this.commandManager = commandManager;
    }

    public selectObjects(objects: GeometricObject[]): void {
        this.selectedObjects = objects;
        this.logger.info(`ØªÙ… ØªØ­Ø¯ÙŠØ¯ ${objects.length} ÙƒØ§Ø¦Ù† Ù„Ù„ØªØ­Ø±ÙŠÙƒ`);
    }

    public startMove(point: Vector3): void {
        if (this.selectedObjects.length === 0) {
            this.logger.warn('Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙƒØ§Ø¦Ù†Ø§Øª Ù„Ù„ØªØ­Ø±ÙŠÙƒ');
            return;
        }

        this.isMoving = true;
        this.startPoint = point.clone();
        this.logger.debug('Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø±ÙŠÙƒ');
    }

    public updateMove(currentPoint: Vector3): void {
        if (!this.isMoving || !this.startPoint) return;

        const delta = new Vector3().subVectors(currentPoint, this.startPoint);
        
        // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø­Ø±ÙƒØ©
        this.selectedObjects.forEach(obj => {
            const currentTransform = obj.transform;
            obj.applyTransform({
                translation: {
                    x: delta.x,
                    y: delta.y,
                    z: delta.z
                }
            });
        });
    }

    public completeMove(endPoint: Vector3): void {
        if (!this.isMoving || !this.startPoint) return;

        const delta = new Vector3().subVectors(endPoint, this.startPoint);
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ù…Ø± Ø§Ù„ØªØ­Ø±ÙŠÙƒ
        // const moveCommand = new MoveObjectsCommand(this.selectedObjects, delta);
        // this.commandManager.execute(moveCommand);

        this.isMoving = false;
        this.startPoint = null;
        this.logger.info('ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø±ÙŠÙƒ');
    }

    public cancelMove(): void {
        if (this.isMoving) {
            // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            this.isMoving = false;
            this.startPoint = null;
            this.logger.info('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø±ÙŠÙƒ');
        }
    }
}

==== FILE: src\editing_tools\TrimTool.ts ====



==== FILE: src\file_io\IFileParser.ts ====



==== FILE: src\file_io\IGESHandler.ts ====



==== FILE: src\file_io\JSONSerializer.ts ====



==== FILE: src\file_io\STEPHandler.ts ====



==== FILE: src\main.ts ====

/**
 * main.ts - Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…
 * Ù†Ø¸Ø§Ù… Ù…ØªÙƒØ§Ù…Ù„ Ù„Ø¥Ø¯Ø§Ø±Ø© ØªØ·Ø¨ÙŠÙ‚ CAD Ù…ØªÙ‚Ø¯Ù… Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù‚Ø¯Ø©
 */

import './styles/main.css';

// Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
import { Viewer, ViewMode, ViewOrientation, ViewSettings, PerformanceStats } from './rendering/Viewer';
import { GeometryEngine } from './core/GeometryEngine';
import { Logger, LogLevel } from './core/Logger';
import { CommandManager } from './core/CommandManager';
import { ProjectManager } from './core/ProjectManager';

// Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
import { DrawLineTool } from './drawing_tools/DrawLineTool';
import { DrawCircleTool, CircleDrawMode } from './drawing_tools/DrawCircleTool';
import { MoveTool } from './editing_tools/MoveTool';

// Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
import { SnapSystem } from './systems/SnapSystem';
import { MeasurementSystem } from './systems/MeasurementSystem';

// Ø§Ù„Ù†Ù…Ø§Ø°Ø¬
import { GeometricObject } from './models/GeometricObject';
import { Layer } from './models/Layer';
import { Wall } from './models/Wall';
import { BuildingElement } from './models/BuildingElement';

// Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª ÙˆØ§Ù„Ø£Ù†ÙˆØ§Ø¹
interface AppConfiguration {
    version: string;
    buildDate: string;
    environment: 'development' | 'production' | 'testing';
    features: {
        advancedTools: boolean;
        cloudSync: boolean;
        collaboration: boolean;
        aiAssistant: boolean;
        plugins: boolean;
    };
    performance: {
        maxObjects: number;
        maxMemory: number;
        renderQuality: 'low' | 'medium' | 'high' | 'ultra';
        antialiasing: boolean;
    };
    ui: {
        theme: 'light' | 'dark' | 'auto';
        language: 'ar' | 'en' | 'fr';
        layout: 'standard' | 'compact' | 'expanded';
        animations: boolean;
    };
}

interface ApplicationState {
    viewer: Viewer | null;
    commandManager: CommandManager;
    projectManager: ProjectManager;
    geometryEngine: GeometryEngine;
    
    // Ø­Ø§Ù„Ø© ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    ui: {
        currentTool: string;
        activeLayer: string;
        selectedObjects: Set<string>;
        viewMode: ViewMode;
        showGrid: boolean;
        showAxes: boolean;
        showDimensions: boolean;
    };
    
    // Ø§Ù„Ø£Ø¯ÙˆØ§Øª
    tools: {
        drawLine: DrawLineTool | null;
        drawCircle: DrawCircleTool | null;
        move: MoveTool | null;
        [key: string]: any;
    };
    
    // Ø§Ù„Ø£Ù†Ø¸Ù…Ø©
    systems: {
        snapSystem: SnapSystem | null;
        measurementSystem: MeasurementSystem | null;
    };
    
    // Ø§Ù„Ø·Ø¨Ù‚Ø§Øª ÙˆØ§Ù„Ù…Ø´Ø±ÙˆØ¹
    project: {
        layers: Map<string, Layer>;
        activeObjects: Map<string, GeometricObject>;
        projectPath: string | null;
        isDirty: boolean;
        lastSaved: Date | null;
    };
    
    // Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ÙˆØ§Ù„Ø£Ø¯Ø§Ø¡
    status: {
        isInitialized: boolean;
        isLoading: boolean;
        loadingProgress: number;
        lastError: Error | null;
        performanceMode: 'optimal' | 'balanced' | 'quality';
    };
}

interface ToolDefinition {
    id: string;
    name: string;
    category: 'draw' | 'edit' | 'measure' | 'view';
    icon: string;
    shortcut?: string;
    description: string;
    create: () => any;
}

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
const APP_CONFIG: AppConfiguration = {
    version: '2.0.0-beta',
    buildDate: new Date().toISOString(),
    environment: 'development',
    features: {
        advancedTools: true,
        cloudSync: false,
        collaboration: false,
        aiAssistant: false,
        plugins: true
    },
    performance: {
        maxObjects: 10000,
        maxMemory: 2048 * 1024 * 1024, // 2GB
        renderQuality: 'high',
        antialiasing: true
    },
    ui: {
        theme: 'light',
        language: 'ar',
        layout: 'standard',
        animations: true
    }
};

// Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¹Ø§Ù…Ø©
const appState: ApplicationState = {
    viewer: null,
    commandManager: new CommandManager(),
    projectManager: new ProjectManager(),
    geometryEngine: GeometryEngine.getInstance(),
    
    ui: {
        currentTool: 'select',
        activeLayer: 'default',
        selectedObjects: new Set(),
        viewMode: ViewMode.SHADED,
        showGrid: true,
        showAxes: true,
        showDimensions: true
    },
    
    tools: {
        drawLine: null,
        drawCircle: null,
        move: null
    },
    
    systems: {
        snapSystem: null,
        measurementSystem: null
    },
    
    project: {
        layers: new Map(),
        activeObjects: new Map(),
        projectPath: null,
        isDirty: false,
        lastSaved: null
    },
    
    status: {
        isInitialized: false,
        isLoading: false,
        loadingProgress: 0,
        lastError: null,
        performanceMode: 'balanced'
    }
};

// ØªØ¹Ø±ÙŠÙØ§Øª Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©
const TOOL_DEFINITIONS: ToolDefinition[] = [
    {
        id: 'select',
        name: 'ØªØ­Ø¯ÙŠØ¯',
        category: 'edit',
        icon: 'cursor',
        shortcut: 'S',
        description: 'Ø£Ø¯Ø§Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯ ÙˆØ§Ù„ØªÙ„Ø§Ø¹Ø¨ Ø¨Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª',
        create: () => null
    },
    {
        id: 'line',
        name: 'Ø®Ø·',
        category: 'draw',
        icon: 'line',
        shortcut: 'L',
        description: 'Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ù…Ø³ØªÙ‚ÙŠÙ…Ø©',
        create: () => new DrawLineTool(
            appState.geometryEngine,
            appState.commandManager,
            appState.systems.snapSystem!,
            appState.systems.measurementSystem!
        )
    },
    {
        id: 'circle',
        name: 'Ø¯Ø§Ø¦Ø±Ø©',
        category: 'draw',
        icon: 'circle',
        shortcut: 'C',
        description: 'Ø±Ø³Ù… Ø¯ÙˆØ§Ø¦Ø± ÙˆØ£Ù‚ÙˆØ§Ø³',
        create: () => new DrawCircleTool(
            appState.geometryEngine,
            appState.commandManager,
            appState.systems.snapSystem!,
            appState.systems.measurementSystem!,
            {},
            CircleDrawMode.CENTER_RADIUS
        )
    },
    {
        id: 'move',
        name: 'ØªØ­Ø±ÙŠÙƒ',
        category: 'edit',
        icon: 'move',
        shortcut: 'M',
        description: 'ØªØ­Ø±ÙŠÙƒ ÙˆÙ†Ø³Ø® Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª',
        create: () => new MoveTool(appState.commandManager)
    }
];

const logger = Logger.getInstance();

// ==================== ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ====================

/**
 * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
 */
async function initializeApplication(): Promise<void> {
    try {
        logger.info(`ğŸš€ Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© TyrexWebCad ${APP_CONFIG.version}...`);
        appState.status.isLoading = true;
        
        // Ø¹Ø±Ø¶ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨
        showWelcomeScreen();
        
        updateLoadingProgress(30, 'ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ...');
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ - Ø³ÙŠÙ‚ÙˆÙ… Ø¨ØªØ­Ù…ÙŠÙ„ OpenCASCADE Ø¨Ù†ÙØ³Ù‡
        await appState.geometryEngine.initialize();
        updateLoadingProgress(50, 'Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ø±Ø¶...');
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ø±Ø¶
        await initializeViewer();
        updateLoadingProgress(70, 'ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª...');
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ù†Ø¸Ù…Ø© ÙˆØ§Ù„Ø£Ø¯ÙˆØ§Øª
        await initializeSystems();
        await initializeTools();
        updateLoadingProgress(85, 'Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…...');
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        await setupUserInterface();
        await loadUserPreferences();
        updateLoadingProgress(95, 'ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ...');
        
        // ØªØ­Ù…ÙŠÙ„ Ù…Ø´Ø±ÙˆØ¹ Ø§ÙØªØ±Ø§Ø¶ÙŠ
        await loadDefaultProject();
        updateLoadingProgress(100, 'Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„!');
        
        // Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
        appState.status.isInitialized = true;
        appState.status.isLoading = false;
        
        hideLoadingScreen();
        showMainInterface();
        
        logger.info('âœ… ØªÙ… ØªÙ‡ÙŠØ¦Ø© TyrexWebCad Ø¨Ù†Ø¬Ø§Ø­');
        showWelcomeMessage();
        
        // Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
        startPerformanceMonitoring();
        
    } catch (error) {
        handleInitializationError(error);
    }
}

/**
 * ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ø±Ø¶
 */
async function initializeViewer(): Promise<void> {
    const viewerContainer = document.getElementById('viewer-container');
    if (!viewerContainer) {
        throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø§ÙˆÙŠ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯');
    }
    
    appState.viewer = new Viewer(viewerContainer);
    
    // Ø§Ù†ØªØ¸Ø§Ø± ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    let attempts = 0;
    const maxAttempts = 100;
    
    while (!appState.viewer.isInitialized() && attempts < maxAttempts) {
        await sleep(100);
        attempts++;
        
        if (attempts % 10 === 0) {
            updateLoadingProgress(50 + attempts / 5, `Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¹Ø±Ø¶... (${attempts}/${maxAttempts})`);
        }
    }
    
    if (!appState.viewer.isInitialized()) {
        throw new Error('ÙØ´Ù„Øª ØªÙ‡ÙŠØ¦Ø© Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ø±Ø¶');
    }
    
    // Ø±Ø¨Ø· Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    setupViewerEvents();
}

/**
 * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
 */
async function initializeSystems(): Promise<void> {
    // Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ù†Ø¬Ø°Ø§Ø¨
    appState.systems.snapSystem = new SnapSystem();
    
    // Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª
    appState.systems.measurementSystem = new MeasurementSystem(
        document.getElementById('viewer-container')!,
        appState.viewer!.getCurrentCamera()
    );
    
    logger.info('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©');
}

/**
 * ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª
 */
async function initializeTools(): Promise<void> {
    TOOL_DEFINITIONS.forEach(toolDef => {
        if (toolDef.id !== 'select') {
            const tool = toolDef.create();
            if (tool) {
                appState.tools[toolDef.id] = tool;
                setupToolEvents(tool, toolDef);
            }
        }
    });
    
    logger.info('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Øª');
}

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
 */
async function setupUserInterface(): Promise<void> {
    setupMainToolbar();
    setupSidePanels();
    setupStatusBar();
    setupContextMenus();
    setupKeyboardShortcuts();
    setupDragAndDrop();
    
    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø³Ù…Ø©
    applyTheme(APP_CONFIG.ui.theme);
    
    logger.info('ØªÙ… Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
}

// ==================== Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ====================

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
 */
function setupMainToolbar(): void {
    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù…Ù„ÙØ§Øª
    setupFileButtons();
    
    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø¹Ø±Ø¶
    setupViewButtons();
    
    // Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø±Ø³Ù…
    setupDrawingTools();
    
    // Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­Ø±ÙŠØ±
    setupEditingTools();
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
    setupViewSettings();
}

function setupFileButtons(): void {
    const fileActions = {
        'btn-new': () => createNewProject(),
        'btn-open': () => openProject(),
        'btn-save': () => saveProject(),
        'btn-save-as': () => saveProjectAs(),
        'btn-import': () => importFile(),
        'btn-export': () => exportFile()
    };
    
    Object.entries(fileActions).forEach(([buttonId, action]) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', action);
        }
    });
}

function setupViewButtons(): void {
    const btn2D = document.getElementById('btn-2d-view');
    const btn3D = document.getElementById('btn-3d-view');
    
    if (btn2D && btn3D && appState.viewer) {
        btn2D.addEventListener('click', () => switchTo2D());
        btn3D.addEventListener('click', () => switchTo3D());
    }
    
    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªÙˆØ¬Ù‡
    const orientationButtons = {
        'btn-view-top': ViewOrientation.TOP,
        'btn-view-front': ViewOrientation.FRONT,
        'btn-view-right': ViewOrientation.RIGHT,
        'btn-view-iso': ViewOrientation.ISOMETRIC
    };
    
    Object.entries(orientationButtons).forEach(([buttonId, orientation]) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', () => {
                appState.viewer?.setViewOrientation(orientation);
            });
        }
    });
}

function setupDrawingTools(): void {
    TOOL_DEFINITIONS.forEach(toolDef => {
        const button = document.getElementById(`tool-${toolDef.id}`);
        if (button) {
            button.addEventListener('click', () => setActiveTool(toolDef.id));
            
            // Ø¥Ø¶Ø§ÙØ© tooltip
            button.title = `${toolDef.description} (${toolDef.shortcut || ''})`;
        }
    });
}

function setupEditingTools(): void {
    const editActions = {
        'btn-undo': () => {
            if (appState.commandManager.canUndo()) {
                appState.commandManager.undo();
                updateUI();
            }
        },
        'btn-redo': () => {
            if (appState.commandManager.canRedo()) {
                appState.commandManager.redo();
                updateUI();
            }
        },
        'btn-delete': () => deleteSelectedObjects(),
        'btn-copy': () => copySelectedObjects(),
        'btn-paste': () => pasteObjects(),
        'btn-duplicate': () => duplicateSelectedObjects()
    };
    
    Object.entries(editActions).forEach(([buttonId, action]) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', action);
        }
    });
}

function setupViewSettings(): void {
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø¨ÙƒØ©
    const snapCheckbox = document.getElementById('snap-to-grid') as HTMLInputElement;
    const gridSizeSelect = document.getElementById('grid-size') as HTMLSelectElement;
    
    if (snapCheckbox) {
        snapCheckbox.addEventListener('change', (e) => {
            const enabled = (e.target as HTMLInputElement).checked;
            appState.systems.snapSystem?.setGridEnabled(enabled);
            appState.ui.showGrid = enabled;
            updateViewerSettings();
        });
    }
    
    if (gridSizeSelect) {
        gridSizeSelect.addEventListener('change', (e) => {
            const size = parseFloat((e.target as HTMLSelectElement).value);
            appState.systems.snapSystem?.setGridSize(size);
            updateViewerSettings();
        });
    }
    
    // Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø¹Ø±Ø¶
    const viewModeButtons = {
        'btn-wireframe': ViewMode.WIREFRAME,
        'btn-shaded': ViewMode.SHADED,
        'btn-rendered': ViewMode.RENDERED,
        'btn-xray': ViewMode.XRAY
    };
    
    Object.entries(viewModeButtons).forEach(([buttonId, mode]) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', () => {
                if (appState.viewer && typeof (appState.viewer as any).setViewMode === 'function') {
                    (appState.viewer as any).setViewMode(mode);
                }
                appState.ui.viewMode = mode;
                updateActiveButton(button, 'view-mode-btn');
            });
        }
    });
}

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
 */
function setupSidePanels(): void {
    setupLayersPanel();
    setupPropertiesPanel();
    setupLibraryPanel();
    setupHistoryPanel();
}

function setupLayersPanel(): void {
    const layersPanel = document.getElementById('layers-panel');
    if (!layersPanel) return;
    
    // Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    const defaultLayer = new Layer();
    defaultLayer.id = 'default';
    defaultLayer.name = 'Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©';
    defaultLayer.visible = true;
    
    appState.project.layers.set('default', defaultLayer);
    updateLayersDisplay();
    
    // Ø²Ø± Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©
    const addLayerBtn = layersPanel.querySelector('.panel-btn');
    if (addLayerBtn) {
        addLayerBtn.addEventListener('click', addNewLayer);
    }
}

function setupPropertiesPanel(): void {
    const propertiesPanel = document.getElementById('properties-panel');
    if (!propertiesPanel) return;
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„ØªØ­Ø¯ÙŠØ¯
    appState.viewer?.on('selectionChanged', updatePropertiesDisplay);
}

function setupLibraryPanel(): void {
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…ÙƒØªØ¨Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙˆØ§Ù„Ø±Ù…ÙˆØ²
}

function setupHistoryPanel(): void {
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„Ø£ÙˆØ§Ù…Ø±
}

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø©
 */
function setupStatusBar(): void {
    const statusBar = document.getElementById('status-bar');
    if (!statusBar) return;
    
    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¤Ø´Ø±
    appState.viewer?.on('mouseMove', (data) => {
        updateCursorPosition(data.world);
    });
    
    // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
    updateObjectInfo();
    
    // Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
    setStatusMessage('Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¹Ù…Ù„');
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Øª ====================

/**
 * ØªÙØ¹ÙŠÙ„ Ø£Ø¯Ø§Ø© Ù…Ø¹ÙŠÙ†Ø©
 */
function setActiveTool(toolId: string): void {
    // Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
    deactivateCurrentTool();
    
    // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    updateToolButtons(toolId);
    
    // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø¯Ø§Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    appState.ui.currentTool = toolId;
    
    if (toolId !== 'select') {
        const tool = appState.tools[toolId];
        if (tool && typeof tool.activate === 'function') {
            tool.activate();
        }
    }
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ø´Ø±
    updateCursor(toolId);
    
    logger.info(`ØªÙ… ØªÙØ¹ÙŠÙ„ Ø£Ø¯Ø§Ø©: ${toolId}`);
    setStatusMessage(`Ø£Ø¯Ø§Ø© Ù†Ø´Ø·Ø©: ${getToolName(toolId)}`);
}

function deactivateCurrentTool(): void {
    const currentToolId = appState.ui.currentTool;
    if (currentToolId !== 'select') {
        const tool = appState.tools[currentToolId];
        if (tool && typeof tool.deactivate === 'function') {
            tool.deactivate();
        }
    }
}

function updateToolButtons(activeToolId: string): void {
    document.querySelectorAll('#drawing-tools .toolbar-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    const activeButton = document.getElementById(`tool-${activeToolId}`);
    if (activeButton) {
        activeButton.classList.add('active');
    }
}

function updateCursor(toolId: string): void {
    const viewerContainer = document.getElementById('viewer-container');
    const canvas = viewerContainer?.querySelector('canvas');
    if (!canvas) return;
    
    const cursors: Record<string, string> = {
        'select': 'default',
        'line': 'crosshair',
        'circle': 'crosshair',
        'move': 'move',
        'pan': 'grab',
        'zoom': 'zoom-in'
    };
    
    canvas.style.cursor = cursors[toolId] || 'default';
}

function getToolName(toolId: string): string {
    const toolDef = TOOL_DEFINITIONS.find(t => t.id === toolId);
    return toolDef?.name || toolId;
}

/**
 * Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø£Ø¯ÙˆØ§Øª
 */
function setupToolEvents(tool: any, toolDef: ToolDefinition): void {
    if (!tool || typeof tool.on !== 'function') return;
    
    tool.on('completed', (data: any) => {
        logger.info(`ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© ${toolDef.name}`);
        setStatusMessage(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ${data.objectId || 'ÙƒØ§Ø¦Ù† Ø¬Ø¯ÙŠØ¯'}`);
        
        if (data.objects) {
            data.objects.forEach((obj: GeometricObject) => {
                appState.project.activeObjects.set(obj.id, obj);
            });
        }
        
        markProjectAsDirty();
        updateObjectInfo();
    });
    
    tool.on('cancelled', () => {
        setStatusMessage('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©');
    });
    
    tool.on('error', (error: any) => {
        logger.error(`Ø®Ø·Ø£ ÙÙŠ Ø£Ø¯Ø§Ø© ${toolDef.name}:`, error);
        showErrorMessage(`Ø®Ø·Ø£ ÙÙŠ ${toolDef.name}: ${error.message}`);
    });
    
    tool.on('statusUpdate', (info: any) => {
        updateToolStatus(info);
    });
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ====================

async function createNewProject(): Promise<void> {
    if (appState.project.isDirty) {
        const shouldSave = await confirmSaveChanges();
        if (shouldSave === null) return; // Ø£Ù„ØºÙ‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        if (shouldSave) await saveProject();
    }
    
    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
    appState.project.activeObjects.clear();
    appState.project.layers.clear();
    appState.project.projectPath = null;
    appState.project.isDirty = false;
    appState.project.lastSaved = null;
    
    // Ø¥Ø¶Ø§ÙØ© Ø·Ø¨Ù‚Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    const defaultLayer = new Layer();
    defaultLayer.id = 'default';
    defaultLayer.name = 'Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©';
    appState.project.layers.set('default', defaultLayer);
    
    // Ù…Ø³Ø­ Ø§Ù„Ù…Ø´Ù‡Ø¯
    if (appState.viewer) {
        // Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø´Ù‡Ø¯
        appState.project.activeObjects.forEach((object) => {
            // Use a public method to remove objects from the viewer
            // This assumes there's a public removeObject method or similar
            (appState.viewer as any).removeObject?.(object.id);
        });
    }
    
    // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù…Ø¯ÙŠØ± Ø§Ù„Ø£ÙˆØ§Ù…Ø±
    appState.commandManager.clear();
    
    updateUI();
    setStatusMessage('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯');
    showSuccessMessage('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­');
}

async function openProject(): Promise<void> {
    try {
        if (appState.project.isDirty) {
            const shouldSave = await confirmSaveChanges();
            if (shouldSave === null) return;
            if (shouldSave) await saveProject();
        }
        
        const projectData = await appState.projectManager.openProject();
        if (projectData) {
            await loadProjectData(projectData);
            setStatusMessage('ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­');
            showSuccessMessage('ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­');
        }
    } catch (error) {
        logger.error('ÙØ´Ù„ ÙØªØ­ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:', error);
        showErrorMessage('ÙØ´Ù„ ÙØªØ­ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
    }
}

async function saveProject(): Promise<void> {
    try {
        // Extract walls and elements from the active objects
        const walls: Wall[] = [];
        const elements: BuildingElement[] = [];

        appState.project.activeObjects.forEach(obj => {
            if (obj instanceof Wall) {
                walls.push(obj);
            } else {
                elements.push(obj as BuildingElement);
            }
        });

        // Save the project with the correct parameters
        const savedData = ProjectManager.saveProject(
            walls,
            elements,
            appState.project.projectPath || 'Untitled Project'
        );

        // Store the saved data (you might want to save this to a file or localStorage)
        localStorage.setItem('tyrexwebcad-project', savedData);

        appState.project.isDirty = false;
        appState.project.lastSaved = new Date();

        updateUI();
        setStatusMessage('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
        showSuccessMessage('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error) {
        logger.error('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:', error);
        showErrorMessage('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
    }
}

async function saveProjectAs(): Promise<void> {
    try {
        const projectData = serializeProject();
        await appState.projectManager.saveProjectAs(projectData);
        
        appState.project.isDirty = false;
        appState.project.lastSaved = new Date();
        
        updateUI();
        setStatusMessage('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø³Ù… Ø¬Ø¯ÙŠØ¯');
        showSuccessMessage('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­');
        
    } catch (error) {
        logger.error('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹:', error);
        showErrorMessage('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹');
    }
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ====================

function deleteSelectedObjects(): void {
    const selectedObjects = Array.from(appState.ui.selectedObjects);
    if (selectedObjects.length === 0) {
        showWarningMessage('Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙƒØ§Ø¦Ù†Ø§Øª Ù„Ù„Ø­Ø°Ù');
        return;
    }
    
    if (confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù ${selectedObjects.length} ÙƒØ§Ø¦Ù†ØŸ`)) {
        selectedObjects.forEach(objectId => {
            const object = appState.project.activeObjects.get(objectId);
            if (object) {
                // Ø§Ø³ØªØ®Ø¯Ù… ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø§Ù…Ø© Ù„Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ÙƒØ§Ø¦Ù† Ù…Ù† Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯ Ù…Ø¹ ØªØ¬Ø§ÙˆØ² Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† TypeScript
                (appState.viewer as any)?.removeGeometricObject?.(objectId);
                appState.project.activeObjects.delete(objectId);
            }
        });
        
        appState.ui.selectedObjects.clear();
        markProjectAsDirty();
        updateUI();
        
        setStatusMessage(`ØªÙ… Ø­Ø°Ù ${selectedObjects.length} ÙƒØ§Ø¦Ù†`);
    }
}

function copySelectedObjects(): void {
    const selectedObjects = Array.from(appState.ui.selectedObjects);
    if (selectedObjects.length === 0) {
        showWarningMessage('Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙƒØ§Ø¦Ù†Ø§Øª Ù„Ù„Ù†Ø³Ø®');
        return;
    }
    
    // ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù†Ø³Ø®
    setStatusMessage(`ØªÙ… Ù†Ø³Ø® ${selectedObjects.length} ÙƒØ§Ø¦Ù†`);
}

function pasteObjects(): void {
    // ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù„ØµÙ‚
    setStatusMessage('ØªÙ… Ù„ØµÙ‚ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª');
}

function duplicateSelectedObjects(): void {
    const selectedObjects = Array.from(appState.ui.selectedObjects);
    if (selectedObjects.length === 0) {
        showWarningMessage('Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ ÙƒØ§Ø¦Ù†Ø§Øª Ù„Ù„ØªÙƒØ±Ø§Ø±');
        return;
    }
    
    // ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙƒØ±Ø§Ø±
    setStatusMessage(`ØªÙ… ØªÙƒØ±Ø§Ø± ${selectedObjects.length} ÙƒØ§Ø¦Ù†`);
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ø±Ø¶ ====================

function switchTo2D(): void {
    appState.viewer?.setView(true);
    updateViewButtons('2d');
    setStatusMessage('ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¶ Ø«Ù†Ø§Ø¦ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯');
}

function switchTo3D(): void {
    appState.viewer?.setView(false);
    updateViewButtons('3d');
    setStatusMessage('ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ø±Ø¶ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯');
}

function updateViewButtons(activeView: '2d' | '3d'): void {
    const btn2D = document.getElementById('btn-2d-view');
    const btn3D = document.getElementById('btn-3d-view');
    
    if (btn2D && btn3D) {
        btn2D.classList.toggle('active', activeView === '2d');
        btn3D.classList.toggle('active', activeView === '3d');
    }
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ====================

function setupKeyboardShortcuts(): void {
    document.addEventListener('keydown', (e) => {
        if ((e.target as HTMLElement).tagName === 'INPUT') return;
        
        const shortcuts = {
            'KeyS': () => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    saveProject();
                } else {
                    setActiveTool('select');
                }
            },
            'KeyO': () => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    openProject();
                }
            },
            'KeyN': () => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    createNewProject();
                }
            },
            'KeyZ': () => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    if (e.shiftKey) {
                        if (appState.commandManager.canRedo()) {
                            appState.commandManager.redo();
                        }
                    } else {
                        if (appState.commandManager.canUndo()) {
                            appState.commandManager.undo();
                        }
                    }
                    updateUI();
                }
            },
            'KeyL': () => setActiveTool('line'),
            'KeyC': () => setActiveTool('circle'),
            'KeyM': () => setActiveTool('move'),
            'Delete': () => deleteSelectedObjects(),
            'Escape': () => {
                deactivateCurrentTool();
                setActiveTool('select');
            }
        };
        
        const handler = shortcuts[e.code as keyof typeof shortcuts];
        if (handler) {
            handler();
        }
    });
}

function setupViewerEvents(): void {
    if (!appState.viewer) return;
    
    appState.viewer.on('objectAdded', (object) => {
        logger.debug('ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù†:', object);
        appState.project.activeObjects.set(object.id, object);
        markProjectAsDirty();
        updateObjectInfo();
    });
    
    appState.viewer.on('objectRemoved', (object) => {
        logger.debug('ØªÙ…Øª Ø¥Ø²Ø§Ù„Ø© ÙƒØ§Ø¦Ù†:', object);
        appState.project.activeObjects.delete(object.id);
        appState.ui.selectedObjects.delete(object.id);
        markProjectAsDirty();
        updateObjectInfo();
    });
    
    appState.viewer.on('selectionChanged', (selection) => {
        appState.ui.selectedObjects = new Set(selection.map((obj: any) => obj.id));
        updatePropertiesDisplay();
        updateUI();
    });
    
    appState.viewer.on('viewChanged', (is2D) => {
        updateViewButtons(is2D ? '2d' : '3d');
    });
}

function setupDragAndDrop(): void {
    const viewerContainer = document.getElementById('viewer-container');
    if (!viewerContainer) return;
    
    viewerContainer.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer!.dropEffect = 'copy';
    });
    
    viewerContainer.addEventListener('drop', async (e) => {
        e.preventDefault();
        const files = Array.from(e.dataTransfer!.files);
        
        for (const file of files) {
            try {
                await importFile(file);
            } catch (error) {
                logger.error('ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„Ù:', error);
                showErrorMessage(`ÙØ´Ù„ Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${file.name}`);
            }
        }
    });
}

// ==================== ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ====================

function updateUI(): void {
    updateToolButtons(appState.ui.currentTool);
    updateUndoRedoButtons();
    updateObjectInfo();
    updateLayersDisplay();
    updatePropertiesDisplay();
    updateTitle();
}

function updateUndoRedoButtons(): void {
    const btnUndo = document.getElementById('btn-undo');
    const btnRedo = document.getElementById('btn-redo');
    
    if (btnUndo) {
        btnUndo.classList.toggle('disabled', !appState.commandManager.canUndo());
    }
    
    if (btnRedo) {
        btnRedo.classList.toggle('disabled', !appState.commandManager.canRedo());
    }
}

function updateObjectInfo(): void {
    const objectCount = appState.project.activeObjects.size;
    const selectedCount = appState.ui.selectedObjects.size;
    
    const objectInfo = document.getElementById('object-info');
    if (objectInfo) {
        objectInfo.textContent = `ÙƒØ§Ø¦Ù†Ø§Øª: ${objectCount} | Ù…Ø­Ø¯Ø¯: ${selectedCount}`;
    }
}

function updateCursorPosition(position: { x: number; y: number; z: number }): void {
    const cursorPosition = document.getElementById('cursor-position');
    if (cursorPosition) {
        cursorPosition.textContent = 
            `X: ${position.x.toFixed(2)}, Y: ${position.y.toFixed(2)}, Z: ${position.z.toFixed(2)}`;
    }
}

function setStatusMessage(message: string): void {
    const statusMessage = document.getElementById('status-message');
    if (statusMessage) {
        statusMessage.textContent = message;
    }
}

function updateTitle(): void {
    const projectName = appState.project.projectPath 
        ? appState.project.projectPath.split('/').pop()?.replace('.json', '') || 'Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯'
        : 'Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯';
    
    const isDirtyIndicator = appState.project.isDirty ? ' *' : '';
    document.title = `${projectName}${isDirtyIndicator} - TyrexWebCad ${APP_CONFIG.version}`;
}

function updateLayersDisplay(): void {
    const layersList = document.getElementById('layers-list');
    if (!layersList) return;
    
    layersList.innerHTML = '';
    
    appState.project.layers.forEach(layer => {
        const layerElement = createLayerElement(layer);
        layersList.appendChild(layerElement);
    });
}

function updatePropertiesDisplay(): void {
    const propertiesContent = document.getElementById('properties-content');
    if (!propertiesContent) return;
    
    if (appState.ui.selectedObjects.size === 0) {
        propertiesContent.innerHTML = '<p class="panel-message">Ø­Ø¯Ø¯ ÙƒØ§Ø¦Ù†Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ø®ØµØ§Ø¦ØµÙ‡</p>';
        return;
    }
    
    if (appState.ui.selectedObjects.size === 1) {
        const objectId = Array.from(appState.ui.selectedObjects)[0];
        const object = appState.project.activeObjects.get(objectId);
        if (object) {
            propertiesContent.innerHTML = createObjectPropertiesHTML(object);
        }
    } else {
        propertiesContent.innerHTML = `<p class="panel-message">Ù…Ø­Ø¯Ø¯ ${appState.ui.selectedObjects.size} ÙƒØ§Ø¦Ù†Ø§Øª</p>`;
    }
}

// ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ====================

function createLayerElement(layer: Layer): HTMLElement {
    const layerDiv = document.createElement('div');
    layerDiv.className = 'layer-item';
    layerDiv.innerHTML = `
        <div class="layer-visibility">
            <input type="checkbox" ${layer.visible ? 'checked' : ''} 
                   onchange="toggleLayerVisibility('${layer.id}')">
        </div>
        <div class="layer-name" onclick="selectLayer('${layer.id}')">${layer.name}</div>
        <div class="layer-actions">
            <button onclick="editLayer('${layer.id}')" title="ØªØ­Ø±ÙŠØ±">âœï¸</button>
            <button onclick="deleteLayer('${layer.id}')" title="Ø­Ø°Ù">ğŸ—‘ï¸</button>
        </div>
    `;
    
    return layerDiv;
}

function createObjectPropertiesHTML(object: GeometricObject): string {
    const props = object.visualProperties;
    const metadata = object.metadata;
    
    return `
        <div class="property-group">
            <h4>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ø§Ù…Ø©</h4>
            <div class="property-item">
                <label>Ø§Ù„Ù†ÙˆØ¹:</label>
                <span>${object.type}</span>
            </div>
            <div class="property-item">
                <label>Ø§Ù„Ù…Ø¹Ø±Ù:</label>
                <span>${object.id}</span>
            </div>
            <div class="property-item">
                <label>Ø§Ù„Ø·Ø¨Ù‚Ø©:</label>
                <span>${object.layerId}</span>
            </div>
        </div>
        
        <div class="property-group">
            <h4>Ø®ØµØ§Ø¦Øµ Ù…Ø±Ø¦ÙŠØ©</h4>
            <div class="property-item">
                <label>Ø§Ù„Ù„ÙˆÙ†:</label>
                <input type="color" value="${props.color}" 
                       onchange="updateObjectColor('${object.id}', this.value)">
            </div>
            <div class="property-item">
                <label>Ø§Ù„Ø´ÙØ§ÙÙŠØ©:</label>
                <input type="range" min="0" max="1" step="0.1" value="${props.opacity}"
                       onchange="updateObjectOpacity('${object.id}', this.value)">
            </div>
        </div>
        
        <div class="property-group">
            <h4>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®</h4>
            <div class="property-item">
                <label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡:</label>
                <span>${metadata.createdAt.toLocaleString('ar')}</span>
            </div>
            <div class="property-item">
                <label>Ø¢Ø®Ø± ØªØ¹Ø¯ÙŠÙ„:</label>
                <span>${metadata.modifiedAt.toLocaleString('ar')}</span>
            </div>
        </div>
    `;
}

// ==================== Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ====================

function showSuccessMessage(message: string): void {
    showToast(message, 'success');
}

function showErrorMessage(message: string): void {
    showToast(message, 'error');
}

function showWarningMessage(message: string): void {
    showToast(message, 'warning');
}

function showInfoMessage(message: string): void {
    showToast(message, 'info');
}

function showToast(message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info'): void {
    const container = document.getElementById('toast-container');
    if (!container) return;
    
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    
    const icon = {
        'info': 'â„¹ï¸',
        'success': 'âœ…',
        'warning': 'âš ï¸',
        'error': 'âŒ'
    }[type];
    
    toast.innerHTML = `
        <div class="toast-icon">${icon}</div>
        <div class="toast-message">${message}</div>
        <button class="toast-close" onclick="this.parentElement.remove()">Ã—</button>
    `;
    
    container.appendChild(toast);
    
    // Ø¥Ø²Ø§Ù„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¨Ø¹Ø¯ 5 Ø«ÙˆØ§Ù†ÙŠ
    setTimeout(() => {
        if (toast.parentElement) {
            toast.classList.add('toast-fade-out');
            setTimeout(() => toast.remove(), 300);
        }
    }, 5000);
}

function showWelcomeMessage(): void {
    showToast(`ğŸ‰ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ TyrexWebCad ${APP_CONFIG.version}`, 'success');
}

// ==================== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ====================

function handleInitializationError(error: any): void {
    logger.error('ÙØ´Ù„Øª ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:', error);
    appState.status.lastError = error;
    appState.status.isLoading = false;
    
    updateLoadingProgress(0, 'ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„');
    
    const errorMessage = error instanceof Error ? error.message : 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
    
    setTimeout(() => {
        hideLoadingScreen();
        showErrorDialog('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©', 
            `ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚: ${errorMessage}\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ØŸ`);
    }, 1000);
}

function showErrorDialog(title: string, message: string): void {
    if (confirm(`${title}\n\n${message}`)) {
        window.location.reload();
    }
}

// ==================== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ====================

function updateLoadingProgress(percent: number, text: string): void {
    appState.status.loadingProgress = percent;
    
    const loadingProgress = document.getElementById('loading-progress');
    const loadingText = document.getElementById('loading-text');
    
    if (loadingProgress) loadingProgress.style.width = `${percent}%`;
    if (loadingText) loadingText.textContent = text;
}

function showWelcomeScreen(): void {
    // Ø¹Ø±Ø¶ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø³Ø®Ø©
    const welcomeInfo = document.querySelector('.loading-subtitle');
    if (welcomeInfo) {
        welcomeInfo.textContent = `Ø§Ù„Ø¥ØµØ¯Ø§Ø± ${APP_CONFIG.version} - Ù†Ø¸Ø§Ù… ØªØµÙ…ÙŠÙ… Ù…ØªÙ‚Ø¯Ù…`;
    }
}

function hideLoadingScreen(): void {
    const loadingScreen = document.getElementById('loading-screen');
    const appContainer = document.getElementById('app');
    
    if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
            loadingScreen.style.display = 'none';
        }, 300);
    }
    
    if (appContainer) {
        appContainer.style.display = 'flex';
        setTimeout(() => {
            appContainer.style.opacity = '1';
        }, 50);
    }
}

function showMainInterface(): void {
    // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ù…Ø¹ ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù†ØªÙ‚Ø§Ù„ÙŠØ©
    const elements = [
        document.getElementById('toolbar'),
        document.getElementById('side-panels'),
        document.getElementById('status-bar')
    ];
    
    elements.forEach((element, index) => {
        if (element) {
            setTimeout(() => {
                element.style.opacity = '1';
                element.style.transform = 'translateY(0)';
            }, index * 100);
        }
    });
}

function sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function markProjectAsDirty(): void {
    appState.project.isDirty = true;
    updateTitle();
}

function updateActiveButton(activeButton: HTMLElement, groupClass: string): void {
    document.querySelectorAll(`.${groupClass}`).forEach(btn => {
        btn.classList.remove('active');
    });
    activeButton.classList.add('active');
}

function applyTheme(theme: string): void {
    document.documentElement.setAttribute('data-theme', theme);
}

function updateViewerSettings(): void {
    if (!appState.viewer) return;
    
    appState.viewer.updateViewSettings({
        showGrid: appState.ui.showGrid,
        showAxes: appState.ui.showAxes
    } as Partial<ViewSettings>);
}

async function confirmSaveChanges(): Promise<boolean | null> {
    return new Promise((resolve) => {
        const result = confirm('Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØªØºÙŠÙŠØ±Ø§Øª ØºÙŠØ± Ù…Ø­ÙÙˆØ¸Ø©. Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­ÙØ¸Ù‡Ø§ØŸ');
        resolve(result);
    });
}

// Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø·Ø¨Ù‚Ø§Øª ÙˆØ§Ù„Ù…Ø´Ø±ÙˆØ¹
async function loadDefaultProject(): Promise<void> {
    // ØªØ­Ù…ÙŠÙ„ Ù…Ø´Ø±ÙˆØ¹ Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø£Ùˆ ÙØ§Ø±Øº
    logger.info('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ');
}

function serializeProject(): string {
    const projectData = {
        version: APP_CONFIG.version,
        objects: Array.from(appState.project.activeObjects.values()).map(obj => obj.toJSON()),
        layers: Array.from(appState.project.layers.values()).map(layer => ({
            id: layer.id,
            name: layer.name,
            visible: layer.visible
        })),
        settings: appState.ui,
        timestamp: new Date().toISOString()
    };
    
    return JSON.stringify(projectData, null, 2);
}

async function loadProjectData(data: string): Promise<void> {
    const projectData = JSON.parse(data);
    
    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø·Ø¨Ù‚Ø§Øª
    projectData.layers?.forEach((layerData: any) => {
        const layer = new Layer();
        layer.id = layerData.id;
        layer.name = layerData.name;
        layer.visible = layerData.visible;
        appState.project.layers.set(layer.id, layer);
    });
    
    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
    // TODO: ØªÙ†ÙÙŠØ° ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
    
    appState.project.isDirty = false;
    updateUI();
}

// Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯ ÙˆØ§Ù„ØªØµØ¯ÙŠØ±
async function importFile(_file?: File): Promise<void> {
    // ØªÙ†ÙÙŠØ° Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª
    logger.info('Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù');
}

async function exportFile(): Promise<void> {
    // ØªÙ†ÙÙŠØ° ØªØµØ¯ÙŠØ± Ø§Ù„Ù…Ù„ÙØ§Øª
    logger.info('ØªØµØ¯ÙŠØ± Ù…Ù„Ù');
}

// Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø·Ø¨Ù‚Ø§Øª
function addNewLayer(): void {
    const layerName = prompt('Ø§Ø³Ù… Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:') || `Ø·Ø¨Ù‚Ø© ${appState.project.layers.size + 1}`;
    
    const layer = new Layer();
    layer.id = `layer_${Date.now()}`;
    layer.name = layerName;
    layer.visible = true;
    
    appState.project.layers.set(layer.id, layer);
    updateLayersDisplay();
    markProjectAsDirty();
}

// ==================== Ø¯ÙˆØ§Ù„ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© (Ø¥ØªØ§Ø­ØªÙ‡Ø§ Ù„Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¹Ø§Ù…) ====================

// Ø¯ÙˆØ§Ù„ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ø¨Ù‚Ø§Øª
function editLayer(layerId: string): void {
    const layer = appState.project.layers.get(layerId);
    if (layer) {
        const newName = prompt('Ø§Ø³Ù… Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯:', layer.name);
        if (newName && newName !== layer.name) {
            layer.name = newName;
            updateLayersDisplay();
            markProjectAsDirty();
        }
    }
}

function deleteLayer(layerId: string): void {
    if (layerId === 'default') {
        showWarningMessage('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©');
        return;
    }
    
    const layer = appState.project.layers.get(layerId);
    if (layer && confirm(`Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ø§Ù„Ø·Ø¨Ù‚Ø© "${layer.name}"ØŸ`)) {
        appState.project.layers.delete(layerId);
        
        // Ù†Ù‚Ù„ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø¥Ù„Ù‰ Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
        appState.project.activeObjects.forEach(obj => {
            if (obj.layerId === layerId) {
                obj.layerId = 'default';
            }
        });
        
        updateLayersDisplay();
        markProjectAsDirty();
    }
}

function toggleLayerVisibility(layerId: string): void {
    const layer = appState.project.layers.get(layerId);
    if (layer) {
        layer.visible = !layer.visible;
        markProjectAsDirty();
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø·Ø¨Ù‚Ø©
        updateLayerObjectsVisibility(layerId, layer.visible);
    }
}

function selectLayer(layerId: string): void {
    appState.ui.activeLayer = layerId;
    updateLayersDisplay();
}

function updateLayerObjectsVisibility(layerId: string, visible: boolean): void {
    appState.project.activeObjects.forEach(obj => {
        if (obj.layerId === layerId) {
            // ØªØ­Ø¯ÙŠØ« Ø±Ø¤ÙŠØ© Ø§Ù„ÙƒØ§Ø¦Ù† ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯
            if (appState.viewer) {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© Ø¹Ø§Ù…Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø±Ø¤ÙŠØ© Ø§Ù„ÙƒØ§Ø¦Ù†
                (appState.viewer as any).setObjectVisibility?.(obj.id, visible);
            }
        }
    });
}

// Ø¯ÙˆØ§Ù„ ØªØ­Ø¯ÙŠØ« Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª
function updateObjectColor(objectId: string, color: string): void {
    const object = appState.project.activeObjects.get(objectId);
    if (object) {
        object.visualProperties = { ...object.visualProperties, color };
        markProjectAsDirty();
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„ÙˆÙ† ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯
        if (appState.viewer) {
            (appState.viewer as any).updateObjectColor?.(objectId, color);
        }
    }
}

function updateObjectOpacity(objectId: string, opacity: string): void {
    const object = appState.project.activeObjects.get(objectId);
    if (object) {
        object.visualProperties = { ...object.visualProperties, opacity: parseFloat(opacity) };
        markProjectAsDirty();
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´ÙØ§ÙÙŠØ© ÙÙŠ Ø§Ù„Ù…Ø´Ù‡Ø¯
        if (appState.viewer) {
            (appState.viewer as any).updateObjectOpacity?.(objectId, parseFloat(opacity));
        }
    }
}

// Ø¥ØªØ§Ø­Ø© Ø§Ù„Ø¯ÙˆØ§Ù„ Ù„Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¹Ø§Ù…
(window as any).editLayer = editLayer;
(window as any).deleteLayer = deleteLayer;
(window as any).toggleLayerVisibility = toggleLayerVisibility;
(window as any).selectLayer = selectLayer;
(window as any).updateObjectColor = updateObjectColor;
(window as any).updateObjectOpacity = updateObjectOpacity;

// Ø¯ÙˆØ§Ù„ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
function startPerformanceMonitoring(): void {
    setInterval(() => {
        if (appState.viewer) {
            const stats = appState.viewer.getPerformanceStats();
            
            // ØªØ­Ø°ÙŠØ±Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
            if (stats.fps < 30) {
                logger.warn(`Ø§Ù†Ø®ÙØ§Ø¶ Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª: ${stats.fps.toFixed(1)} FPS`);
            }
            
            if (stats.objectCount > APP_CONFIG.performance.maxObjects * 0.8) {
                logger.warn(`Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª: ${stats.objectCount}`);
            }
        }
    }, 5000);
}

async function loadUserPreferences(): Promise<void> {
    try {
        const prefs = localStorage.getItem('tyrexwebcad-preferences');
        if (prefs) {
            const preferences = JSON.parse(prefs);
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª
            if (preferences.ui) {
                Object.assign(APP_CONFIG.ui, preferences.ui);
            }
            
            if (preferences.performance) {
                Object.assign(APP_CONFIG.performance, preferences.performance);
            }
            
            logger.info('ØªÙ… ØªØ­Ù…ÙŠÙ„ ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
        }
    } catch (error) {
        logger.warn('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:', error);
    }
}

function updateToolStatus(info: any): void {
    // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø¯Ø§Ø© ÙÙŠ Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø©
    setStatusMessage(`${info.toolName}: ${info.pointCount}/${info.requiredPoints} Ù†Ù‚Ø§Ø·`);
}

function setupContextMenus(): void {
    // Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ø³ÙŠØ§Ù‚ Ù„Ù„Ù†Ù‚Ø± Ø¨Ø§Ù„Ø²Ø± Ø§Ù„Ø£ÙŠÙ…Ù†
    document.addEventListener('contextmenu', (e) => {
        // Ù…Ù†Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ø±Ø¶
        if ((e.target as HTMLElement).closest('#viewer-container')) {
            e.preventDefault();
            // TODO: Ø¥Ø¸Ù‡Ø§Ø± Ù‚Ø§Ø¦Ù…Ø© Ø³ÙŠØ§Ù‚ Ù…Ø®ØµØµØ©
        }
    });
}

// ==================== Ø¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ====================

/**
 * Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
 */
function startApplication(): void {
    logger.setLevel(LogLevel.INFO);
    logger.info(`ğŸš€ Ø¨Ø¯Ø¡ ØªØ·Ø¨ÙŠÙ‚ TyrexWebCad ${APP_CONFIG.version}`);
    
    // Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©
    logger.info(`Ø§Ù„Ø¨ÙŠØ¦Ø©: ${APP_CONFIG.environment}`);
    logger.info(`Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ù…ÙØ¹Ù„Ø©: ${Object.entries(APP_CONFIG.features).filter(([,v]) => v).map(([k]) => k).join(', ')}`);
    
    initializeApplication();
}

// Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„ØµÙØ­Ø© ÙˆØ¨Ø¯Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startApplication);
} else {
    startApplication();
}

// Ø­ÙØ¸ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
window.addEventListener('beforeunload', (e) => {
    if (appState.project.isDirty) {
        e.preventDefault();
        e.returnValue = 'Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØªØºÙŠÙŠØ±Ø§Øª ØºÙŠØ± Ù…Ø­ÙÙˆØ¸Ø©. Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ';
    }
    
    // Ø­ÙØ¸ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª
    try {
        const preferences = {
            ui: APP_CONFIG.ui,
            performance: APP_CONFIG.performance,
            timestamp: new Date().toISOString()
        };
        localStorage.setItem('tyrexwebcad-preferences', JSON.stringify(preferences));
    } catch (error) {
        logger.warn('ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª:', error);
    }
});

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù…Ø©
window.addEventListener('error', (event) => {
    logger.error('Ø®Ø·Ø£ Ø¹Ø§Ù…:', event.error);
    appState.status.lastError = event.error;
});

window.addEventListener('unhandledrejection', (event) => {
    logger.error('ÙˆØ¹Ø¯ Ù…Ø±ÙÙˆØ¶:', event.reason);
    appState.status.lastError = event.reason;
});

// ØªØµØ¯ÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ù„ØªØ·ÙˆÙŠØ± ÙˆØ§Ù„ØªØ´Ø®ÙŠØµ
(window as any).TyrexWebCad = {
    version: APP_CONFIG.version,
    appState,
    logger,
    config: APP_CONFIG
};

==== FILE: src\models\Arc.ts ====

/**
 * Arc - Arc entity class
 * Represents an arc in 2D/3D space
 */

import { GeometricObject, GeometricObjectType, Point3D } from './GeometricObject';
import { OCShapeHandle } from '../core/GeometryEngine';

/**
 * Arc class - represents an arc
 */
export class Arc extends GeometricObject {
    // Center point
    private _center: Point3D;
    
    // Radius
    private _radius: number;
    
    // Start angle (radians)
    private _startAngle: number;
    
    // End angle (radians)
    private _endAngle: number;
    
    // Normal vector (for 3D orientation)
    private _normal: Point3D;

    /**
     * Constructor - creates an arc
     */
    constructor(
        center: Point3D, 
        radius: number, 
        startAngle: number, 
        endAngle: number,
        normal: Point3D = { x: 0, y: 0, z: 1 }
    ) {
        super(GeometricObjectType.ARC);
        
        this._center = { ...center };
        this._radius = radius;
        this._startAngle = this.normalizeAngle(startAngle);
        this._endAngle = this.normalizeAngle(endAngle);
        this._normal = { ...normal };
        
        this.logger.info(`Created arc at (${center.x}, ${center.y}, ${center.z}) with radius ${radius}`);
    }

    /**
     * Create geometric shape in OpenCASCADE
     */
    protected createOCShape(): OCShapeHandle {
        try {
            // For now, create as a full circle - actual arc creation would need 
            // proper OpenCASCADE arc API
            const circleHandle = this.geometryEngine.createCircle(
                this._center,
                this._normal,
                this._radius
            );
            
            // TODO: Trim circle to arc using start/end angles
            
            this.logger.debug(`Created arc in OpenCASCADE - Handle: ${circleHandle}`);
            return circleHandle;
            
        } catch (error) {
            this.logger.error(`Failed to create arc in OpenCASCADE`, error);
            throw error;
        }
    }

    /**
     * Update geometric shape when properties change
     */
    protected updateOCShape(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
        
        this.logger.debug(`Updated arc ${this._id}`);
    }

    /**
     * Calculate bounding box
     */
    public getBounds(): { min: Point3D; max: Point3D } {
        // Calculate bounds considering all possible arc positions
        const points: Point3D[] = [];
        
        // Add start and end points
        points.push(this.getStartPoint());
        points.push(this.getEndPoint());
        
        // Check if arc crosses any axis
        const angles = [0, Math.PI/2, Math.PI, 3*Math.PI/2];
        angles.forEach(angle => {
            if (this.containsAngle(angle)) {
                points.push({
                    x: this._center.x + this._radius * Math.cos(angle),
                    y: this._center.y + this._radius * Math.sin(angle),
                    z: this._center.z
                });
            }
        });
        
        // Find min and max from all points
        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);
        const zs = points.map(p => p.z);
        
        return {
            min: {
                x: Math.min(...xs),
                y: Math.min(...ys),
                z: Math.min(...zs)
            },
            max: {
                x: Math.max(...xs),
                y: Math.max(...ys),
                z: Math.max(...zs)
            }
        };
    }

    /**
     * Clone the arc
     */
    public clone(): Arc {
        const cloned = new Arc(
            this._center, 
            this._radius, 
            this._startAngle, 
            this._endAngle, 
            this._normal
        );
        
        // Copy properties from original
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned._transform = {
            translation: { ...this._transform.translation },
            rotation: { ...this._transform.rotation },
            scale: { ...this._transform.scale }
        };
        
        return cloned;
    }

    /**
     * Get start point
     */
    public getStartPoint(): Point3D {
        return {
            x: this._center.x + this._radius * Math.cos(this._startAngle),
            y: this._center.y + this._radius * Math.sin(this._startAngle),
            z: this._center.z
        };
    }

    /**
     * Get end point
     */
    public getEndPoint(): Point3D {
        return {
            x: this._center.x + this._radius * Math.cos(this._endAngle),
            y: this._center.y + this._radius * Math.sin(this._endAngle),
            z: this._center.z
        };
    }

    /**
     * Get mid point
     */
    public getMidPoint(): Point3D {
        const midAngle = this._startAngle + this.getSweepAngle() / 2;
        return {
            x: this._center.x + this._radius * Math.cos(midAngle),
            y: this._center.y + this._radius * Math.sin(midAngle),
            z: this._center.z
        };
    }

    /**
     * Get sweep angle
     */
    public getSweepAngle(): number {
        let sweep = this._endAngle - this._startAngle;
        if (sweep < 0) sweep += 2 * Math.PI;
        return sweep;
    }

    /**
     * Get arc length
     */
    public getArcLength(): number {
        return this._radius * this.getSweepAngle();
    }

    /**
     * Get chord length
     */
    public getChordLength(): number {
        const start = this.getStartPoint();
        const end = this.getEndPoint();
        return Math.sqrt(
            Math.pow(end.x - start.x, 2) +
            Math.pow(end.y - start.y, 2) +
            Math.pow(end.z - start.z, 2)
        );
    }

    /**
     * Get point on arc at parameter t (0 to 1)
     */
    public getPointAtParameter(t: number): Point3D {
        const angle = this._startAngle + t * this.getSweepAngle();
        return {
            x: this._center.x + this._radius * Math.cos(angle),
            y: this._center.y + this._radius * Math.sin(angle),
            z: this._center.z
        };
    }

    /**
     * Check if angle is contained in arc
     */
    public containsAngle(angle: number): boolean {
        angle = this.normalizeAngle(angle);
        const start = this._startAngle;
        const end = this._endAngle;
        
        if (start <= end) {
            return angle >= start && angle <= end;
        } else {
            return angle >= start || angle <= end;
        }
    }

    /**
     * Normalize angle to [0, 2Ï€)
     */
    private normalizeAngle(angle: number): number {
        angle = angle % (2 * Math.PI);
        if (angle < 0) angle += 2 * Math.PI;
        return angle;
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        const baseJSON = super.toJSON();
        
        return {
            ...baseJSON,
            center: { ...this._center },
            radius: this._radius,
            startAngle: this._startAngle,
            endAngle: this._endAngle,
            normal: { ...this._normal },
            sweepAngle: this.getSweepAngle(),
            arcLength: this.getArcLength(),
            chordLength: this.getChordLength()
        };
    }

    /**
     * Restore from JSON
     */
    public fromJSON(data: any): void {
        super.fromJSON(data);
        
        if (data.center) {
            this._center = { ...data.center };
        }
        
        if (data.radius !== undefined) {
            this._radius = data.radius;
        }
        
        if (data.startAngle !== undefined) {
            this._startAngle = data.startAngle;
        }
        
        if (data.endAngle !== undefined) {
            this._endAngle = data.endAngle;
        }
        
        if (data.normal) {
            this._normal = { ...data.normal };
        }
        
        this._ocHandle = null;
    }

    /**
     * Create arc from JSON
     */
    public static fromJSON(data: any): Arc {
        const arc = new Arc(
            data.center || { x: 0, y: 0, z: 0 },
            data.radius || 1,
            data.startAngle || 0,
            data.endAngle || Math.PI,
            data.normal || { x: 0, y: 0, z: 1 }
        );
        
        arc.fromJSON(data);
        return arc;
    }

    // Getters and Setters
    
    public get center(): Point3D { 
        return { ...this._center }; 
    }
    
    public set center(value: Point3D) {
        this._center = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get radius(): number { 
        return this._radius; 
    }
    
    public set radius(value: number) {
        if (value <= 0) {
            throw new Error('Radius must be positive');
        }
        this._radius = value;
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get startAngle(): number { 
        return this._startAngle; 
    }
    
    public set startAngle(value: number) {
        this._startAngle = this.normalizeAngle(value);
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get endAngle(): number { 
        return this._endAngle; 
    }
    
    public set endAngle(value: number) {
        this._endAngle = this.normalizeAngle(value);
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get normal(): Point3D { 
        return { ...this._normal }; 
    }
    
    public set normal(value: Point3D) {
        this._normal = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
}

==== FILE: src\models\Block.ts ====

// src/models/Block.ts
export class Block {
    id: string = '';
    name: string = '';
}


==== FILE: src\models\BuildingElement.ts ====

/**
 * BuildingElement - Base class for architectural building elements
 */

import { GeometricObject, GeometricObjectType, Point3D } from './GeometricObject';
import { OCShapeHandle } from '../core/GeometryEngine';

// Building element types
export enum BuildingElementType {
    WALL = 'wall',
    DOOR = 'door',
    WINDOW = 'window',
    COLUMN = 'column',
    BEAM = 'beam',
    SLAB = 'slab',
    ROOF = 'roof',
    STAIR = 'stair',
    RAMP = 'ramp',
    RAILING = 'railing',
    FURNITURE = 'furniture',
    EQUIPMENT = 'equipment'
}

// Element properties
export interface BuildingElementProperties {
    material?: string;
    fireRating?: string;
    acousticRating?: number;
    thermalResistance?: number;
    loadBearing?: boolean;
    structuralMaterial?: string;
    finishMaterial?: string;
    manufacturer?: string;
    model?: string;
    cost?: number;
    [key: string]: any;
}

/**
 * Abstract base class for building elements
 */
export abstract class BuildingElement extends GeometricObject {
    // Element type
    protected elementType: BuildingElementType;
    
    // Element properties
    protected elementProperties: BuildingElementProperties;
    
    // Related elements
    protected connectedElements: string[] = [];
    protected hostedElements: string[] = [];
    protected hostElement?: string;
    
    // Level/Floor association
    protected levelId?: string;
    protected elevation: number = 0;

    constructor(type: GeometricObjectType, elementType: BuildingElementType) {
        super(type);
        this.elementType = elementType;
        this.elementProperties = {};
    }

    /**
     * Get element type
     */
    public getElementType(): BuildingElementType {
        return this.elementType;
    }

    /**
     * Set element property
     */
    public setProperty(key: string, value: any): void {
        this.elementProperties[key] = value;
        this.updateModifiedTime();
    }

    /**
     * Get element property
     */
    public getProperty(key: string): any {
        return this.elementProperties[key];
    }

    /**
     * Get all properties
     */
    public getProperties(): BuildingElementProperties {
        return { ...this.elementProperties };
    }

    /**
     * Add connected element
     */
    public addConnectedElement(elementId: string): void {
        if (!this.connectedElements.includes(elementId)) {
            this.connectedElements.push(elementId);
            this.updateModifiedTime();
        }
    }

    /**
     * Remove connected element
     */
    public removeConnectedElement(elementId: string): void {
        const index = this.connectedElements.indexOf(elementId);
        if (index !== -1) {
            this.connectedElements.splice(index, 1);
            this.updateModifiedTime();
        }
    }

    /**
     * Add hosted element
     */
    public addHostedElement(elementId: string): void {
        if (!this.hostedElements.includes(elementId)) {
            this.hostedElements.push(elementId);
            this.updateModifiedTime();
        }
    }

    /**
     * Remove hosted element
     */
    public removeHostedElement(elementId: string): void {
        const index = this.hostedElements.indexOf(elementId);
        if (index !== -1) {
            this.hostedElements.splice(index, 1);
            this.updateModifiedTime();
        }
    }

    /**
     * Set host element
     */
    public setHostElement(elementId?: string): void {
        this.hostElement = elementId;
        this.updateModifiedTime();
    }

    /**
     * Set level association
     */
    public setLevel(levelId: string, elevation: number = 0): void {
        this.levelId = levelId;
        this.elevation = elevation;
        this.updateModifiedTime();
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        const baseJSON = super.toJSON();
        
        return {
            ...baseJSON,
            elementType: this.elementType,
            elementProperties: { ...this.elementProperties },
            connectedElements: [...this.connectedElements],
            hostedElements: [...this.hostedElements],
            hostElement: this.hostElement,
            levelId: this.levelId,
            elevation: this.elevation
        };
    }

    /**
     * Restore from JSON
     */
    public fromJSON(data: any): void {
        super.fromJSON(data);
        
        if (data.elementType) {
            this.elementType = data.elementType;
        }
        
        if (data.elementProperties) {
            this.elementProperties = { ...data.elementProperties };
        }
        
        if (data.connectedElements) {
            this.connectedElements = [...data.connectedElements];
        }
        
        if (data.hostedElements) {
            this.hostedElements = [...data.hostedElements];
        }
        
        this.hostElement = data.hostElement;
        this.levelId = data.levelId;
        this.elevation = data.elevation || 0;
    }
}

/**
 * Wall element
 */
export class WallElement extends BuildingElement {
    private startPoint: Point3D;
    private endPoint: Point3D;
    private height: number;
    private thickness: number;
    private baseOffset: number = 0;

    constructor(
        startPoint: Point3D,
        endPoint: Point3D,
        height: number = 3,
        thickness: number = 0.2
    ) {
        super(GeometricObjectType.SOLID, BuildingElementType.WALL);
        
        this.startPoint = { ...startPoint };
        this.endPoint = { ...endPoint };
        this.height = height;
        this.thickness = thickness;
        
        // Default wall properties
        this.elementProperties = {
            material: 'Concrete',
            loadBearing: true,
            fireRating: '2HR',
            acousticRating: 50
        };
    }

    protected createOCShape(): OCShapeHandle {
        // Create wall geometry using GeometryEngine
        // This would create a box or swept profile
        const length = this.getLength();
        const wallBox = this.geometryEngine.createBox(
            length,
            this.thickness,
            this.height,
            this.startPoint
        );
        
        return wallBox;
    }

    protected updateOCShape(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
    }

    public getBounds(): { min: Point3D; max: Point3D } {
        return {
            min: {
                x: Math.min(this.startPoint.x, this.endPoint.x) - this.thickness / 2,
                y: Math.min(this.startPoint.y, this.endPoint.y) - this.thickness / 2,
                z: Math.min(this.startPoint.z, this.endPoint.z)
            },
            max: {
                x: Math.max(this.startPoint.x, this.endPoint.x) + this.thickness / 2,
                y: Math.max(this.startPoint.y, this.endPoint.y) + this.thickness / 2,
                z: Math.max(this.startPoint.z, this.endPoint.z) + this.height
            }
        };
    }

    public clone(): WallElement {
        const cloned = new WallElement(
            this.startPoint,
            this.endPoint,
            this.height,
            this.thickness
        );
        
        // Copy base properties
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned.elementProperties = { ...this.elementProperties };
        
        return cloned;
    }

    public getLength(): number {
        return Math.sqrt(
            Math.pow(this.endPoint.x - this.startPoint.x, 2) +
            Math.pow(this.endPoint.y - this.startPoint.y, 2) +
            Math.pow(this.endPoint.z - this.startPoint.z, 2)
        );
    }

    public getArea(): number {
        return this.getLength() * this.height;
    }

    public getVolume(): number {
        return this.getArea() * this.thickness;
    }
}

/**
 * Door element
 */
export class DoorElement extends BuildingElement {
    private position: Point3D;
    private width: number;
    private height: number;
    private thickness: number;
    private swingDirection: 'left' | 'right' | 'double';
    private openingAngle: number = 90;

    constructor(
        position: Point3D,
        width: number = 0.9,
        height: number = 2.1,
        thickness: number = 0.05
    ) {
        super(GeometricObjectType.SOLID, BuildingElementType.DOOR);
        
        this.position = { ...position };
        this.width = width;
        this.height = height;
        this.thickness = thickness;
        this.swingDirection = 'left';
        
        // Default door properties
        this.elementProperties = {
            material: 'Wood',
            fireRating: '1HR',
            manufacturer: 'Generic',
            model: 'Standard Door'
        };
    }

    protected createOCShape(): OCShapeHandle {
        // Create door geometry
        return this.geometryEngine.createBox(
            this.width,
            this.thickness,
            this.height,
            this.position
        );
    }

    protected updateOCShape(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
    }

    public getBounds(): { min: Point3D; max: Point3D } {
        return {
            min: {
                x: this.position.x,
                y: this.position.y,
                z: this.position.z
            },
            max: {
                x: this.position.x + this.width,
                y: this.position.y + this.thickness,
                z: this.position.z + this.height
            }
        };
    }

    public clone(): DoorElement {
        const cloned = new DoorElement(
            this.position,
            this.width,
            this.height,
            this.thickness
        );
        
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned.elementProperties = { ...this.elementProperties };
        cloned.swingDirection = this.swingDirection;
        cloned.openingAngle = this.openingAngle;
        
        return cloned;
    }
}

/**
 * Window element
 */
export class WindowElement extends BuildingElement {
    private position: Point3D;
    private width: number;
    private height: number;
    private sillHeight: number;
    
    constructor(
        position: Point3D,
        width: number = 1.2,
        height: number = 1.5,
        sillHeight: number = 0.9
    ) {
        super(GeometricObjectType.SOLID, BuildingElementType.WINDOW);
        
        this.position = { ...position };
        this.width = width;
        this.height = height;
        this.sillHeight = sillHeight;
        
        // Default window properties
        this.elementProperties = {
            material: 'Aluminum',
            glazing: 'Double',
            uValue: 1.4,
            manufacturer: 'Generic',
            model: 'Standard Window'
        };
    }

    protected createOCShape(): OCShapeHandle {
        // Create window geometry
        const windowPosition = {
            x: this.position.x,
            y: this.position.y,
            z: this.position.z + this.sillHeight
        };
        
        return this.geometryEngine.createBox(
            this.width,
            0.1, // Thin depth
            this.height,
            windowPosition
        );
    }

    protected updateOCShape(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
    }

    public getBounds(): { min: Point3D; max: Point3D } {
        return {
            min: {
                x: this.position.x,
                y: this.position.y,
                z: this.position.z + this.sillHeight
            },
            max: {
                x: this.position.x + this.width,
                y: this.position.y + 0.1,
                z: this.position.z + this.sillHeight + this.height
            }
        };
    }

    public clone(): WindowElement {
        const cloned = new WindowElement(
            this.position,
            this.width,
            this.height,
            this.sillHeight
        );
        
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned.elementProperties = { ...this.elementProperties };
        
        return cloned;
    }
}

==== FILE: src\models\Circle.ts ====

/**
 * Circle - Circle entity class
 * Represents a circle in 2D/3D space
 */

import { GeometricObject, GeometricObjectType, Point3D } from './GeometricObject';
import { OCShapeHandle } from '../core/GeometryEngine';

/**
 * Circle class - represents a circle
 */
export class Circle extends GeometricObject {
    // Center point
    private _center: Point3D;
    
    // Radius
    private _radius: number;
    
    // Normal vector (for 3D orientation)
    private _normal: Point3D;

    /**
     * Constructor - creates a circle
     */
    constructor(center: Point3D, radius: number, normal: Point3D = { x: 0, y: 0, z: 1 }) {
        super(GeometricObjectType.CIRCLE);
        
        this._center = { ...center };
        this._radius = radius;
        this._normal = { ...normal };
        
        this.logger.info(`Created circle at (${center.x}, ${center.y}, ${center.z}) with radius ${radius}`);
    }

    /**
     * Create geometric shape in OpenCASCADE
     */
    protected createOCShape(): OCShapeHandle {
        try {
            const circleHandle = this.geometryEngine.createCircle(
                this._center,
                this._normal,
                this._radius
            );
            
            this.logger.debug(`Created circle in OpenCASCADE - Handle: ${circleHandle}`);
            return circleHandle;
            
        } catch (error) {
            this.logger.error(`Failed to create circle in OpenCASCADE`, error);
            throw error;
        }
    }

    /**
     * Update geometric shape when properties change
     */
    protected updateOCShape(): void {
        // Delete old shape
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
        
        // New shape will be created on next access
        this.logger.debug(`Updated circle ${this._id}`);
    }

    /**
     * Calculate bounding box
     */
    public getBounds(): { min: Point3D; max: Point3D } {
        return {
            min: {
                x: this._center.x - this._radius,
                y: this._center.y - this._radius,
                z: this._center.z
            },
            max: {
                x: this._center.x + this._radius,
                y: this._center.y + this._radius,
                z: this._center.z
            }
        };
    }

    /**
     * Clone the circle
     */
    public clone(): Circle {
        const cloned = new Circle(this._center, this._radius, this._normal);
        
        // Copy properties from original
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned._transform = {
            translation: { ...this._transform.translation },
            rotation: { ...this._transform.rotation },
            scale: { ...this._transform.scale }
        };
        
        return cloned;
    }

    /**
     * Calculate circumference
     */
    public getCircumference(): number {
        return 2 * Math.PI * this._radius;
    }

    /**
     * Calculate area
     */
    public getArea(): number {
        return Math.PI * Math.pow(this._radius, 2);
    }

    /**
     * Get point on circle at given angle
     */
    public getPointAtAngle(angle: number): Point3D {
        // For now, assume circle is in XY plane
        return {
            x: this._center.x + this._radius * Math.cos(angle),
            y: this._center.y + this._radius * Math.sin(angle),
            z: this._center.z
        };
    }

    /**
     * Check if point is on circle
     */
    public isPointOnCircle(point: Point3D, tolerance: number = 0.001): boolean {
        const distance = Math.sqrt(
            Math.pow(point.x - this._center.x, 2) +
            Math.pow(point.y - this._center.y, 2) +
            Math.pow(point.z - this._center.z, 2)
        );
        
        return Math.abs(distance - this._radius) < tolerance;
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        const baseJSON = super.toJSON();
        
        return {
            ...baseJSON,
            center: { ...this._center },
            radius: this._radius,
            normal: { ...this._normal },
            circumference: this.getCircumference(),
            area: this.getArea()
        };
    }

    /**
     * Restore from JSON
     */
    public fromJSON(data: any): void {
        super.fromJSON(data);
        
        if (data.center) {
            this._center = { ...data.center };
        }
        
        if (data.radius !== undefined) {
            this._radius = data.radius;
        }
        
        if (data.normal) {
            this._normal = { ...data.normal };
        }
        
        this._ocHandle = null;
    }

    /**
     * Create circle from JSON
     */
    public static fromJSON(data: any): Circle {
        const circle = new Circle(
            data.center || { x: 0, y: 0, z: 0 },
            data.radius || 1,
            data.normal || { x: 0, y: 0, z: 1 }
        );
        
        circle.fromJSON(data);
        return circle;
    }

    // Getters and Setters
    
    public get center(): Point3D { 
        return { ...this._center }; 
    }
    
    public set center(value: Point3D) {
        this._center = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get radius(): number { 
        return this._radius; 
    }
    
    public set radius(value: number) {
        if (value <= 0) {
            throw new Error('Radius must be positive');
        }
        this._radius = value;
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get normal(): Point3D { 
        return { ...this._normal }; 
    }
    
    public set normal(value: Point3D) {
        this._normal = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
}

==== FILE: src\models\GeometricObject.ts ====

/**
 * GeometricObject - Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
 * 
 * Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø© ØªØ­Ø¯Ø¯ Ø§Ù„Ø®ØµØ§Ø¦Øµ ÙˆØ§Ù„Ø³Ù„ÙˆÙƒÙŠØ§Øª Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ø¨ÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
 * Ù…Ø«Ù„ Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±ÙŠØ¯ØŒ Ø§Ù„Ø·Ø¨Ù‚Ø©ØŒ Ø§Ù„Ù„ÙˆÙ†ØŒ Ø§Ù„Ø±Ø¤ÙŠØ©ØŒ ÙˆØ§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
 */

import { GeometryEngine, OCShapeHandle } from '../core/GeometryEngine';
import { Logger } from '../core/Logger';

// ØªØ¹Ø¯Ø§Ø¯ Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
export enum GeometricObjectType {
    POINT = 'point',
    LINE = 'line',
    CIRCLE = 'circle',
    ARC = 'arc',
    POLYLINE = 'polyline',
    SOLID = 'solid',
    SURFACE = 'surface',
    CURVE = 'curve',
    COMPOUND = 'compound'
}

// ÙˆØ§Ø¬Ù‡Ø© Ù„Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
export interface VisualProperties {
    color: string;
    opacity: number;
    lineWidth?: number;
    lineStyle?: 'solid' | 'dashed' | 'dotted';
    fillPattern?: 'solid' | 'hatch' | 'none';
}

// ÙˆØ§Ø¬Ù‡Ø© Ù„Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
export interface Transform {
    translation: { x: number; y: number; z: number };
    rotation: { x: number; y: number; z: number; angle: number };
    scale: { x: number; y: number; z: number };
}

// ÙˆØ§Ø¬Ù‡Ø© Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
export interface Metadata {
    name?: string;
    description?: string;
    author?: string;
    createdAt: Date;
    modifiedAt: Date;
    customProperties?: Record<string, any>;
}

/**
 * Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
 */
export abstract class GeometricObject {
    // Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„ÙØ±ÙŠØ¯ Ù„Ù„ÙƒØ§Ø¦Ù†
    protected _id: string;
    
    // Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
    protected _type: GeometricObjectType;
    
    // Ù…Ø¹Ø±Ù Ø§Ù„Ø´ÙƒÙ„ ÙÙŠ OpenCASCADE
    protected _ocHandle: OCShapeHandle | null = null;
    
    // Ø§Ù„Ø·Ø¨Ù‚Ø© Ø§Ù„ØªÙŠ ÙŠÙ†ØªÙ…ÙŠ Ø¥Ù„ÙŠÙ‡Ø§ Ø§Ù„ÙƒØ§Ø¦Ù†
    protected _layerId: string = 'default';
    
    // Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¤ÙŠØ©
    protected _visible: boolean = true;
    
    // Ø­Ø§Ù„Ø© Ø§Ù„Ù‚ÙÙ„ (Ù…Ù†Ø¹ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„)
    protected _locked: boolean = false;
    
    // Ø­Ø§Ù„Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ¯
    protected _selected: boolean = false;
    
    // Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø±Ø¦ÙŠØ©
    protected _visualProperties: VisualProperties = {
        color: '#000000',
        opacity: 1.0,
        lineWidth: 1,
        lineStyle: 'solid',
        fillPattern: 'solid'
    };
    
    // Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø·Ø¨Ù‚Ø© Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù†
    protected _transform: Transform = {
        translation: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0, angle: 0 },
        scale: { x: 1, y: 1, z: 1 }
    };
    
    // Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆØµÙÙŠØ©
    protected _metadata: Metadata;
    
    // Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
    protected geometryEngine: GeometryEngine;
    
    // Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    protected logger: Logger;

    constructor(type: GeometricObjectType) {
        this._id = this.generateUniqueId();
        this._type = type;
        this._metadata = {
            createdAt: new Date(),
            modifiedAt: new Date()
        };
        
        this.geometryEngine = GeometryEngine.getInstance();
        this.logger = Logger.getInstance();
        
        this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ Ø¬Ø¯ÙŠØ¯: ${this._type} - ${this._id}`);
    }

    /**
     * ØªÙˆÙ„ÙŠØ¯ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„ÙƒØ§Ø¦Ù†
     * ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ Ù…Ø¹ Ø±Ù‚Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ÙØ±Ø§Ø¯Ø©
     */
    protected generateUniqueId(): string {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substr(2, 9);
        return `${this._type}_${timestamp}_${random}`;
    }

    /**
     * Ø¯Ø§Ù„Ø© Ù…Ø¬Ø±Ø¯Ø© - ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙŠ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø´ØªÙ‚Ø©
     * ØªÙ‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ÙÙŠ OpenCASCADE
     */
    protected abstract createOCShape(): OCShapeHandle;

    /**
     * Ø¯Ø§Ù„Ø© Ù…Ø¬Ø±Ø¯Ø© - ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙŠ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø´ØªÙ‚Ø©
     * ØªÙ‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø®ØµØ§Ø¦Øµ
     */
    protected abstract updateOCShape(): void;

    /**
     * Ø¯Ø§Ù„Ø© Ù…Ø¬Ø±Ø¯Ø© - ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙŠ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø´ØªÙ‚Ø©
     * ØªØ­Ø³Ø¨ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© Ù„Ù„ÙƒØ§Ø¦Ù†
     */
    public abstract getBounds(): { min: Point3D; max: Point3D };

    /**
     * Ø¯Ø§Ù„Ø© Ù…Ø¬Ø±Ø¯Ø© - ÙŠØ¬Ø¨ ØªÙ†ÙÙŠØ°Ù‡Ø§ ÙÙŠ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø´ØªÙ‚Ø©
     * ØªÙ†Ø³Ø® Ø§Ù„ÙƒØ§Ø¦Ù†
     */
    public abstract clone(): GeometricObject;

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ÙÙŠ OpenCASCADE
     * ÙŠÙ†Ø´Ø¦ Ø§Ù„Ø´ÙƒÙ„ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹
     */
    public getOCShape(): OCShapeHandle {
        if (!this._ocHandle) {
            this._ocHandle = this.createOCShape();
        }
        return this._ocHandle;
    }

    /**
     * ØªØ·Ø¨ÙŠÙ‚ ØªØ­ÙˆÙŠÙ„ Ù‡Ù†Ø¯Ø³ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù†
     */
    public applyTransform(transform: Partial<Transform>): void {
        // Ø¯Ù…Ø¬ Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ
        if (transform.translation) {
            this._transform.translation.x += transform.translation.x;
            this._transform.translation.y += transform.translation.y;
            this._transform.translation.z += transform.translation.z;
        }
        
        if (transform.rotation) {
            // Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† ØªØ·Ø¨ÙŠÙ‚ Ù…Ù†Ø·Ù‚ Ø£ÙƒØ«Ø± ØªØ¹Ù‚ÙŠØ¯Ø§Ù‹ Ù„Ø¯Ù…Ø¬ Ø§Ù„Ø¯ÙˆØ±Ø§Ù†Ø§Øª
            this._transform.rotation = transform.rotation;
        }
        
        if (transform.scale) {
            this._transform.scale.x *= transform.scale.x;
            this._transform.scale.y *= transform.scale.y;
            this._transform.scale.z *= transform.scale.z;
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
        this.updateOCShape();
        this.updateModifiedTime();
        
        this.logger.debug(`ØªÙ… ØªØ·Ø¨ÙŠÙ‚ ØªØ­ÙˆÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ø¦Ù† ${this._id}`, transform);
    }

    /**
     * ØªØ­Ø¯ÙŠØ« ÙˆÙ‚Øª Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
     */
    protected updateModifiedTime(): void {
        this._metadata.modifiedAt = new Date();
    }

    /**
     * ØªØ­ÙˆÙŠÙ„ Ø§Ù„ÙƒØ§Ø¦Ù† Ø¥Ù„Ù‰ JSON Ù„Ù„Ø­ÙØ¸
     */
    public toJSON(): object {
        return {
            id: this._id,
            type: this._type,
            layerId: this._layerId,
            visible: this._visible,
            locked: this._locked,
            visualProperties: { ...this._visualProperties },
            transform: {
                translation: { ...this._transform.translation },
                rotation: { ...this._transform.rotation },
                scale: { ...this._transform.scale }
            },
            metadata: {
                ...this._metadata,
                createdAt: this._metadata.createdAt.toISOString(),
                modifiedAt: this._metadata.modifiedAt.toISOString()
            }
        };
    }

    /**
     * Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ÙƒØ§Ø¦Ù† Ù…Ù† JSON
     */
    public fromJSON(data: any): void {
        this._id = data.id;
        this._type = data.type;
        this._layerId = data.layerId || 'default';
        this._visible = data.visible !== undefined ? data.visible : true;
        this._locked = data.locked || false;
        
        if (data.visualProperties) {
            this._visualProperties = { ...data.visualProperties };
        }
        
        if (data.transform) {
            this._transform = {
                translation: { ...data.transform.translation },
                rotation: { ...data.transform.rotation },
                scale: { ...data.transform.scale }
            };
        }
        
        if (data.metadata) {
            this._metadata = {
                ...data.metadata,
                createdAt: new Date(data.metadata.createdAt),
                modifiedAt: new Date(data.metadata.modifiedAt)
            };
        }
    }

    /**
     * ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ÙˆØ§Ø±Ø¯
     */
    public dispose(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
        
        this.logger.debug(`ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ: ${this._id}`);
    }

    // Getters Ùˆ Setters Ù„Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    
    public get id(): string { return this._id; }
    
    public get type(): GeometricObjectType { return this._type; }
    
    public get layerId(): string { return this._layerId; }
    public set layerId(value: string) {
        this._layerId = value;
        this.updateModifiedTime();
    }
    
    public get visible(): boolean { return this._visible; }
    public set visible(value: boolean) {
        this._visible = value;
        this.updateModifiedTime();
    }
    
    public get locked(): boolean { return this._locked; }
    public set locked(value: boolean) {
        this._locked = value;
        this.updateModifiedTime();
    }
    
    public get selected(): boolean { return this._selected; }
    public set selected(value: boolean) {
        this._selected = value;
    }
    
    public get visualProperties(): VisualProperties { return { ...this._visualProperties }; }
    public set visualProperties(value: Partial<VisualProperties>) {
        this._visualProperties = { ...this._visualProperties, ...value };
        this.updateModifiedTime();
    }
    
    public get transform(): Transform {
        return {
            translation: { ...this._transform.translation },
            rotation: { ...this._transform.rotation },
            scale: { ...this._transform.scale }
        };
    }
    
    public get metadata(): Metadata { return { ...this._metadata }; }
    
    public setMetadata(key: string, value: any): void {
        if (!this._metadata.customProperties) {
            this._metadata.customProperties = {};
        }
        this._metadata.customProperties[key] = value;
        this.updateModifiedTime();
    }
}

// Ù†ÙˆØ¹ Ù…Ø³Ø§Ø¹Ø¯ Ù„Ù„Ù†Ù‚Ø·Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
export interface Point3D {
    x: number;
    y: number;
    z: number;
}

==== FILE: src\models\Layer.ts ====

/**
 * Layer - Layer management for organizing geometric objects
 */

import { Color } from 'three';

export interface LayerProperties {
    color?: string;
    lineWidth?: number;
    lineStyle?: 'solid' | 'dashed' | 'dotted';
    opacity?: number;
}

/**
 * Layer class - represents a drawing layer
 */
export class Layer {
    // Unique identifier
    public id: string;
    
    // Layer name
    public name: string;
    
    // Visibility state
    public visible: boolean = true;
    
    // Lock state
    public locked: boolean = false;
    
    // Layer order (z-index)
    public order: number = 0;
    
    // Visual properties
    public properties: LayerProperties;
    
    // Parent layer (for nested layers)
    public parentId?: string;
    
    // Child layers
    public childIds: string[] = [];
    
    // Metadata
    public metadata: {
        createdAt: Date;
        modifiedAt: Date;
        description?: string;
        [key: string]: any;
    };

    constructor(name?: string) {
        this.id = this.generateId();
        this.name = name || `Layer ${this.id}`;
        
        this.properties = {
            color: '#000000',
            lineWidth: 1,
            lineStyle: 'solid',
            opacity: 1
        };
        
        this.metadata = {
            createdAt: new Date(),
            modifiedAt: new Date()
        };
    }

    /**
     * Generate unique ID
     */
    private generateId(): string {
        return `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Update layer properties
     */
    public updateProperties(properties: Partial<LayerProperties>): void {
        Object.assign(this.properties, properties);
        this.metadata.modifiedAt = new Date();
    }

    /**
     * Add child layer
     */
    public addChild(childId: string): void {
        if (!this.childIds.includes(childId)) {
            this.childIds.push(childId);
            this.metadata.modifiedAt = new Date();
        }
    }

    /**
     * Remove child layer
     */
    public removeChild(childId: string): void {
        const index = this.childIds.indexOf(childId);
        if (index !== -1) {
            this.childIds.splice(index, 1);
            this.metadata.modifiedAt = new Date();
        }
    }

    /**
     * Clone layer
     */
    public clone(): Layer {
        const cloned = new Layer(this.name + ' (Copy)');
        cloned.visible = this.visible;
        cloned.locked = this.locked;
        cloned.order = this.order;
        cloned.properties = { ...this.properties };
        cloned.parentId = this.parentId;
        cloned.childIds = [...this.childIds];
        cloned.metadata = {
            ...this.metadata,
            createdAt: new Date(),
            modifiedAt: new Date()
        };
        return cloned;
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        return {
            id: this.id,
            name: this.name,
            visible: this.visible,
            locked: this.locked,
            order: this.order,
            properties: { ...this.properties },
            parentId: this.parentId,
            childIds: [...this.childIds],
            metadata: {
                ...this.metadata,
                createdAt: this.metadata.createdAt.toISOString(),
                modifiedAt: this.metadata.modifiedAt.toISOString()
            }
        };
    }

    /**
     * Create from JSON
     */
    public static fromJSON(data: any): Layer {
        const layer = new Layer(data.name);
        layer.id = data.id;
        layer.visible = data.visible ?? true;
        layer.locked = data.locked ?? false;
        layer.order = data.order ?? 0;
        
        if (data.properties) {
            layer.properties = { ...data.properties };
        }
        
        layer.parentId = data.parentId;
        layer.childIds = data.childIds || [];
        
        if (data.metadata) {
            layer.metadata = {
                ...data.metadata,
                createdAt: new Date(data.metadata.createdAt),
                modifiedAt: new Date(data.metadata.modifiedAt)
            };
        }
        
        return layer;
    }
}

/**
 * Layer Manager - manages all layers in the project
 */
export class LayerManager {
    private layers: Map<string, Layer> = new Map();
    private activeLayerId: string = 'default';

    constructor() {
        // Create default layer
        const defaultLayer = new Layer('Default');
        defaultLayer.id = 'default';
        this.layers.set('default', defaultLayer);
    }

    /**
     * Add layer
     */
    public addLayer(layer: Layer): void {
        this.layers.set(layer.id, layer);
        
        // Update parent's children
        if (layer.parentId) {
            const parent = this.layers.get(layer.parentId);
            if (parent) {
                parent.addChild(layer.id);
            }
        }
    }

    /**
     * Remove layer
     */
    public removeLayer(layerId: string): boolean {
        if (layerId === 'default') {
            return false; // Cannot remove default layer
        }
        
        const layer = this.layers.get(layerId);
        if (!layer) return false;
        
        // Remove from parent's children
        if (layer.parentId) {
            const parent = this.layers.get(layer.parentId);
            if (parent) {
                parent.removeChild(layerId);
            }
        }
        
        // Move children to parent or default
        layer.childIds.forEach(childId => {
            const child = this.layers.get(childId);
            if (child) {
                child.parentId = layer.parentId || 'default';
            }
        });
        
        this.layers.delete(layerId);
        
        // If active layer was removed, switch to default
        if (this.activeLayerId === layerId) {
            this.activeLayerId = 'default';
        }
        
        return true;
    }

    /**
     * Get layer
     */
    public getLayer(layerId: string): Layer | undefined {
        return this.layers.get(layerId);
    }

    /**
     * Get all layers
     */
    public getAllLayers(): Layer[] {
        return Array.from(this.layers.values());
    }

    /**
     * Get visible layers
     */
    public getVisibleLayers(): Layer[] {
        return this.getAllLayers().filter(layer => layer.visible);
    }

    /**
     * Set active layer
     */
    public setActiveLayer(layerId: string): boolean {
        if (this.layers.has(layerId)) {
            this.activeLayerId = layerId;
            return true;
        }
        return false;
    }

    /**
     * Get active layer
     */
    public getActiveLayer(): Layer | undefined {
        return this.layers.get(this.activeLayerId);
    }

    /**
     * Move layer order
     */
    public moveLayer(layerId: string, newOrder: number): void {
        const layer = this.layers.get(layerId);
        if (layer) {
            layer.order = newOrder;
            // Re-sort other layers if needed
            this.normalizeLayerOrder();
        }
    }

    /**
     * Normalize layer order
     */
    private normalizeLayerOrder(): void {
        const sortedLayers = this.getAllLayers().sort((a, b) => a.order - b.order);
        sortedLayers.forEach((layer, index) => {
            layer.order = index;
        });
    }

    /**
     * Get layers in order
     */
    public getLayersInOrder(): Layer[] {
        return this.getAllLayers().sort((a, b) => a.order - b.order);
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        return {
            layers: this.getAllLayers().map(layer => layer.toJSON()),
            activeLayerId: this.activeLayerId
        };
    }

    /**
     * Load from JSON
     */
    public fromJSON(data: any): void {
        this.layers.clear();
        
        if (data.layers && Array.isArray(data.layers)) {
            data.layers.forEach((layerData: any) => {
                const layer = Layer.fromJSON(layerData);
                this.layers.set(layer.id, layer);
            });
        }
        
        // Ensure default layer exists
        if (!this.layers.has('default')) {
            const defaultLayer = new Layer('Default');
            defaultLayer.id = 'default';
            this.layers.set('default', defaultLayer);
        }
        
        this.activeLayerId = data.activeLayerId || 'default';
        
        // Validate active layer
        if (!this.layers.has(this.activeLayerId)) {
            this.activeLayerId = 'default';
        }
    }
}

==== FILE: src\models\Line.ts ====

/**
 * Line - ÙØ¦Ø© ØªÙ…Ø«Ù„ Ø®Ø·Ø§Ù‹ Ù…Ø³ØªÙ‚ÙŠÙ…Ø§Ù‹ ÙÙŠ Ø§Ù„ÙØ¶Ø§Ø¡ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
 * 
 * Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø© ØªØ±Ø« Ù…Ù† GeometricObject ÙˆØªÙ†ÙØ° Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø¬Ø±Ø¯Ø©
 * Ù„ØªÙ…Ø«ÙŠÙ„ Ø®Ø· Ø¨Ø³ÙŠØ· Ø¨ÙŠÙ† Ù†Ù‚Ø·ØªÙŠÙ†
 */

import { GeometricObject, GeometricObjectType, Point3D } from './GeometricObject';
import { OCShapeHandle, OCPointHandle } from '../core/GeometryEngine';

/**
 * ÙØ¦Ø© Line - ØªÙ…Ø«Ù„ Ø®Ø·Ø§Ù‹ Ù…Ø³ØªÙ‚ÙŠÙ…Ø§Ù‹
 */
export class Line extends GeometricObject {
    // Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    private _startPoint: Point3D;
    
    // Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
    private _endPoint: Point3D;
    
    // Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù†Ù‚Ø§Ø· ÙÙŠ OpenCASCADE (Ù„Ù„Ø£Ø¯Ø§Ø¡)
    private _startPointHandle: OCPointHandle | null = null;
    private _endPointHandle: OCPointHandle | null = null;

    /**
     * Ø§Ù„Ù…ÙÙ†Ø´Ø¦ - ÙŠÙ†Ø´Ø¦ Ø®Ø·Ø§Ù‹ Ø¨ÙŠÙ† Ù†Ù‚Ø·ØªÙŠÙ†
     */
    constructor(startPoint: Point3D, endPoint: Point3D) {
        super(GeometricObjectType.LINE);
        
        this._startPoint = { ...startPoint };
        this._endPoint = { ...endPoint };
        
        this.logger.info(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù…Ù† (${startPoint.x}, ${startPoint.y}, ${startPoint.z}) Ø¥Ù„Ù‰ (${endPoint.x}, ${endPoint.y}, ${endPoint.z})`);
    }

    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ÙÙŠ OpenCASCADE
     * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙØ³ØªØ¯Ø¹Ù‰ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù„Ù„Ø´ÙƒÙ„
     */
    protected createOCShape(): OCShapeHandle {
        try {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ù‚Ø§Ø· ÙÙŠ OpenCASCADE Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø©
            if (!this._startPointHandle) {
                this._startPointHandle = this.geometryEngine.createPoint(
                    this._startPoint.x,
                    this._startPoint.y,
                    this._startPoint.z
                );
            }
            
            if (!this._endPointHandle) {
                this._endPointHandle = this.geometryEngine.createPoint(
                    this._endPoint.x,
                    this._endPoint.y,
                    this._endPoint.z
                );
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ø·
            const lineHandle = this.geometryEngine.createLine(
                this._startPointHandle,
                this._endPointHandle
            );
            
            this.logger.debug(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· ÙÙŠ OpenCASCADE - Handle: ${lineHandle}`);
            
            return lineHandle;
        } catch (error) {
            this.logger.error(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø®Ø· ÙÙŠ OpenCASCADE`, error);
            throw error;
        }
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø®ØµØ§Ø¦Øµ
     * ÙŠÙØ³ØªØ¯Ø¹Ù‰ Ø¹Ù†Ø¯ ØªØ¹Ø¯ÙŠÙ„ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø£Ùˆ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
     */
    protected updateOCShape(): void {
        // Ø­Ø°Ù Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù‚Ø¯ÙŠÙ…
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
        
        // Ø­Ø°Ù Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        if (this._startPointHandle) {
            this.geometryEngine.deleteShape(this._startPointHandle);
            this._startPointHandle = null;
        }
        
        if (this._endPointHandle) {
            this.geometryEngine.deleteShape(this._endPointHandle);
            this._endPointHandle = null;
        }
        
        // Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø´ÙƒÙ„ Ø¬Ø¯ÙŠØ¯ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
        this.logger.debug(`ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø®Ø· ${this._id}`);
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© Ù„Ù„Ø®Ø·
     * ØªÙØ³ØªØ®Ø¯Ù… Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ ÙˆØ§Ù„Ø¹Ø±Ø¶
     */
    public getBounds(): { min: Point3D; max: Point3D } {
        return {
            min: {
                x: Math.min(this._startPoint.x, this._endPoint.x),
                y: Math.min(this._startPoint.y, this._endPoint.y),
                z: Math.min(this._startPoint.z, this._endPoint.z)
            },
            max: {
                x: Math.max(this._startPoint.x, this._endPoint.x),
                y: Math.max(this._startPoint.y, this._endPoint.y),
                z: Math.max(this._startPoint.z, this._endPoint.z)
            }
        };
    }

    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ø®Ø·
     */
    public clone(): Line {
        const clonedLine = new Line(this._startPoint, this._endPoint);
        
        // Ù†Ø³Ø® Ø§Ù„Ø®ØµØ§Ø¦Øµ Ù…Ù† Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ø£ØµÙ„ÙŠ
        clonedLine._layerId = this._layerId;
        clonedLine._visible = this._visible;
        clonedLine._locked = this._locked;
        clonedLine._visualProperties = { ...this._visualProperties };
        clonedLine._transform = {
            translation: { ...this._transform.translation },
            rotation: { ...this._transform.rotation },
            scale: { ...this._transform.scale }
        };
        
        return clonedLine;
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ø·ÙˆÙ„ Ø§Ù„Ø®Ø·
     * Ù‡Ø°Ù‡ Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù…ÙÙŠØ¯Ø© Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø®Ø·ÙˆØ·
     */
    public getLength(): number {
        const dx = this._endPoint.x - this._startPoint.x;
        const dy = this._endPoint.y - this._startPoint.y;
        const dz = this._endPoint.z - this._startPoint.z;
        
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ
     */
    public getMidPoint(): Point3D {
        return {
            x: (this._startPoint.x + this._endPoint.x) / 2,
            y: (this._startPoint.y + this._endPoint.y) / 2,
            z: (this._startPoint.z + this._endPoint.z) / 2
        };
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ù…ØªØ¬Ù‡ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ (Ù…ÙØ·Ø¨ÙÙ‘Ø¹)
     */
    public getDirection(): Point3D {
        const length = this.getLength();
        
        if (length === 0) {
            return { x: 0, y: 0, z: 0 };
        }
        
        return {
            x: (this._endPoint.x - this._startPoint.x) / length,
            y: (this._endPoint.y - this._startPoint.y) / length,
            z: (this._endPoint.z - this._startPoint.z) / length
        };
    }

    /**
     * Ø­Ø³Ø§Ø¨ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø· Ù…Ù† Ù†Ù‚Ø·Ø© Ù…Ø¹ÙŠÙ†Ø©
     */
    public getClosestPoint(point: Point3D): Point3D {
        const direction = this.getDirection();
        const length = this.getLength();
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·
        const toPoint = {
            x: point.x - this._startPoint.x,
            y: point.y - this._startPoint.y,
            z: point.z - this._startPoint.z
        };
        
        // Ø­Ø§ØµÙ„ Ø§Ù„Ø¶Ø±Ø¨ Ø§Ù„Ù†Ù‚Ø·ÙŠ
        let t = toPoint.x * direction.x + 
                toPoint.y * direction.y + 
                toPoint.z * direction.z;
        
        // ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¨ÙŠÙ† 0 Ùˆ Ø·ÙˆÙ„ Ø§Ù„Ø®Ø·
        t = Math.max(0, Math.min(length, t));
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·
        return {
            x: this._startPoint.x + direction.x * t,
            y: this._startPoint.y + direction.y * t,
            z: this._startPoint.z + direction.z * t
        };
    }

    /**
     * ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ JSON Ù…Ø¹ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø®Ø· Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
     */
    public toJSON(): object {
        const baseJSON = super.toJSON();
        
        return {
            ...baseJSON,
            startPoint: { ...this._startPoint },
            endPoint: { ...this._endPoint },
            length: this.getLength()
        };
    }

    /**
     * Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ù† JSON
     */
    public fromJSON(data: any): void {
        super.fromJSON(data);
        
        if (data.startPoint) {
            this._startPoint = { ...data.startPoint };
        }
        
        if (data.endPoint) {
            this._endPoint = { ...data.endPoint };
        }
        
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø¹Ø±ÙØ§Øª Ù„Ø¥Ø¬Ø¨Ø§Ø± Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
        this._startPointHandle = null;
        this._endPointHandle = null;
        this._ocHandle = null;
    }

    /**
     * Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø· Ù…Ù† JSON Ù…Ø¨Ø§Ø´Ø±Ø©
     */
    public static fromJSON(data: any): Line {
        const line = new Line(
            data.startPoint || { x: 0, y: 0, z: 0 },
            data.endPoint || { x: 1, y: 0, z: 0 }
        );
        
        line.fromJSON(data);
        return line;
    }

    // Getters Ùˆ Setters Ù„Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø®Ø·
    
    public get startPoint(): Point3D { 
        return { ...this._startPoint }; 
    }
    
    public set startPoint(value: Point3D) {
        this._startPoint = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get endPoint(): Point3D { 
        return { ...this._endPoint }; 
    }
    
    public set endPoint(value: Point3D) {
        this._endPoint = { ...value };
        this.updateOCShape();
        this.updateModifiedTime();
    }
}

==== FILE: src\models\Point.ts ====

// src/models/Point.ts
import { GeometricObject, GeometricObjectType } from './GeometricObject';
export class Point extends GeometricObject {
    constructor() { super(GeometricObjectType.POINT); }
    protected createOCShape(): any { return null; }
    protected updateOCShape(): void {}
    public getBounds(): any { return null; }
    public clone(): Point { return new Point(); }
}

==== FILE: src\models\Polyline.ts ====

/**
 * Polyline - Polyline entity class
 * Represents a multi-segment line in 2D/3D space
 */

import { GeometricObject, GeometricObjectType, Point3D } from './GeometricObject';
import { OCShapeHandle } from '../core/GeometryEngine';

/**
 * Polyline class - represents a polyline
 */
export class Polyline extends GeometricObject {
    // Vertices
    private _vertices: Point3D[];
    
    // Is closed
    private _isClosed: boolean;

    /**
     * Constructor - creates a polyline
     */
    constructor(vertices: Point3D[], isClosed: boolean = false) {
        super(GeometricObjectType.POLYLINE);
        
        if (vertices.length < 2) {
            throw new Error('Polyline must have at least 2 vertices');
        }
        
        this._vertices = vertices.map(v => ({ ...v }));
        this._isClosed = isClosed;
        
        this.logger.info(`Created polyline with ${vertices.length} vertices`);
    }

    /**
     * Create geometric shape in OpenCASCADE
     */
    protected createOCShape(): OCShapeHandle {
        try {
            // Create individual line segments
            const segments: OCShapeHandle[] = [];
            
            for (let i = 0; i < this._vertices.length - 1; i++) {
                const handle = this.geometryEngine.createLine(
                    this._vertices[i],
                    this._vertices[i + 1]
                );
                segments.push(handle);
            }
            
            // If closed, add closing segment
            if (this._isClosed && this._vertices.length > 2) {
                const handle = this.geometryEngine.createLine(
                    this._vertices[this._vertices.length - 1],
                    this._vertices[0]
                );
                segments.push(handle);
            }
            
            // TODO: Combine segments into a wire
            // For now, return first segment as placeholder
            
            this.logger.debug(`Created polyline in OpenCASCADE with ${segments.length} segments`);
            return segments[0];
            
        } catch (error) {
            this.logger.error(`Failed to create polyline in OpenCASCADE`, error);
            throw error;
        }
    }

    /**
     * Update geometric shape when properties change
     */
    protected updateOCShape(): void {
        if (this._ocHandle) {
            this.geometryEngine.deleteShape(this._ocHandle);
            this._ocHandle = null;
        }
        
        this.logger.debug(`Updated polyline ${this._id}`);
    }

    /**
     * Calculate bounding box
     */
    public getBounds(): { min: Point3D; max: Point3D } {
        const xs = this._vertices.map(v => v.x);
        const ys = this._vertices.map(v => v.y);
        const zs = this._vertices.map(v => v.z);
        
        return {
            min: {
                x: Math.min(...xs),
                y: Math.min(...ys),
                z: Math.min(...zs)
            },
            max: {
                x: Math.max(...xs),
                y: Math.max(...ys),
                z: Math.max(...zs)
            }
        };
    }

    /**
     * Clone the polyline
     */
    public clone(): Polyline {
        const cloned = new Polyline(this._vertices, this._isClosed);
        
        // Copy properties from original
        cloned._layerId = this._layerId;
        cloned._visible = this._visible;
        cloned._locked = this._locked;
        cloned._visualProperties = { ...this._visualProperties };
        cloned._transform = {
            translation: { ...this._transform.translation },
            rotation: { ...this._transform.rotation },
            scale: { ...this._transform.scale }
        };
        
        return cloned;
    }

    /**
     * Get total length
     */
    public getTotalLength(): number {
        let length = 0;
        
        for (let i = 1; i < this._vertices.length; i++) {
            length += this.getSegmentLength(i - 1);
        }
        
        if (this._isClosed && this._vertices.length > 2) {
            length += this.getClosingSegmentLength();
        }
        
        return length;
    }

    /**
     * Get segment length
     */
    public getSegmentLength(index: number): number {
        if (index < 0 || index >= this._vertices.length - 1) {
            throw new Error('Invalid segment index');
        }
        
        const p1 = this._vertices[index];
        const p2 = this._vertices[index + 1];
        
        return Math.sqrt(
            Math.pow(p2.x - p1.x, 2) +
            Math.pow(p2.y - p1.y, 2) +
            Math.pow(p2.z - p1.z, 2)
        );
    }

    /**
     * Get closing segment length
     */
    public getClosingSegmentLength(): number {
        if (!this._isClosed || this._vertices.length < 3) {
            return 0;
        }
        
        const p1 = this._vertices[this._vertices.length - 1];
        const p2 = this._vertices[0];
        
        return Math.sqrt(
            Math.pow(p2.x - p1.x, 2) +
            Math.pow(p2.y - p1.y, 2) +
            Math.pow(p2.z - p1.z, 2)
        );
    }

    /**
     * Get area (for closed polylines)
     */
    public getArea(): number {
        if (!this._isClosed || this._vertices.length < 3) {
            return 0;
        }
        
        let area = 0;
        const n = this._vertices.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += this._vertices[i].x * this._vertices[j].y;
            area -= this._vertices[j].x * this._vertices[i].y;
        }
        
        return Math.abs(area) / 2;
    }

    /**
     * Get centroid
     */
    public getCentroid(): Point3D {
        let cx = 0, cy = 0, cz = 0;
        const n = this._vertices.length;
        
        for (const vertex of this._vertices) {
            cx += vertex.x;
            cy += vertex.y;
            cz += vertex.z;
        }
        
        return {
            x: cx / n,
            y: cy / n,
            z: cz / n
        };
    }

    /**
     * Add vertex
     */
    public addVertex(vertex: Point3D, index?: number): void {
        if (index === undefined) {
            this._vertices.push({ ...vertex });
        } else {
            if (index < 0 || index > this._vertices.length) {
                throw new Error('Invalid vertex index');
            }
            this._vertices.splice(index, 0, { ...vertex });
        }
        
        this.updateOCShape();
        this.updateModifiedTime();
    }

    /**
     * Remove vertex
     */
    public removeVertex(index: number): void {
        if (index < 0 || index >= this._vertices.length) {
            throw new Error('Invalid vertex index');
        }
        
        if (this._vertices.length <= 2) {
            throw new Error('Cannot remove vertex - polyline must have at least 2 vertices');
        }
        
        this._vertices.splice(index, 1);
        this.updateOCShape();
        this.updateModifiedTime();
    }

    /**
     * Update vertex
     */
    public updateVertex(index: number, vertex: Point3D): void {
        if (index < 0 || index >= this._vertices.length) {
            throw new Error('Invalid vertex index');
        }
        
        this._vertices[index] = { ...vertex };
        this.updateOCShape();
        this.updateModifiedTime();
    }

    /**
     * Get point at parameter t (0 to 1)
     */
    public getPointAtParameter(t: number): Point3D {
        const totalLength = this.getTotalLength();
        const targetLength = t * totalLength;
        
        let accumulatedLength = 0;
        
        // Find segment containing target point
        for (let i = 0; i < this._vertices.length - 1; i++) {
            const segmentLength = this.getSegmentLength(i);
            
            if (accumulatedLength + segmentLength >= targetLength) {
                // Point is on this segment
                const segmentT = (targetLength - accumulatedLength) / segmentLength;
                const p1 = this._vertices[i];
                const p2 = this._vertices[i + 1];
                
                return {
                    x: p1.x + (p2.x - p1.x) * segmentT,
                    y: p1.y + (p2.y - p1.y) * segmentT,
                    z: p1.z + (p2.z - p1.z) * segmentT
                };
            }
            
            accumulatedLength += segmentLength;
        }
        
        // Check closing segment
        if (this._isClosed && this._vertices.length > 2) {
            const closingLength = this.getClosingSegmentLength();
            const segmentT = (targetLength - accumulatedLength) / closingLength;
            const p1 = this._vertices[this._vertices.length - 1];
            const p2 = this._vertices[0];
            
            return {
                x: p1.x + (p2.x - p1.x) * segmentT,
                y: p1.y + (p2.y - p1.y) * segmentT,
                z: p1.z + (p2.z - p1.z) * segmentT
            };
        }
        
        // Return last vertex if t = 1
        return { ...this._vertices[this._vertices.length - 1] };
    }

    /**
     * Convert to JSON
     */
    public toJSON(): object {
        const baseJSON = super.toJSON();
        
        return {
            ...baseJSON,
            vertices: this._vertices.map(v => ({ ...v })),
            isClosed: this._isClosed,
            vertexCount: this._vertices.length,
            totalLength: this.getTotalLength(),
            area: this.getArea()
        };
    }

    /**
     * Restore from JSON
     */
    public fromJSON(data: any): void {
        super.fromJSON(data);
        
        if (data.vertices && Array.isArray(data.vertices)) {
            this._vertices = data.vertices.map((v: any) => ({
                x: v.x || 0,
                y: v.y || 0,
                z: v.z || 0
            }));
        }
        
        if (data.isClosed !== undefined) {
            this._isClosed = data.isClosed;
        }
        
        this._ocHandle = null;
    }

    /**
     * Create polyline from JSON
     */
    public static fromJSON(data: any): Polyline {
        const vertices = data.vertices || [
            { x: 0, y: 0, z: 0 },
            { x: 1, y: 0, z: 0 }
        ];
        
        const polyline = new Polyline(vertices, data.isClosed || false);
        polyline.fromJSON(data);
        return polyline;
    }

    // Getters and Setters
    
    public get vertices(): Point3D[] { 
        return this._vertices.map(v => ({ ...v })); 
    }
    
    public set vertices(value: Point3D[]) {
        if (value.length < 2) {
            throw new Error('Polyline must have at least 2 vertices');
        }
        this._vertices = value.map(v => ({ ...v }));
        this.updateOCShape();
        this.updateModifiedTime();
    }
    
    public get vertexCount(): number {
        return this._vertices.length;
    }
    
    public get isClosed(): boolean { 
        return this._isClosed; 
    }
    
    public set isClosed(value: boolean) {
        this._isClosed = value;
        this.updateOCShape();
        this.updateModifiedTime();
    }
}

==== FILE: src\models\Solid.ts ====

// src/models/Solid.ts
import { GeometricObject, GeometricObjectType } from './GeometricObject';
export class Solid extends GeometricObject {
    constructor() { super(GeometricObjectType.SOLID); }
    protected createOCShape(): any { return null; }
    protected updateOCShape(): void {}
    public getBounds(): any { return null; }
    public clone(): Solid { return new Solid(); }
}

==== FILE: src\models\Wall.ts ====

import { Vector3 } from 'three';

// Ù†Ù…ÙˆØ°Ø¬ ÙŠÙ…Ø«Ù„ Ø¬Ø¯Ø§Ø± ÙÙŠ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹
export class Wall {
    private _id: string;
    private _start: Vector3;
    private _end: Vector3;
    private _height: number;
    private _thickness: number;
    private _selected: boolean = false;
    private _highlighted: boolean = false;

    constructor(
        start: Vector3,
        end: Vector3,
        height: number = 3,
        thickness: number = 0.2
    ) {
        // ØªÙˆÙ„ÙŠØ¯ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„Ø¬Ø¯Ø§Ø±
        this._id = `wall_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this._start = start.clone();
        this._end = end.clone();
        this._height = height;
        this._thickness = thickness;
    }

    // Getters
    get id(): string { return this._id; }
    get start(): Vector3 { return this._start.clone(); }
    get end(): Vector3 { return this._end.clone(); }
    get height(): number { return this._height; }
    get thickness(): number { return this._thickness; }
    get selected(): boolean { return this._selected; }
    get highlighted(): boolean { return this._highlighted; }

    // Setters
    set selected(value: boolean) { this._selected = value; }
    set highlighted(value: boolean) { this._highlighted = value; }

    // Ø­Ø³Ø§Ø¨ Ø·ÙˆÙ„ Ø§Ù„Ø¬Ø¯Ø§Ø±
    get length(): number {
        return this._start.distanceTo(this._end);
    }

    // Ø­Ø³Ø§Ø¨ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯Ø§Ø± Ø¨Ø§Ù„Ø±Ø§Ø¯ÙŠØ§Ù†
    get angle(): number {
        return Math.atan2(
            this._end.y - this._start.y,
            this._end.x - this._start.x
        );
    }

    // Ø­Ø³Ø§Ø¨ Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯Ø§Ø± Ø¨Ø§Ù„Ø¯Ø±Ø¬Ø§Øª
    get angleDegrees(): number {
        return (this.angle * 180) / Math.PI;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ
    get midPoint(): Vector3 {
        return new Vector3().addVectors(this._start, this._end).multiplyScalar(0.5);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ØªØ¬Ù‡ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
    get direction(): Vector3 {
        return new Vector3()
            .subVectors(this._end, this._start)
            .normalize();
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ØªØ¬Ù‡ Ø¹Ù…ÙˆØ¯ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø±
    get normal(): Vector3 {
        const dir = this.direction;
        return new Vector3(-dir.y, dir.x, 0).normalize();
    }

    // ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    updateStart(point: Vector3): void {
        this._start = point.clone();
    }

    // ØªØ­Ø¯ÙŠØ« Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
    updateEnd(point: Vector3): void {
        this._end = point.clone();
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ‚Ø§Ø·Ø¹ Ø§Ù„Ø¬Ø¯Ø§Ø± Ù…Ø¹ Ù†Ù‚Ø·Ø© (Ù…Ø¹ Ù…Ø³Ø§ÙØ© ØªØ³Ø§Ù…Ø­)
    isPointNear(point: Vector3, tolerance: number = 0.5): boolean {
        const distToStart = point.distanceTo(this._start);
        const distToEnd = point.distanceTo(this._end);
        const wallLength = this.length;

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ù†Ù‡Ø§ÙŠØ©
        if (distToStart < tolerance || distToEnd < tolerance) {
            return true;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† Ø®Ø· Ø§Ù„Ø¬Ø¯Ø§Ø±
        const totalDist = distToStart + distToEnd;
        return Math.abs(totalDist - wallLength) < tolerance;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø¯Ø§Ø± Ù…Ù† Ù†Ù‚Ø·Ø© Ù…Ø¹ÙŠÙ†Ø©
    getClosestPoint(point: Vector3): Vector3 {
        const wallVector = new Vector3().subVectors(this._end, this._start);
        const pointVector = new Vector3().subVectors(point, this._start);
        
        const wallLengthSquared = wallVector.lengthSq();
        if (wallLengthSquared === 0) return this._start.clone();
        
        const t = Math.max(0, Math.min(1, pointVector.dot(wallVector) / wallLengthSquared));
        
        return new Vector3()
            .copy(this._start)
            .add(wallVector.multiplyScalar(t));
    }

    // Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø§Ù„Ø¬Ø¯Ø§Ø±
    clone(): Wall {
        const cloned = new Wall(this._start, this._end, this._height, this._thickness);
        cloned._selected = this._selected;
        cloned._highlighted = this._highlighted;
        return cloned;
    }

    // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ÙƒØ§Ø¦Ù† JSON
    toJSON(): object {
        return {
            id: this._id,
            start: { x: this._start.x, y: this._start.y, z: this._start.z },
            end: { x: this._end.x, y: this._end.y, z: this._end.z },
            height: this._height,
            thickness: this._thickness
        };
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù† ÙƒØ§Ø¦Ù† JSON
    static fromJSON(data: any): Wall {
        const start = new Vector3(data.start.x, data.start.y, data.start.z);
        const end = new Vector3(data.end.x, data.end.y, data.end.z);
        return new Wall(start, end, data.height, data.thickness);
    }
}

==== FILE: src\rendering\CameraControls.ts ====



==== FILE: src\rendering\MaterialManager.ts ====



==== FILE: src\rendering\SceneManager.ts ====



==== FILE: src\rendering\Viewer.ts ====

import {
    WebGLRenderer, Scene, PerspectiveCamera, OrthographicCamera,
    GridHelper, AxesHelper, AmbientLight, DirectionalLight,
    Vector3, Vector2, Raycaster, Color, Line as ThreeLine, BufferGeometry,
    MeshStandardMaterial, Mesh,
    TextureLoader, Object3D, Plane, Fog,
    BufferAttribute, LineBasicMaterial, Clock
} from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// Ø§Ù„ÙˆØ§Ø±Ø¯Ø§Øª Ù…Ù† Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
import { GeometryEngine, TessellationParams } from '../core/GeometryEngine';
import { Logger } from '../core/Logger';
import { GeometricObject } from '../models/GeometricObject';
import { Line } from '../models/Line';
import { Wall } from '../models/Wall';
import { Circle } from '../models/Circle';
import { SnapSystem } from '../systems/SnapSystem';
import { MeasurementSystem } from '../systems/MeasurementSystem';
import { Constants } from '../core/Constants';
import { CommandManager } from '../core/CommandManager';
import { BuildingElement } from '../models/BuildingElement';

// Ù†ÙˆØ¹ Ø¯Ø§Ù„Ø© Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹ Ù„Ù„Ø£Ø­Ø¯Ø§Ø«
type EventListener = (data: any) => void;

// ÙˆØ§Ø¬Ù‡Ø© Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£Ù‚Ø±Ø¨ Ø¬Ø¯Ø§Ø±
interface WallIntersection {
    wall: Wall;
    point: Vector3;
    distance: number;
}

export enum ViewMode {
    WIREFRAME = 'wireframe',
    SHADED = 'shaded',
    RENDERED = 'rendered',
    XRAY = 'xray'
}

export enum ViewOrientation {
    TOP = 'top',
    BOTTOM = 'bottom',
    FRONT = 'front',
    BACK = 'back',
    LEFT = 'left',
    RIGHT = 'right',
    ISOMETRIC = 'isometric'
}

// ÙˆØ§Ø¬Ù‡Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
export interface ViewSettings {
    showGrid: boolean;
    showAxes: boolean;
    showBoundingBoxes?: boolean;
    showNormals?: boolean;
    showWireframe?: boolean;
    enableShadows?: boolean;
    enableAntialiasing?: boolean;
    backgroundColor?: Color;
    ambientLightIntensity?: number;
    directionalLightIntensity?: number;
    gridSize?: number;
    gridDivisions?: number;
}

// ÙˆØ§Ø¬Ù‡Ø© Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
export interface PerformanceStats {
    fps: number;
    renderTime: number;
    triangleCount: number;
    drawCalls: number;
    memoryUsage: number;
    objectCount: number;
}

/**
 * Viewer - Ø§Ù„Ù…ÙƒÙˆÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ø¹Ø±Ø¶ ÙˆØ¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
 * 
 * Ù‡Ø°Ø§ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ø³Ø¤ÙˆÙ„ Ø¹Ù†:
 * - Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ© ÙÙŠ Ù…Ø´Ù‡Ø¯ Three.js
 * - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„Ù…Ø§ÙˆØ³ØŒ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­)
 * - Ø§Ù„ØªÙƒØ§Ù…Ù„ Ù…Ø¹ GeometryEngine Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø´ÙƒØ§Ù„
 * - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª ÙˆØ§Ù„Ø¥Ø¶Ø§Ø¡Ø© ÙˆØ§Ù„Ù…ÙˆØ§Ø¯
 */
export class Viewer {
    private container: HTMLElement;
    private renderer!: WebGLRenderer;
    private scene2D!: Scene;
    private scene3D!: Scene;
    private camera2D!: OrthographicCamera;
    private camera3D!: PerspectiveCamera;
    private controls2D!: OrbitControls;
    private controls3D!: OrbitControls;
    private is2D: boolean = true;
    
    // Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ ÙˆÙ†Ø¸Ø§Ù… Ø§Ù„ØªØ³Ø¬ÙŠÙ„
    private geometryEngine: GeometryEngine;
    private logger: Logger;
    
    // Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠØ©
    private geometricObjects: Map<string, GeometricObject> = new Map();
    // Ù†Ø³ØªØ®Ø¯Ù… Mesh Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Object3D Ù„Ø£Ù†Ù†Ø§ Ù†ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø®ØµØ§Ø¦Øµ geometry Ùˆ material
    private objectMeshes2D: Map<string, Mesh[]> = new Map();
    private objectMeshes3D: Map<string, Mesh> = new Map();
    
    // Ø¹Ù†Ø§ØµØ± Ø§Ù„Ø¨Ù†Ø§Ø¡ (Ø£Ø¨ÙˆØ§Ø¨ ÙˆÙ†ÙˆØ§ÙØ°)
    private buildingElements: Map<string, BuildingElement> = new Map();
    private elementMeshes2D: Map<string, Mesh> = new Map();
    private elementMeshes3D: Map<string, Mesh> = new Map();
    
    // Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ù…
    private isDrawing: boolean = false;
    private currentStartPoint: Vector3 | null = null;
    private previewLine: ThreeLine | null = null;
    
    // Ø£Ù†Ø¸Ù…Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©
    private commandManager: CommandManager = new CommandManager();
    private currentTool: 'line' | 'wall' | 'door' | 'window' = 'line';
    private snapSystem: SnapSystem | undefined;
    private measurementSystem!: MeasurementSystem;
    private raycaster: Raycaster = new Raycaster();
    private mouse: Vector2 = new Vector2();
    private intersectionPlane: Plane;
    
    // Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    private eventListeners: Map<string, EventListener[]> = new Map();
    
    // Ù…Ø­Ù…Ù„ Ø§Ù„Ù†Ø³ÙŠØ¬
    private textureLoader: TextureLoader = new TextureLoader();
    
    // Ø­Ø§Ù„Ø© Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
    private initialized: boolean = false;

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
    private viewSettings: ViewSettings = {
        showGrid: true,
        showAxes: true,
        showBoundingBoxes: false,
        showNormals: false,
        showWireframe: false,
        enableShadows: true,
        enableAntialiasing: true,
        backgroundColor: new Color(0xf5f5f5),
        ambientLightIntensity: 0.6,
        directionalLightIntensity: 0.4,
        gridSize: 50,
        gridDivisions: 50
    };

    // Ø¥Ø¶Ø§Ø¡Ø©
    private lights: {
        ambient?: AmbientLight;
        directional?: DirectionalLight;
    } = {};

    // Ø³Ø§Ø¹Ø© ÙˆØ¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
    private clock: Clock = new Clock();
    private performanceStats: PerformanceStats = {
        fps: 0,
        renderTime: 0,
        triangleCount: 0,
        drawCalls: 0,
        memoryUsage: 0,
        objectCount: 0
    };
    private frameCount: number = 0;
    private lastTime: number = 0;

    constructor(container: HTMLElement) {
        console.log('CORE VIEWER: Constructor called.');
        this.container = container;
        this.intersectionPlane = new Plane(new Vector3(0, 0, 1), 0);
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø«ÙŠÙ„Ø§Øª
        this.geometryEngine = GeometryEngine.getInstance();
        this.logger = Logger.getInstance();
        
        console.log('CORE VIEWER: Instance partially created, \'this\' is:', this);
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        this.initializeAsync();
    }

    /**
     * Ø§Ù„ØªÙ‡ÙŠØ¦Ø© ØºÙŠØ± Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø©
     * Ù†Ù†ØªØ¸Ø± ØªÙ‡ÙŠØ¦Ø© GeometryEngine Ù‚Ø¨Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
     */
    private async initializeAsync(): Promise<void> {
        try {
            console.log('CORE VIEWER: initializeAsync - START');
            this.logger.info('Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© Viewer...');
            
            // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø±Ùƒ Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ
            await this.geometryEngine.initialize();
            console.log('CORE VIEWER: initializeAsync - GeometryEngine initialized.');
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
            this.renderer = this.createRenderer();
            console.log('CORE VIEWER: initializeAsync - Renderer created.');
            
            this.scene2D = this.createScene2D();
            this.scene3D = this.createScene3D();
            console.log('CORE VIEWER: initializeAsync - Scenes created.');
            
            this.camera2D = this.createCamera2D();
            this.camera3D = this.createCamera3D();
            console.log('CORE VIEWER: initializeAsync - Cameras created. camera2D:', this.camera2D, 'camera3D:', this.camera3D);
            
            this.controls2D = this.createControls2D();
            this.controls3D = this.createControls3D();
            console.log('CORE VIEWER: initializeAsync - Controls created.');
            console.log('CORE VIEWER: initializeAsync - Lighting created.');
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
            this.snapSystem = new SnapSystem();
            this.measurementSystem = new MeasurementSystem(
                this.container,
                this.is2D ? this.camera2D : this.camera3D
            );
            
            console.log('CORE VIEWER: initializeAsync - Internal systems created.');
            
            // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø£ÙˆÙ„ÙŠ
            this.setup();
            this.animate();
            
            console.log('CORE VIEWER: initializeAsync - Setup methods called.');
            
            this.initialized = true;
            console.log('CORE VIEWER: initializeAsync - COMPLETING. \'initialized\' flag set to true. Instance \'this\':', this);
            console.log('CORE VIEWER: initializeAsync - typeof this.getCurrentCamera:', typeof this.getCurrentCamera);
            this.logger.info('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Viewer Ø¨Ù†Ø¬Ø§Ø­');
            
            // Ø¥Ø¶Ø§ÙØ© Ø¨Ø¹Ø¶ Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
            this.addTestShapes();
            
            console.log('CORE VIEWER: initializeAsync completed successfully.');
            
        } catch (error) {
            this.logger.error('ÙØ´Ù„Øª ØªÙ‡ÙŠØ¦Ø© Viewer:', error);
            throw error;
        }
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    private setup(): void {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø­Ø±Ùƒ Ù„Ù„Ø­Ø§ÙˆÙŠ
        this.container.appendChild(this.renderer.domElement);
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³
        this.setupMouseEvents();
        
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        this.setupKeyboardEvents();
        
        // Ø¥Ø¶Ø§ÙØ© Ø¹Ù†Ø§ØµØ± Ø§Ù„Ù…Ø´Ù‡Ø¯
        this.setupScenes();
        
        // Ù…Ø¹Ø§Ù„Ø¬ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        window.addEventListener('resize', this.onWindowResize.bind(this));
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø­Ø±Ùƒ
    private createRenderer(): WebGLRenderer {
        const renderer = new WebGLRenderer({ antialias: true });
        renderer.setSize(this.container.clientWidth, this.container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        return renderer;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ù‡Ø¯ 2D
    private createScene2D(): Scene {
        const scene = new Scene();
        scene.background = new Color(0xf5f5f5);
        return scene;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ù‡Ø¯ 3D
    private createScene3D(): Scene {
        const scene = new Scene();
        scene.background = new Color(0x222222);
        scene.fog = new Fog(0x222222, 50, 200);
        return scene;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ù…ÙŠØ±Ø§ 2D
    private createCamera2D(): OrthographicCamera {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        const frustumSize = Constants.CAMERA.FRUSTUM_SIZE_2D;
        const camera = new OrthographicCamera(
            -frustumSize * aspect / 2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            -frustumSize / 2,
            Constants.CAMERA.NEAR,
            Constants.CAMERA.FAR
        );
        camera.position.set(0, 0, 10);
        return camera;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ù…ÙŠØ±Ø§ 3D
    private createCamera3D(): PerspectiveCamera {
        const aspect = this.container.clientWidth / this.container.clientHeight;
        const camera = new PerspectiveCamera(
            Constants.CAMERA.FOV_3D,
            aspect,
            Constants.CAMERA.NEAR,
            Constants.CAMERA.FAR
        );
        camera.position.set(30, 30, 30);
        camera.lookAt(0, 0, 0);
        return camera;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… 2D
    private createControls2D(): OrbitControls {
        const controls = new OrbitControls(this.camera2D, this.renderer.domElement);
        controls.enableRotate = false;
        controls.enablePan = true;
        controls.panSpeed = Constants.CONTROLS.PAN_SPEED;
        controls.zoomSpeed = Constants.CONTROLS.ZOOM_SPEED;
        controls.update();
        return controls;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØªØ­ÙƒÙ… 3D
    private createControls3D(): OrbitControls {
        const controls = new OrbitControls(this.camera3D, this.renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = Constants.CONTROLS.DAMPING_FACTOR;
        controls.panSpeed = Constants.CONTROLS.PAN_SPEED;
        controls.zoomSpeed = Constants.CONTROLS.ZOOM_SPEED;
        controls.update();
        return controls;
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    private setupScenes(): void {
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø´Ø¨ÙƒØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ± Ù„ÙƒÙ„Ø§ Ø§Ù„Ù…Ø´Ù‡Ø¯ÙŠÙ†
        [this.scene2D, this.scene3D].forEach(scene => {
            // Ø´Ø¨ÙƒØ©
            const grid = new GridHelper(
                this.viewSettings.gridSize! * this.viewSettings.gridDivisions!,
                this.viewSettings.gridDivisions!,
                Constants.GRID.COLOR,
                Constants.GRID.COLOR
            );
            grid.name = 'gridHelper';
            
            if (scene === this.scene2D) {
                grid.rotation.x = Math.PI / 2;
            }
            
            scene.add(grid);
            
            // Ù…Ø­Ø§ÙˆØ±
            const axes = new AxesHelper(5);
            axes.name = 'axesHelper';
            scene.add(axes);
            
            // Ø¥Ø¶Ø§Ø¡Ø©
            this.lights.ambient = new AmbientLight(0xffffff, this.viewSettings.ambientLightIntensity);
            scene.add(this.lights.ambient);
            
            this.lights.directional = new DirectionalLight(0xffffff, this.viewSettings.directionalLightIntensity);
            this.lights.directional.position.set(10, 10, 10);
            this.lights.directional.castShadow = true;
            scene.add(this.lights.directional);
        });
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ Ù„Ù„Ù…Ø´Ù‡Ø¯
     * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø¨ÙŠÙ† GeometricObject Ùˆ Three.js
     */
    private async addGeometricObject(object: GeometricObject): Promise<void> {
        try {
            // Ø­ÙØ¸ Ø§Ù„ÙƒØ§Ø¦Ù†
            this.geometricObjects.set(object.id, object);
            
            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„ Ù…Ù† OpenCASCADE
            const ocHandle = object.getOCShape();
            
            // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø´Ø¨ÙƒØ© Ù…Ø«Ù„Ø«ÙŠØ©
            const tessellationParams: TessellationParams = {
                deflection: 0.1,
                angleDeflection: 0.5
            };
            
            const meshData = this.geometryEngine.tessellateShape(ocHandle, tessellationParams);
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ù†Ø¯Ø³Ø© Three.js
            const geometry = new BufferGeometry();
            geometry.setAttribute('position', new BufferAttribute(meshData.vertices, 3));
            geometry.setIndex(Array.from(meshData.indices));
            
            if (meshData.normals) {
                geometry.setAttribute('normal', new BufferAttribute(meshData.normals, 3));
            } else {
                geometry.computeVertexNormals();
            }
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙƒØ§Ø¦Ù†
            const visualProps = object.visualProperties;
            const material = new MeshStandardMaterial({
                color: visualProps.color,
                opacity: visualProps.opacity,
                transparent: visualProps.opacity < 1
            });
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø´Ø¨ÙƒØ©
            const mesh = new Mesh(geometry, material);
            mesh.userData.objectId = object.id;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ­ÙˆÙŠÙ„Ø§Øª
            const transform = object.transform;
            mesh.position.set(
                transform.translation.x,
                transform.translation.y,
                transform.translation.z
            );
            
            // Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…Ø´Ù‡Ø¯ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
            if (this.is2D) {
                this.scene2D.add(mesh);
                this.objectMeshes2D.set(object.id, [mesh]);
            } else {
                this.scene3D.add(mesh);
                this.objectMeshes3D.set(object.id, mesh);
            }
            
            this.logger.debug(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ Ù„Ù„Ù…Ø´Ù‡Ø¯: ${object.id}`);
            
            // Ø¥Ø±Ø³Ø§Ù„ Ø­Ø¯Ø«
            this.emit('objectAdded', object);
            
        } catch (error) {
            this.logger.error(`ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù‡Ù†Ø¯Ø³ÙŠ: ${object.id}`, error);
            throw error;
        }
    }

    /**
     * Ø¥Ø¶Ø§ÙØ© Ø£Ø´ÙƒØ§Ù„ Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©
     * Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ØªÙˆØ¶Ø­ ÙƒÙŠÙÙŠØ© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
     */
    private async addTestShapes(): Promise<void> {
        try {
            // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·ÙˆØ· Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©
            const line1 = new Line(
                { x: -10, y: -10, z: 0 },
                { x: 10, y: -10, z: 0 }
            );
            
            const line2 = new Line(
                { x: 10, y: -10, z: 0 },
                { x: 10, y: 10, z: 0 }
            );
            
            const line3 = new Line(
                { x: 10, y: 10, z: 0 },
                { x: -10, y: 10, z: 0 }
            );
            
            const line4 = new Line(
                { x: -10, y: 10, z: 0 },
                { x: -10, y: -10, z: 0 }
            );
            
            // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®Ø·ÙˆØ· Ù„Ù„Ù…Ø´Ù‡Ø¯
            await this.addGeometricObject(line1);
            await this.addGeometricObject(line2);
            await this.addGeometricObject(line3);
            await this.addGeometricObject(line4);
            
            this.logger.info('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©');
            
        } catch (error) {
            this.logger.error('ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±ÙŠØ©:', error);
        }
    }

    // Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©...
    
    private setupMouseEvents(): void {
        this.renderer.domElement.addEventListener('mousemove', this.onMouseMove.bind(this));
        this.renderer.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
        this.renderer.domElement.addEventListener('mouseup', this.onMouseUp.bind(this));
        this.renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    private setupKeyboardEvents(): void {
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isDrawing) {
                this.cancelDrawing();
            }
            
            if (e.key === 'Delete') {
                this.deleteSelectedObjects();
            }
        });
    }

    private onMouseMove(e: MouseEvent): void {
        this.updateMousePosition(e);
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆØ§Ù„ØªÙ…ÙŠÙŠØ²...
    }

    private onMouseDown(e: MouseEvent): void {
        if (e.button === 0 && this.is2D) {
            this.handleLeftClick();
        } else if (e.button === 2) {
            if (this.isDrawing) {
                this.cancelDrawing();
            } else {
                this.handleRightClick();
            }
        }
    }

    private onMouseUp(_e: MouseEvent): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø±ÙØ¹ Ø§Ù„Ù…Ø§ÙˆØ³
    }

    private handleLeftClick(): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø£ÙŠØ³Ø±
    }

    private handleRightClick(): void {
        // Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù†Ù‚Ø± Ø§Ù„Ø£ÙŠÙ…Ù†
    }

    private cancelDrawing(): void {
        this.isDrawing = false;
        this.currentStartPoint = null;
        
        if (this.previewLine) {
            this.scene2D.remove(this.previewLine);
            this.previewLine = null;
        }
    }

    private deleteSelectedObjects(): void {
        this.geometricObjects.forEach(obj => {
            if (obj.selected) {
                this.removeGeometricObject(obj.id);
            }
        });
    }

    private removeGeometricObject(objectId: string): void {
        const object = this.geometricObjects.get(objectId);
        if (!object) return;
        
        // Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        this.geometricObjects.delete(objectId);
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙ…Ø«ÙŠÙ„ Ø§Ù„Ù…Ø±Ø¦ÙŠ
        const meshes2D = this.objectMeshes2D.get(objectId);
        if (meshes2D) {
            meshes2D.forEach(mesh => {
                this.scene2D.remove(mesh);
                mesh.geometry.dispose();
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            });
            this.objectMeshes2D.delete(objectId);
        }
        
        const mesh3D = this.objectMeshes3D.get(objectId);
        if (mesh3D) {
            this.scene3D.remove(mesh3D);
            mesh3D.geometry.dispose();
            if (Array.isArray(mesh3D.material)) {
                mesh3D.material.forEach(m => m.dispose());
            } else {
                mesh3D.material.dispose();
            }
            this.objectMeshes3D.delete(objectId);
        }
        
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù†
        object.dispose();
        
        this.emit('objectRemoved', object);
    }

    private updateMousePosition(e: MouseEvent): void {
        const rect = this.renderer.domElement.getBoundingClientRect();
        this.mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        this.mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    }

    private animate(): void {
        requestAnimationFrame(this.animate.bind(this));
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        this.updatePerformanceStats();
        
        if (this.is2D) {
            this.controls2D.update();
        } else {
            this.controls3D.update();
        }
        
        this.render();
    }

    private render(): void {
        if (this.is2D) {
            this.renderer.render(this.scene2D, this.camera2D);
        } else {
            this.renderer.render(this.scene3D, this.camera3D);
        }
    }

    private onWindowResize(): void {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        const aspect = width / height;
        
        this.renderer.setSize(width, height);
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ 2D
        const frustumSize = Constants.CAMERA.FRUSTUM_SIZE_2D;
        this.camera2D.left = -frustumSize * aspect / 2;
        this.camera2D.right = frustumSize * aspect / 2;
        this.camera2D.top = frustumSize / 2;
        this.camera2D.bottom = -frustumSize / 2;
        this.camera2D.updateProjectionMatrix();
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ 3D
        this.camera3D.aspect = aspect;
        this.camera3D.updateProjectionMatrix();
        
        this.render();
    }

    // ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
    private updatePerformanceStats(): void {
        this.frameCount++;
        const currentTime = performance.now();
        
        if (currentTime >= this.lastTime + 1000) { // ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
            this.performanceStats.fps = this.frameCount;
            this.frameCount = 0;
            this.lastTime = currentTime;
            
            // ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
            this.performanceStats.renderTime = this.clock.getDelta() * 1000;
            this.performanceStats.objectCount = this.geometricObjects.size;
            
            if (this.renderer.info) {
                this.performanceStats.triangleCount = this.renderer.info.render.triangles;
                this.performanceStats.drawCalls = this.renderer.info.render.calls;
            }
            
            // Ø­Ø³Ø§Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© (ØªÙ‚Ø±ÙŠØ¨ÙŠ)
            if ((performance as any).memory) {
                this.performanceStats.memoryUsage = (performance as any).memory.usedJSHeapSize;
            }
        }
    }

    // Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
    public on(event: string, listener: EventListener): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event)!.push(listener);
    }

    public off(event: string, listener: EventListener): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
    }

    private emit(event: string, data: any): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.forEach(listener => listener(data));
        }
    }

    // Ø¯ÙˆØ§Ù„ Ø¹Ø§Ù…Ø©
    public setView(is2D: boolean): void {
        this.is2D = is2D;
        this.measurementSystem.updateCamera(is2D ? this.camera2D : this.camera3D);
        this.emit('viewChanged', is2D);
    }

    public setCurrentTool(tool: 'line' | 'wall' | 'door' | 'window'): void {
        this.currentTool = tool;
        this.cancelDrawing();
    }

    /**
     * ØªØ¹ÙŠÙŠÙ† Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø±Ø¶ Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§
     */
    public setViewOrientation(orientation: ViewOrientation): void {
        const distance = 50;
        let position: Vector3;
        let up = new Vector3(0, 1, 0);

        switch (orientation) {
            case ViewOrientation.TOP:
                position = new Vector3(0, distance, 0);
                up = new Vector3(0, 0, -1);
                break;
            case ViewOrientation.BOTTOM:
                position = new Vector3(0, -distance, 0);
                up = new Vector3(0, 0, 1);
                break;
            case ViewOrientation.FRONT:
                position = new Vector3(0, 0, distance);
                break;
            case ViewOrientation.BACK:
                position = new Vector3(0, 0, -distance);
                break;
            case ViewOrientation.LEFT:
                position = new Vector3(-distance, 0, 0);
                break;
            case ViewOrientation.RIGHT:
                position = new Vector3(distance, 0, 0);
                break;
            case ViewOrientation.ISOMETRIC:
                position = new Vector3(distance, distance, distance);
                break;
        }

        if (this.is2D && this.camera2D) {
            this.camera2D.position.copy(position);
            this.camera2D.up.copy(up);
            this.camera2D.lookAt(0, 0, 0);
            this.camera2D.updateProjectionMatrix();
            this.controls2D.update();
        } else if (!this.is2D && this.camera3D) {
            this.camera3D.position.copy(position);
            this.camera3D.up.copy(up);
            this.camera3D.lookAt(0, 0, 0);
            this.camera3D.updateProjectionMatrix();
            this.controls3D.update();
        }

        this.render();
        this.emit('viewOrientationChanged', orientation);
    }

    public isInitialized(): boolean {
        return this.initialized;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø­Ø§Ù„ÙŠØ©
     */
    public getCurrentCamera(): PerspectiveCamera | OrthographicCamera {
        return this.is2D ? this.camera2D : this.camera3D;
    }

    /**
     * Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡
     */
    public getPerformanceStats(): PerformanceStats {
        return { ...this.performanceStats };
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
     */
    public updateViewSettings(settings: Partial<ViewSettings>): void {
        Object.assign(this.viewSettings, settings);
        this.applyViewSettings();
    }

    /**
     * ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
     */
    private applyViewSettings(): void {
        // ØªØ·Ø¨ÙŠÙ‚ Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©
        if (this.viewSettings.backgroundColor) {
           this.scene2D.background = this.viewSettings.backgroundColor;
           this.scene3D.background = this.viewSettings.backgroundColor;
        }
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
        if (this.viewSettings.ambientLightIntensity !== undefined && this.lights.ambient) {
           this.lights.ambient.intensity = this.viewSettings.ambientLightIntensity;
        }
        
        if (this.viewSettings.directionalLightIntensity !== undefined && this.lights.directional) {
           this.lights.directional.intensity = this.viewSettings.directionalLightIntensity;
        }
        
        // ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¸Ù„Ø§Ù„
        if (this.viewSettings.enableShadows !== undefined) {
           this.renderer.shadowMap.enabled = this.viewSettings.enableShadows;
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´Ø¨ÙƒØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ±
        [this.scene2D, this.scene3D].forEach(scene => {
            const gridHelper = scene.getObjectByName('gridHelper');
            if (gridHelper && this.viewSettings.showGrid !== undefined) {
                gridHelper.visible = this.viewSettings.showGrid;
            }

            const axesHelper = scene.getObjectByName('axesHelper');
            if (axesHelper && this.viewSettings.showAxes !== undefined) {
                axesHelper.visible = this.viewSettings.showAxes;
            }
        });
        
        this.logger.debug('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶ Ø¶Ù…Ù† ÙˆØ­Ø¯Ø© Viewer.');
    }

    /**
     * Ø¥Ø²Ø§Ù„Ø© ÙƒØ§Ø¦Ù† Ù‡Ù†Ø¯Ø³ÙŠ (ÙˆØ§Ø¬Ù‡Ø© Ø¹Ø§Ù…Ø©)
     */
    public removeObject(objectId: string): void {
        this.removeGeometricObject(objectId);
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø±Ø¤ÙŠØ© ÙƒØ§Ø¦Ù†
     */
    public setObjectVisibility(objectId: string, visible: boolean): void {
        const meshes2D = this.objectMeshes2D.get(objectId);
        if (meshes2D) {
            meshes2D.forEach(mesh => {
                mesh.visible = visible;
            });
        }

        const mesh3D = this.objectMeshes3D.get(objectId);
        if (mesh3D) {
            mesh3D.visible = visible;
        }
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† ÙƒØ§Ø¦Ù†
     */
    public updateObjectColor(objectId: string, color: string): void {
        const meshes2D = this.objectMeshes2D.get(objectId);
        if (meshes2D) {
            meshes2D.forEach(mesh => {
                if (mesh.material instanceof MeshStandardMaterial) {
                    mesh.material.color.set(color);
                }
            });
        }

        const mesh3D = this.objectMeshes3D.get(objectId);
        if (mesh3D && mesh3D.material instanceof MeshStandardMaterial) {
            mesh3D.material.color.set(color);
        }
    }

    /**
     * ØªØ­Ø¯ÙŠØ« Ø´ÙØ§ÙÙŠØ© ÙƒØ§Ø¦Ù†
     */
    public updateObjectOpacity(objectId: string, opacity: number): void {
        const meshes2D = this.objectMeshes2D.get(objectId);
        if (meshes2D) {
            meshes2D.forEach(mesh => {
                if (mesh.material instanceof MeshStandardMaterial) {
                    mesh.material.opacity = opacity;
                    mesh.material.transparent = opacity < 1;
                }
            });
        }

        const mesh3D = this.objectMeshes3D.get(objectId);
        if (mesh3D && mesh3D.material instanceof MeshStandardMaterial) {
            mesh3D.material.opacity = opacity;
            mesh3D.material.transparent = opacity < 1;
        }
    }
}

==== FILE: src\styles\main.css ====

/* Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Segoe UI Emoji', sans-serif;
    overflow: hidden;
    background: #f0f0f0;
    direction: rtl;
}

/* Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    transition: opacity 0.3s ease;
}

.loading-container {
    text-align: center;
    color: white;
}

.loading-logo svg {
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.05); }
}

.loading-title {
    font-size: 2.5rem;
    margin: 1rem 0;
    font-weight: 300;
}

.loading-subtitle {
    font-size: 1.1rem;
    opacity: 0.9;
    margin-bottom: 2rem;
}

.loading-progress-container {
    width: 300px;
    height: 4px;
    background: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    overflow: hidden;
    margin: 0 auto;
}

.loading-progress {
    height: 100%;
    background: white;
    border-radius: 2px;
    transition: width 0.3s ease;
    width: 0%;
}

.loading-text {
    margin-top: 1rem;
    opacity: 0.8;
}

/* Ø­Ø§ÙˆÙŠ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ */
.app-container {
    width: 100%;
    height: 100vh;
    display: none;
    flex-direction: column;
    opacity: 0;
    transition: opacity 0.3s ease;
}

/* Ø­Ø§ÙˆÙŠ Ø§Ù„Ø¹Ø§Ø±Ø¶ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ */
.viewer-container {
    flex: 1;
    position: relative;
    overflow: hidden;
}

/* Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠ */
.toolbar {
    position: absolute;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 255, 255, 0.95);
    padding: 12px 16px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    display: flex;
    gap: 20px;
    z-index: 1000;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.toolbar-group {
    display: flex;
    gap: 8px;
    align-items: center;
    padding: 0 12px;
}

.toolbar-group:not(:last-child) {
    border-left: 1px solid #e0e0e0;
}

.toolbar-separator {
    width: 1px;
    height: 24px;
    background: #e0e0e0;
}

.toolbar-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border: none;
    border-radius: 8px;
    background: white;
    color: #333;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    white-space: nowrap;
    user-select: none;
}

.toolbar-btn:hover {
    background: #f8f9fa;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.toolbar-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.toolbar-btn.active {
    background: #2196F3;
    color: white;
    box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
}

.toolbar-btn.active:hover {
    background: #1976D2;
}

.toolbar-btn svg {
    stroke-width: 2;
    flex-shrink: 0;
}

.toolbar-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.toolbar-label {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #555;
    font-weight: 500;
}

.toolbar-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: #2196F3;
}

.toolbar-label select {
    padding: 6px 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: white;
    font-size: 14px;
    cursor: pointer;
    outline: none;
    transition: border-color 0.2s ease;
}

.toolbar-label select:focus {
    border-color: #2196F3;
    box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.1);
}

/* Ø§Ù„Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© */
.side-panels {
    position: absolute;
    top: 80px;
    right: 15px;
    width: 280px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    z-index: 900;
}

.panel {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    overflow: hidden;
    transition: transform 0.2s ease;
}

.panel:hover {
    transform: translateY(-2px);
}

.panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border-bottom: 1px solid #e0e0e0;
}

.panel-header h3 {
    font-size: 16px;
    font-weight: 600;
    color: #333;
    margin: 0;
}

.panel-btn {
    width: 32px;
    height: 32px;
    border: none;
    border-radius: 6px;
    background: #2196F3;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.panel-btn:hover {
    background: #1976D2;
    transform: scale(1.05);
}

.panel-content {
    padding: 20px;
    max-height: 300px;
    overflow-y: auto;
}

.panel-content::-webkit-scrollbar {
    width: 6px;
}

.panel-content::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

.panel-content::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

.panel-message {
    text-align: center;
    color: #666;
    font-style: italic;
    padding: 20px;
}

/* Ø´Ø±ÙŠØ· Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³ÙÙ„ÙŠ */
.status-bar {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 8px 16px;
    display: flex;
    gap: 24px;
    font-size: 12px;
    font-family: 'Courier New', monospace;
    z-index: 1000;
    backdrop-filter: blur(10px);
}

.status-item {
    opacity: 0.9;
    transition: opacity 0.2s ease;
}

.status-item:hover {
    opacity: 1;
}

/* ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª */
.dimension-label {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    color: #333;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    pointer-events: none;
    user-select: none;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 100;
    white-space: nowrap;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    transition: all 0.2s ease;
}

.dimension-label.preview {
    background: rgba(33, 150, 243, 0.95);
    color: white;
    border-color: rgba(33, 150, 243, 0.3);
}

/* Ø³Ø·Ø± Ø§Ù„Ø£ÙˆØ§Ù…Ø± */
.command-line {
    position: absolute;
    bottom: 40px;
    left: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
    font-family: 'Courier New', monospace;
    z-index: 1100;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.command-prompt {
    color: #4CAF50;
    font-weight: bold;
}

.command-input {
    flex: 1;
    background: transparent;
    border: none;
    color: white;
    font-family: inherit;
    font-size: 14px;
    outline: none;
    padding: 0;
}

.command-input::placeholder {
    color: #888;
}

/* Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª */
.toast-container {
    position: fixed;
    top: 100px;
    right: 20px;
    z-index: 10000;
    display: flex;
    flex-direction: column;
    gap: 10px;
    pointer-events: none;
}

.toast {
    background: white;
    color: #333;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    border-left: 4px solid #2196F3;
    max-width: 350px;
    transform: translateX(100%);
    animation: slideIn 0.3s ease forwards;
    pointer-events: auto;
    position: relative;
    backdrop-filter: blur(10px);
}

.toast.toast-success {
    border-left-color: #4CAF50;
}

.toast.toast-warning {
    border-left-color: #FF9800;
}

.toast.toast-error {
    border-left-color: #F44336;
}

.toast.toast-fade-out {
    animation: slideOut 0.3s ease forwards;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

@keyframes slideOut {
    from {
        transform: translateX(0);
        opacity: 1;
    }
    to {
        transform: translateX(100%);
        opacity: 0;
    }
}

/* Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© */
.help-message {
    position: absolute;
    top: 90px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(33, 150, 243, 0.95);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 999;
    animation: fadeInUp 0.3s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 20px rgba(33, 150, 243, 0.3);
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateX(-50%) translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }
}

/* Ø®Ø· Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© */
.preview-line {
    stroke: #2196F3;
    stroke-width: 2;
    stroke-dasharray: 8, 4;
    animation: dash 1s linear infinite;
    opacity: 0.8;
}

@keyframes dash {
    to {
        stroke-dashoffset: -12;
    }
}

/* Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø¹Ø±Ø¶ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ */
canvas {
    outline: none;
    display: block;
}

/* Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ù…Ø¤Ø´Ø± */
.drawing-mode {
    cursor: crosshair !important;
}

.moving-mode {
    cursor: move !important;
}

.selecting-mode {
    cursor: pointer !important;
}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© */
@media (max-width: 768px) {
    .toolbar {
        left: 10px;
        right: 10px;
        transform: none;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .toolbar-group {
        padding: 0 8px;
    }
    
    .toolbar-btn {
        padding: 8px 12px;
        font-size: 12px;
    }
    
    .side-panels {
        right: 10px;
        width: 260px;
    }
    
    .toast-container {
        right: 10px;
        left: 10px;
    }
    
    .toast {
        max-width: none;
    }
}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø£Ø¯Ø§Ø¡ */
.gpu-accelerated {
    transform: translateZ(0);
    will-change: transform;
}

/* Ø­Ø§Ù„Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
.loading {
    opacity: 0.7;
    pointer-events: none;
    position: relative;
}

.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #2196F3;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„ */
.toolbar-btn:focus,
.panel-btn:focus,
.command-input:focus {
    outline: 2px solid #2196F3;
    outline-offset: 2px;
}

/* ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© */
@media print {
    .toolbar,
    .side-panels,
    .status-bar,
    .command-line,
    .toast-container {
        display: none !important;
    }
    
    .viewer-container {
        width: 100% !important;
        height: 100% !important;
    }
}

==== FILE: src\systems\AreaCalculator.ts ====

import { Vector3 } from 'three';
import { Wall } from '../models/Wall';

export interface AreaInfo {
    area: number;
    perimeter: number;
    wallCount: number;
    isEnclosed: boolean;
}

export class AreaCalculator {
    
    // Ø­Ø³Ø§Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù…Ù† Ù…Ø¬Ù…ÙˆØ¹Ø© Ø¬Ø¯Ø±Ø§Ù†
    static calculateAreaInfo(walls: Wall[]): AreaInfo {
        if (walls.length < 3) {
            return { area: 0, perimeter: 0, wallCount: walls.length, isEnclosed: false };
        }

        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø­ÙŠØ·
        const perimeter = walls.reduce((sum, wall) => sum + wall.length, 0);

        // ÙØ­Øµ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† ØªØ´ÙƒÙ„ Ø´ÙƒÙ„ Ù…ØºÙ„Ù‚
        const isEnclosed = this.checkIfEnclosed(walls);

        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø´ÙƒÙ„ Ù…ØºÙ„Ù‚
        let area = 0;
        if (isEnclosed) {
            const points = this.getOrderedPoints(walls);
            area = this.calculatePolygonArea(points);
        }

        return { area, perimeter, wallCount: walls.length, isEnclosed };
    }

    // ÙØ­Øµ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† ØªØ´ÙƒÙ„ Ø´ÙƒÙ„ Ù…ØºÙ„Ù‚
    private static checkIfEnclosed(walls: Wall[]): boolean {
        if (walls.length < 3) return false;

        // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ù„Ù„Ù†Ù‚Ø§Ø· ÙˆØ¹Ø¯Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        const pointConnections = new Map<string, number>();

        walls.forEach(wall => {
            const startKey = this.pointToKey(wall.start);
            const endKey = this.pointToKey(wall.end);

            pointConnections.set(startKey, (pointConnections.get(startKey) || 0) + 1);
            pointConnections.set(endKey, (pointConnections.get(endKey) || 0) + 1);
        });

        // ÙÙŠ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù…ØºÙ„Ù‚ØŒ ÙƒÙ„ Ù†Ù‚Ø·Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…ØªØµÙ„Ø© Ø¨Ø¬Ø¯Ø§Ø±ÙŠÙ† Ø¨Ø§Ù„Ø¶Ø¨Ø·
        for (const connections of pointConnections.values()) {
            if (connections !== 2) return false;
        }

        return true;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ø±ØªØ¨Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø©
    private static getOrderedPoints(walls: Wall[]): Vector3[] {
        if (walls.length === 0) return [];

        const points: Vector3[] = [];
        const usedWalls = new Set<Wall>();
        const wallMap = new Map<string, Wall[]>();

        // Ø¨Ù†Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª
        walls.forEach(wall => {
            const startKey = this.pointToKey(wall.start);
            const endKey = this.pointToKey(wall.end);

            if (!wallMap.has(startKey)) wallMap.set(startKey, []);
            if (!wallMap.has(endKey)) wallMap.set(endKey, []);

            wallMap.get(startKey)!.push(wall);
            wallMap.get(endKey)!.push(wall);
        });

        // Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø£ÙˆÙ„ Ø¬Ø¯Ø§Ø±
        let currentWall = walls[0];
        let currentPoint = currentWall.start;
        points.push(currentPoint);
        usedWalls.add(currentWall);

        // ØªØªØ¨Ø¹ Ø§Ù„Ø¬Ø¯Ø±Ø§Ù† Ù„Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¶Ù„Ø¹
        while (usedWalls.size < walls.length) {
            const nextPoint = currentWall.start.equals(currentPoint) ? currentWall.end : currentWall.start;
            points.push(nextPoint);

            const nextPointKey = this.pointToKey(nextPoint);
            const connectedWalls = wallMap.get(nextPointKey) || [];
            
            const nextWall = connectedWalls.find(w => !usedWalls.has(w));
            if (!nextWall) break;

            currentWall = nextWall;
            currentPoint = nextPoint;
            usedWalls.add(currentWall);
        }

        return points;
    }

    // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø¶Ù„Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ØµÙŠØºØ© Shoelace
    private static calculatePolygonArea(points: Vector3[]): number {
        if (points.length < 3) return 0;

        let area = 0;
        const n = points.length;

        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
        }

        return Math.abs(area) / 2;
    }

    // ØªØ­ÙˆÙŠÙ„ Ù†Ù‚Ø·Ø© Ø¥Ù„Ù‰ Ù…ÙØªØ§Ø­ Ù†ØµÙŠ Ù„Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
    private static pointToKey(point: Vector3): string {
        const precision = 3; // Ø¯Ù‚Ø© Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©
        return `${point.x.toFixed(precision)},${point.y.toFixed(precision)}`;
    }

    // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù„Ù„Ø¹Ø±Ø¶
    static formatArea(area: number): string {
        return `${area.toFixed(2)} mÂ²`;
    }

    // ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ø­ÙŠØ· Ù„Ù„Ø¹Ø±Ø¶
    static formatPerimeter(perimeter: number): string {
        return `${perimeter.toFixed(2)} m`;
    }
}

==== FILE: src\systems\AreaPerimeterSystem.ts ====



==== FILE: src\systems\ConstraintSystem.ts ====



==== FILE: src\systems\DimensioningSystem.ts ====



==== FILE: src\systems\HistorySystem.ts ====



==== FILE: src\systems\LayerSystem.ts ====



==== FILE: src\systems\MeasurementSystem.ts ====

/**
 * MeasurementSystem - Dynamic measurement and dimension display system
 */

import { Vector3, Camera, Scene, Group, Line as ThreeLine, BufferGeometry, LineBasicMaterial, Sprite, SpriteMaterial, CanvasTexture } from 'three';
import { CSS2DRenderer, CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer.js';
import { Logger } from '../core/Logger';

// Dimension types
export enum DimensionType {
    LINEAR = 'linear',
    ANGULAR = 'angular',
    RADIAL = 'radial',
    DIAMETER = 'diameter',
    AREA = 'area',
    VOLUME = 'volume'
}

// Dimension style
export interface DimensionStyle {
    color: string;
    fontSize: number;
    fontFamily: string;
    lineWidth: number;
    arrowSize: number;
    textOffset: number;
    precision: number;
    unit: 'mm' | 'cm' | 'm' | 'ft' | 'in';
    showUnit: boolean;
}

// Dimension data
export interface DimensionData {
    id: string;
    type: DimensionType;
    points: Vector3[];
    value: number;
    text: string;
    visible: boolean;
    temporary: boolean;
    style?: Partial<DimensionStyle>;
}

/**
 * Measurement System class
 */
export class MeasurementSystem {
    private container: HTMLElement;
    private camera: Camera;
    private scene: Scene;
    private dimensionGroup: Group;
    private css2DRenderer!: CSS2DRenderer;
    private logger: Logger;
    
    // Dimensions
    private dimensions: Map<string, DimensionData> = new Map();
    private dimensionObjects: Map<string, Group> = new Map();
    
    // Preview dimension
    private previewDimension: DimensionData | null = null;
    private previewObject: Group | null = null;
    
    // Default style
    private defaultStyle: DimensionStyle = {
        color: '#000000',
        fontSize: 14,
        fontFamily: 'Arial',
        lineWidth: 1,
        arrowSize: 10,
        textOffset: 20,
        precision: 2,
        unit: 'm',
        showUnit: true
    };

    constructor(container: HTMLElement, camera: Camera) {
        this.container = container;
        this.camera = camera;
        this.scene = new Scene();
        this.dimensionGroup = new Group();
        this.dimensionGroup.name = 'dimensions';
        this.logger = Logger.getInstance();

        // Ensure the dimension objects are part of the scene rendered by CSS2DRenderer
        this.scene.add(this.dimensionGroup);
        
        this.setupCSS2DRenderer();
    }

    /**
     * Setup CSS2D renderer for labels
     */
    private setupCSS2DRenderer(): void {
        this.css2DRenderer = new CSS2DRenderer();
        this.css2DRenderer.setSize(this.container.clientWidth, this.container.clientHeight);
        this.css2DRenderer.domElement.style.position = 'absolute';
        this.css2DRenderer.domElement.style.top = '0';
        this.css2DRenderer.domElement.style.pointerEvents = 'none';
        this.container.appendChild(this.css2DRenderer.domElement);
    }

    /**
     * Update camera
     */
    public updateCamera(camera: Camera): void {
        this.camera = camera;
    }

    /**
     * Add linear dimension
     */
    public addLinearDimension(
        point1: Vector3,
        point2: Vector3,
        offset: number = 20,
        style?: Partial<DimensionStyle>
    ): string {
        const id = this.generateId();
        const distance = point1.distanceTo(point2);
        
        const dimension: DimensionData = {
            id,
            type: DimensionType.LINEAR,
            points: [point1.clone(), point2.clone()],
            value: distance,
            text: this.formatLength(distance, style),
            visible: true,
            temporary: false,
            style
        };
        
        this.dimensions.set(id, dimension);
        this.createDimensionObject(dimension);
        
        return id;
    }

    /**
     * Add angular dimension
     */
    public addAngularDimension(
        center: Vector3,
        start: Vector3,
        end: Vector3,
        radius: number = 50,
        style?: Partial<DimensionStyle>
    ): string {
        const id = this.generateId();
        
        // Calculate angle
        const startAngle = Math.atan2(start.y - center.y, start.x - center.x);
        const endAngle = Math.atan2(end.y - center.y, end.x - center.x);
        let angle = endAngle - startAngle;
        if (angle < 0) angle += 2 * Math.PI;
        
        const angleDegrees = angle * 180 / Math.PI;
        
        const dimension: DimensionData = {
            id,
            type: DimensionType.ANGULAR,
            points: [center.clone(), start.clone(), end.clone()],
            value: angleDegrees,
            text: `${angleDegrees.toFixed(1)}Â°`,
            visible: true,
            temporary: false,
            style
        };
        
        this.dimensions.set(id, dimension);
        this.createDimensionObject(dimension);
        
        return id;
    }

    /**
     * Show preview dimension
     */
    public showPreviewDimension(point1: Vector3, point2: Vector3): void {
        this.hidePreviewDimension();
        
        const distance = point1.distanceTo(point2);
        
        this.previewDimension = {
            id: 'preview',
            type: DimensionType.LINEAR,
            points: [point1.clone(), point2.clone()],
            value: distance,
            text: this.formatLength(distance),
            visible: true,
            temporary: true
        };
        
        this.previewObject = this.createLinearDimensionObject(this.previewDimension);
        this.dimensionGroup.add(this.previewObject);
    }

    /**
     * Hide preview dimension
     */
    public hidePreviewDimension(): void {
        if (this.previewObject) {
            this.dimensionGroup.remove(this.previewObject);
            this.disposeGroup(this.previewObject);
            this.previewObject = null;
            this.previewDimension = null;
        }
    }

    /**
     * Create dimension object
     */
    private createDimensionObject(dimension: DimensionData): void {
        let object: Group;
        
        switch (dimension.type) {
            case DimensionType.LINEAR:
                object = this.createLinearDimensionObject(dimension);
                break;
            case DimensionType.ANGULAR:
                object = this.createAngularDimensionObject(dimension);
                break;
            default:
                return;
        }
        
        this.dimensionObjects.set(dimension.id, object);
        this.dimensionGroup.add(object);
    }

    /**
     * Create linear dimension object
     */
    private createLinearDimensionObject(dimension: DimensionData): Group {
        const group = new Group();
        const style = { ...this.defaultStyle, ...dimension.style };
        
        const [p1, p2] = dimension.points;
        const direction = new Vector3().subVectors(p2, p1).normalize();
        const perpendicular = new Vector3(-direction.y, direction.x, 0).normalize();
        const offset = style.textOffset;
        
        // Offset points
        const offsetP1 = p1.clone().add(perpendicular.clone().multiplyScalar(offset));
        const offsetP2 = p2.clone().add(perpendicular.clone().multiplyScalar(offset));
        
        // Extension lines
        const ext1Geometry = new BufferGeometry().setFromPoints([p1, offsetP1]);
        const ext2Geometry = new BufferGeometry().setFromPoints([p2, offsetP2]);
        
        const lineMaterial = new LineBasicMaterial({
            color: style.color,
            linewidth: style.lineWidth
        });
        
        const ext1 = new ThreeLine(ext1Geometry, lineMaterial);
        const ext2 = new ThreeLine(ext2Geometry, lineMaterial);
        
        group.add(ext1, ext2);
        
        // Dimension line
        const dimGeometry = new BufferGeometry().setFromPoints([offsetP1, offsetP2]);
        const dimLine = new ThreeLine(dimGeometry, lineMaterial);
        group.add(dimLine);
        
        // Arrows
        this.addArrows(group, offsetP1, offsetP2, direction, style);
        
        // Text label
        const midPoint = new Vector3().addVectors(offsetP1, offsetP2).multiplyScalar(0.5);
        this.addTextLabel(group, dimension.text, midPoint, style);
        
        return group;
    }

    /**
     * Create angular dimension object
     */
    private createAngularDimensionObject(dimension: DimensionData): Group {
        const group = new Group();
        const style = { ...this.defaultStyle, ...dimension.style };
        
        const [center, start, end] = dimension.points;
        const radius = style.textOffset * 2;
        
        // Calculate angles
        const startAngle = Math.atan2(start.y - center.y, start.x - center.x);
        const endAngle = Math.atan2(end.y - center.y, end.x - center.x);
        
        // Create arc
        const arcPoints: Vector3[] = [];
        const segments = 32;
        let angle = startAngle;
        const angleStep = (endAngle - startAngle) / segments;
        
        for (let i = 0; i <= segments; i++) {
            const x = center.x + radius * Math.cos(angle);
            const y = center.y + radius * Math.sin(angle);
            arcPoints.push(new Vector3(x, y, center.z));
            angle += angleStep;
        }
        
        const arcGeometry = new BufferGeometry().setFromPoints(arcPoints);
        const arcMaterial = new LineBasicMaterial({
            color: style.color,
            linewidth: style.lineWidth
        });
        
        const arc = new ThreeLine(arcGeometry, arcMaterial);
        group.add(arc);
        
        // Extension lines
        const ext1Start = center.clone();
        const ext1End = new Vector3(
            center.x + radius * Math.cos(startAngle),
            center.y + radius * Math.sin(startAngle),
            center.z
        );
        
        const ext2Start = center.clone();
        const ext2End = new Vector3(
            center.x + radius * Math.cos(endAngle),
            center.y + radius * Math.sin(endAngle),
            center.z
        );
        
        const ext1Geometry = new BufferGeometry().setFromPoints([ext1Start, ext1End]);
        const ext2Geometry = new BufferGeometry().setFromPoints([ext2Start, ext2End]);
        
        const ext1 = new ThreeLine(ext1Geometry, arcMaterial);
        const ext2 = new ThreeLine(ext2Geometry, arcMaterial);
        
        group.add(ext1, ext2);
        
        // Text label
        const midAngle = (startAngle + endAngle) / 2;
        const textPosition = new Vector3(
            center.x + radius * Math.cos(midAngle),
            center.y + radius * Math.sin(midAngle),
            center.z
        );
        
        this.addTextLabel(group, dimension.text, textPosition, style);
        
        return group;
    }

    /**
     * Add arrows to dimension line
     */
    private addArrows(
        group: Group,
        start: Vector3,
        end: Vector3,
        direction: Vector3,
        style: DimensionStyle
    ): void {
        const arrowSize = style.arrowSize;
        const arrowAngle = Math.PI / 6; // 30 degrees
        
        // Start arrow
        const arrow1Dir1 = direction.clone().applyAxisAngle(new Vector3(0, 0, 1), arrowAngle);
        const arrow1Dir2 = direction.clone().applyAxisAngle(new Vector3(0, 0, 1), -arrowAngle);
        
        const arrow1Points = [
            start.clone().add(arrow1Dir1.clone().multiplyScalar(arrowSize)),
            start,
            start.clone().add(arrow1Dir2.clone().multiplyScalar(arrowSize))
        ];
        
        // End arrow
        const arrow2Dir1 = direction.clone().negate().applyAxisAngle(new Vector3(0, 0, 1), arrowAngle);
        const arrow2Dir2 = direction.clone().negate().applyAxisAngle(new Vector3(0, 0, 1), -arrowAngle);
        
        const arrow2Points = [
            end.clone().add(arrow2Dir1.clone().multiplyScalar(arrowSize)),
            end,
            end.clone().add(arrow2Dir2.clone().multiplyScalar(arrowSize))
        ];
        
        const material = new LineBasicMaterial({
            color: style.color,
            linewidth: style.lineWidth
        });
        
        const arrow1Geometry = new BufferGeometry().setFromPoints(arrow1Points);
        const arrow2Geometry = new BufferGeometry().setFromPoints(arrow2Points);
        
        const arrow1 = new ThreeLine(arrow1Geometry, material);
        const arrow2 = new ThreeLine(arrow2Geometry, material);
        
        group.add(arrow1, arrow2);
    }

    /**
     * Add text label
     */
    private addTextLabel(
        group: Group,
        text: string,
        position: Vector3,
        style: DimensionStyle
    ): void {
        // Create HTML element
        const labelDiv = document.createElement('div');
        labelDiv.className = 'dimension-label';
        labelDiv.textContent = text;
        labelDiv.style.color = style.color;
        labelDiv.style.fontSize = `${style.fontSize}px`;
        labelDiv.style.fontFamily = style.fontFamily;
        labelDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        labelDiv.style.padding = '2px 4px';
        labelDiv.style.borderRadius = '2px';
        labelDiv.style.whiteSpace = 'nowrap';
        
        const label = new CSS2DObject(labelDiv);
        label.position.copy(position);
        group.add(label);
    }

    /**
     * Format length
     */
    private formatLength(length: number, style?: Partial<DimensionStyle>): string {
        const s = { ...this.defaultStyle, ...style };
        let value: number;
        let unit: string = '';
        
        switch (s.unit) {
            case 'mm':
                value = length * 1000;
                unit = 'mm';
                break;
            case 'cm':
                value = length * 100;
                unit = 'cm';
                break;
            case 'm':
                value = length;
                unit = 'm';
                break;
            case 'ft':
                value = length * 3.28084;
                unit = 'ft';
                break;
            case 'in':
                value = length * 39.3701;
                unit = 'in';
                break;
            default:
                value = length;
                unit = 'm';
        }
        
        const formatted = value.toFixed(s.precision);
        return s.showUnit ? `${formatted} ${unit}` : formatted;
    }

    /**
     * Update all dimensions
     */
    public updateAllDimensions(): void {
        // Update visibility based on camera
        // Could implement LOD or occlusion here
    }

    /**
     * Remove dimension
     */
    public removeDimension(id: string): void {
        const dimension = this.dimensions.get(id);
        const object = this.dimensionObjects.get(id);
        
        if (dimension && object) {
            this.dimensions.delete(id);
            this.dimensionObjects.delete(id);
            this.dimensionGroup.remove(object);
            this.disposeGroup(object);
        }
    }

    /**
     * Clear all dimensions
     */
    public clearAllDimensions(): void {
        this.dimensions.forEach((dimension, id) => {
            this.removeDimension(id);
        });
    }

    /**
     * Set dimension visibility
     */
    public setDimensionVisibility(id: string, visible: boolean): void {
        const dimension = this.dimensions.get(id);
        const object = this.dimensionObjects.get(id);
        
        if (dimension && object) {
            dimension.visible = visible;
            object.visible = visible;
        }
    }

    /**
     * Update style
     */
    public updateDefaultStyle(style: Partial<DimensionStyle>): void {
        Object.assign(this.defaultStyle, style);
    }

    /**
     * Render dimensions
            this.css2DRenderer.render(this.scene, this.camera);
    public render(): void {
        if (this.css2DRenderer && this.camera) {
            this.css2DRenderer.render(this.dimensionGroup, this.camera);
        }
    }

    /**
     * Resize handler
     */
    public onResize(width: number, height: number): void {
        if (this.css2DRenderer) {
            this.css2DRenderer.setSize(width, height);
        }
    }

    /**
     * Generate unique ID
     */
    private generateId(): string {
        return `dim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    /**
     * Dispose group and its children
     */
    private disposeGroup(group: Group): void {
        group.traverse((child) => {
            if (child instanceof ThreeLine) {
                child.geometry.dispose();
                if (child.material instanceof LineBasicMaterial) {
                    child.material.dispose();
                }
            }
        });
        
        // Remove CSS2D objects
        const css2DObjects: CSS2DObject[] = [];
        group.traverse((child) => {
            if (child instanceof CSS2DObject) {
                css2DObjects.push(child);
            }
        });
        
        css2DObjects.forEach(obj => {
            group.remove(obj);
            obj.element.remove();
        });
    }

    /**
     * Get dimension group for adding to scene
     */
    public getDimensionGroup(): Group {
        return this.dimensionGroup;
    }

    /**
     * Dispose
     */
    public dispose(): void {
        this.clearAllDimensions();
        this.hidePreviewDimension();
        
        if (this.css2DRenderer) {
            this.css2DRenderer.domElement.remove();
        }
    }
}

==== FILE: src\systems\SelectionSystem.ts ====



==== FILE: src\systems\SnapSystem.ts ====

/**
 * SnapSystem - Advanced Geometric Snapping System
 * Provides precise snapping to geometric features
 */

import { Vector3 } from 'three';
import { GeometryEngine, Point3D } from '../core/GeometryEngine';
import { GeometricObject } from '../models/GeometricObject';
import { Line } from '../models/Line';
import { Circle } from '../models/Circle';
import { Arc } from '../models/Arc';
import { Polyline } from '../models/Polyline';
import { Constants } from '../core/Constants';
import { Logger } from '../core/Logger';

// Snap result
export interface SnapResult {
    point: Vector3;          // The snapped point
    snapped: boolean;        // Whether snapping occurred
    type?: SnapType;         // Type of snap
    target?: GeometricObject; // Target object snapped to
    feature?: string;        // Specific feature (e.g., "endpoint", "center")
    distance?: number;       // Distance from original point
}

// Snap types
export enum SnapType {
    GRID = 'grid',                   // Grid snap
    ENDPOINT = 'endpoint',           // Line/arc endpoints
    MIDPOINT = 'midpoint',           // Midpoints
    CENTER = 'center',               // Circle/arc centers
    INTERSECTION = 'intersection',   // Intersections
    PERPENDICULAR = 'perpendicular', // Perpendicular points
    TANGENT = 'tangent',             // Tangent points
    NEAREST = 'nearest',             // Nearest point on curve
    QUADRANT = 'quadrant',           // Circle quadrants
    NODE = 'node',                   // Polyline nodes
    EXTENSION = 'extension',         // Line extensions
    PARALLEL = 'parallel',           // Parallel lines
    ANGLE = 'angle'                  // Angle snap
}

// Snap settings
export interface SnapSettings {
    gridEnabled: boolean;
    gridSize: number;
    endpointEnabled: boolean;
    midpointEnabled: boolean;
    centerEnabled: boolean;
    intersectionEnabled: boolean;
    perpendicularEnabled: boolean;
    tangentEnabled: boolean;
    nearestEnabled: boolean;
    quadrantEnabled: boolean;
    nodeEnabled: boolean;
    extensionEnabled: boolean;
    angleEnabled: boolean;
    snapDistance: number;
    angleIncrement: number;
}

// Snap candidate
interface SnapCandidate {
    point: Vector3;
    type: SnapType;
    target?: GeometricObject;
    feature?: string;
    distance: number;
    priority: number;
}

/**
 * Advanced Snap System
 */
export class SnapSystem {
    private geometryEngine: GeometryEngine;
    private logger: Logger;
    
    // Settings
    private settings: SnapSettings;
    
    // Cache for performance
    private snapCache: Map<string, SnapCandidate[]> = new Map();
    private cacheTimeout: number = 100; // ms
    private lastCacheTime: number = 0;

    constructor() {
        this.geometryEngine = GeometryEngine.getInstance();
        this.logger = Logger.getInstance();
        
        // Default settings
        this.settings = {
            gridEnabled: true,
            gridSize: Constants.GRID.DEFAULT_SIZE,
            endpointEnabled: true,
            midpointEnabled: true,
            centerEnabled: true,
            intersectionEnabled: true,
            perpendicularEnabled: true,
            tangentEnabled: true,
            nearestEnabled: true,
            quadrantEnabled: true,
            nodeEnabled: true,
            extensionEnabled: false,
            angleEnabled: true,
            snapDistance: Constants.SNAP.ENDPOINT_SNAP_DISTANCE,
            angleIncrement: 15 // degrees
        };
    }

    /**
     * Main snap function
     */
    public snap(
        point: Vector3,
        objects: GeometricObject[] = [],
        referencePoint?: Vector3,
        activeObject?: GeometricObject
    ): SnapResult {
        const candidates: SnapCandidate[] = [];
        
        // Clear cache if expired
        if (Date.now() - this.lastCacheTime > this.cacheTimeout) {
            this.snapCache.clear();
        }
        
        // Collect all snap candidates
        this.collectSnapCandidates(point, objects, referencePoint, activeObject, candidates);
        
        // Sort by priority and distance
        candidates.sort((a, b) => {
            if (a.priority !== b.priority) {
                return b.priority - a.priority; // Higher priority first
            }
            return a.distance - b.distance; // Closer distance first
        });
        
        // Return best candidate or grid snap
        if (candidates.length > 0 && candidates[0].distance < this.settings.snapDistance) {
            const best = candidates[0];
            return {
                point: best.point,
                snapped: true,
                type: best.type,
                target: best.target,
                feature: best.feature,
                distance: best.distance
            };
        }
        
        // Grid snap as fallback
        if (this.settings.gridEnabled) {
            return this.snapToGrid(point);
        }
        
        return {
            point: point.clone(),
            snapped: false
        };
    }

    /**
     * Collect all snap candidates
     */
    private collectSnapCandidates(
        point: Vector3,
        objects: GeometricObject[],
        referencePoint: Vector3 | undefined,
        activeObject: GeometricObject | undefined,
        candidates: SnapCandidate[]
    ): void {
        // Object snaps
        objects.forEach(object => {
            if (object === activeObject) return; // Skip active object
            
            // Get candidates for this object
            const objectCandidates = this.getObjectSnapCandidates(point, object);
            candidates.push(...objectCandidates);
        });
        
        // Angle snaps (if drawing from reference point)
        if (referencePoint && this.settings.angleEnabled) {
            const angleSnaps = this.getAngleSnapCandidates(point, referencePoint);
            candidates.push(...angleSnaps);
        }
        
        // Grid snap (lowest priority)
        if (this.settings.gridEnabled) {
            const gridSnap = this.getGridSnapCandidate(point);
            candidates.push(gridSnap);
        }
    }

    /**
     * Get snap candidates for a specific object
     */
    private getObjectSnapCandidates(point: Vector3, object: GeometricObject): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        
        if (object instanceof Line) {
            candidates.push(...this.getLineSnapCandidates(point, object));
        } else if (object instanceof Circle) {
            candidates.push(...this.getCircleSnapCandidates(point, object));
        } else if (object instanceof Arc) {
            candidates.push(...this.getArcSnapCandidates(point, object));
        } else if (object instanceof Polyline) {
            candidates.push(...this.getPolylineSnapCandidates(point, object));
        }
        
        return candidates;
    }

    /**
     * Get line snap candidates
     */
    private getLineSnapCandidates(point: Vector3, line: Line): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        
        // Endpoints
        if (this.settings.endpointEnabled) {
            const start = new Vector3(line.startPoint.x, line.startPoint.y, line.startPoint.z);
            const end = new Vector3(line.endPoint.x, line.endPoint.y, line.endPoint.z);
            
            candidates.push({
                point: start,
                type: SnapType.ENDPOINT,
                target: line,
                feature: 'start',
                distance: point.distanceTo(start),
                priority: 10
            });
            
            candidates.push({
                point: end,
                type: SnapType.ENDPOINT,
                target: line,
                feature: 'end',
                distance: point.distanceTo(end),
                priority: 10
            });
        }
        
        // Midpoint
        if (this.settings.midpointEnabled) {
            const mid = line.getMidPoint();
            const midVec = new Vector3(mid.x, mid.y, mid.z);
            
            candidates.push({
                point: midVec,
                type: SnapType.MIDPOINT,
                target: line,
                feature: 'midpoint',
                distance: point.distanceTo(midVec),
                priority: 8
            });
        }
        
        // Nearest point
        if (this.settings.nearestEnabled) {
            const nearest = line.getClosestPoint({
                x: point.x,
                y: point.y,
                z: point.z
            });
            const nearestVec = new Vector3(nearest.x, nearest.y, nearest.z);
            
            // Only add if not too close to endpoints or midpoint
            const minDistToOthers = 0.1;
            let tooClose = false;
            
            candidates.forEach(c => {
                if (nearestVec.distanceTo(c.point) < minDistToOthers) {
                    tooClose = true;
                }
            });
            
            if (!tooClose) {
                candidates.push({
                    point: nearestVec,
                    type: SnapType.NEAREST,
                    target: line,
                    feature: 'nearest',
                    distance: point.distanceTo(nearestVec),
                    priority: 5
                });
            }
        }
        
        // Extension (if enabled)
        if (this.settings.extensionEnabled) {
            const direction = line.getDirection();
            const start = new Vector3(line.startPoint.x, line.startPoint.y, line.startPoint.z);
            const end = new Vector3(line.endPoint.x, line.endPoint.y, line.endPoint.z);
            
            // Project point onto line extension
            const toPoint = point.clone().sub(start);
            const lineDir = new Vector3(direction.x, direction.y, direction.z);
            const t = toPoint.dot(lineDir);
            
            if (t < 0 || t > line.getLength()) {
                const extensionPoint = start.clone().add(lineDir.multiplyScalar(t));
                
                candidates.push({
                    point: extensionPoint,
                    type: SnapType.EXTENSION,
                    target: line,
                    feature: 'extension',
                    distance: point.distanceTo(extensionPoint),
                    priority: 3
                });
            }
        }
        
        return candidates;
    }

    /**
     * Get circle snap candidates
     */
    private getCircleSnapCandidates(point: Vector3, circle: Circle): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        const center = new Vector3(circle.center.x, circle.center.y, circle.center.z);
        
        // Center
        if (this.settings.centerEnabled) {
            candidates.push({
                point: center,
                type: SnapType.CENTER,
                target: circle,
                feature: 'center',
                distance: point.distanceTo(center),
                priority: 10
            });
        }
        
        // Quadrants
        if (this.settings.quadrantEnabled) {
            const quadrants = [
                { angle: 0, name: 'right' },
                { angle: Math.PI / 2, name: 'top' },
                { angle: Math.PI, name: 'left' },
                { angle: 3 * Math.PI / 2, name: 'bottom' }
            ];
            
            quadrants.forEach(q => {
                const qPoint = circle.getPointAtAngle(q.angle);
                const qVec = new Vector3(qPoint.x, qPoint.y, qPoint.z);
                
                candidates.push({
                    point: qVec,
                    type: SnapType.QUADRANT,
                    target: circle,
                    feature: q.name,
                    distance: point.distanceTo(qVec),
                    priority: 8
                });
            });
        }
        
        // Nearest point on circle
        if (this.settings.nearestEnabled) {
            const toCenter = point.clone().sub(center);
            if (toCenter.length() > 0) {
                const nearest = center.clone().add(
                    toCenter.normalize().multiplyScalar(circle.radius)
                );
                
                candidates.push({
                    point: nearest,
                    type: SnapType.NEAREST,
                    target: circle,
                    feature: 'circumference',
                    distance: point.distanceTo(nearest),
                    priority: 5
                });
            }
        }
        
        // Tangent (if drawing from external point)
        if (this.settings.tangentEnabled) {
            const distToCenter = point.distanceTo(center);
            if (distToCenter > circle.radius) {
                const tangents = this.calculateTangentPoints(point, center, circle.radius);
                
                tangents.forEach((t, index) => {
                    candidates.push({
                        point: t,
                        type: SnapType.TANGENT,
                        target: circle,
                        feature: `tangent${index + 1}`,
                        distance: point.distanceTo(t),
                        priority: 7
                    });
                });
            }
        }
        
        return candidates;
    }

    /**
     * Get arc snap candidates
     */
    private getArcSnapCandidates(point: Vector3, arc: Arc): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        const center = new Vector3(arc.center.x, arc.center.y, arc.center.z);
        
        // Center
        if (this.settings.centerEnabled) {
            candidates.push({
                point: center,
                type: SnapType.CENTER,
                target: arc,
                feature: 'center',
                distance: point.distanceTo(center),
                priority: 10
            });
        }
        
        // Endpoints
        if (this.settings.endpointEnabled) {
            const start = arc.getStartPoint();
            const end = arc.getEndPoint();
            
            candidates.push({
                point: new Vector3(start.x, start.y, start.z),
                type: SnapType.ENDPOINT,
                target: arc,
                feature: 'start',
                distance: point.distanceTo(new Vector3(start.x, start.y, start.z)),
                priority: 10
            });
            
            candidates.push({
                point: new Vector3(end.x, end.y, end.z),
                type: SnapType.ENDPOINT,
                target: arc,
                feature: 'end',
                distance: point.distanceTo(new Vector3(end.x, end.y, end.z)),
                priority: 10
            });
        }
        
        // Midpoint
        if (this.settings.midpointEnabled) {
            const mid = arc.getMidPoint();
            const midVec = new Vector3(mid.x, mid.y, mid.z);
            
            candidates.push({
                point: midVec,
                type: SnapType.MIDPOINT,
                target: arc,
                feature: 'midpoint',
                distance: point.distanceTo(midVec),
                priority: 8
            });
        }
        
        // Nearest point on arc
        if (this.settings.nearestEnabled) {
            const toCenter = point.clone().sub(center);
            const angle = Math.atan2(toCenter.y, toCenter.x);
            
            if (arc.containsAngle(angle)) {
                const nearest = center.clone().add(
                    toCenter.normalize().multiplyScalar(arc.radius)
                );
                
                candidates.push({
                    point: nearest,
                    type: SnapType.NEAREST,
                    target: arc,
                    feature: 'arc',
                    distance: point.distanceTo(nearest),
                    priority: 5
                });
            }
        }
        
        return candidates;
    }

    /**
     * Get polyline snap candidates
     */
    private getPolylineSnapCandidates(point: Vector3, polyline: Polyline): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        const vertices = polyline.vertices;
        
        // Vertices/Nodes
        if (this.settings.nodeEnabled) {
            vertices.forEach((vertex, index) => {
                const vertexVec = new Vector3(vertex.x, vertex.y, vertex.z);
                
                candidates.push({
                    point: vertexVec,
                    type: SnapType.NODE,
                    target: polyline,
                    feature: `vertex${index}`,
                    distance: point.distanceTo(vertexVec),
                    priority: 10
                });
            });
        }
        
        // Segment midpoints
        if (this.settings.midpointEnabled) {
            for (let i = 0; i < vertices.length - 1; i++) {
                const v1 = vertices[i];
                const v2 = vertices[i + 1];
                const mid = new Vector3(
                    (v1.x + v2.x) / 2,
                    (v1.y + v2.y) / 2,
                    (v1.z + v2.z) / 2
                );
                
                candidates.push({
                    point: mid,
                    type: SnapType.MIDPOINT,
                    target: polyline,
                    feature: `segment${i}`,
                    distance: point.distanceTo(mid),
                    priority: 8
                });
            }
            
            // Closing segment for closed polylines
            if (polyline.isClosed && vertices.length > 2) {
                const v1 = vertices[vertices.length - 1];
                const v2 = vertices[0];
                const mid = new Vector3(
                    (v1.x + v2.x) / 2,
                    (v1.y + v2.y) / 2,
                    (v1.z + v2.z) / 2
                );
                
                candidates.push({
                    point: mid,
                    type: SnapType.MIDPOINT,
                    target: polyline,
                    feature: 'closing',
                    distance: point.distanceTo(mid),
                    priority: 8
                });
            }
        }
        
        // Center (for closed polylines)
        if (this.settings.centerEnabled && polyline.isClosed) {
            const centroid = polyline.getCentroid();
            const centroidVec = new Vector3(centroid.x, centroid.y, centroid.z);
            
            candidates.push({
                point: centroidVec,
                type: SnapType.CENTER,
                target: polyline,
                feature: 'centroid',
                distance: point.distanceTo(centroidVec),
                priority: 7
            });
        }
        
        return candidates;
    }

    /**
     * Get angle snap candidates
     */
    private getAngleSnapCandidates(point: Vector3, referencePoint: Vector3): SnapCandidate[] {
        const candidates: SnapCandidate[] = [];
        const vector = point.clone().sub(referencePoint);
        const distance = vector.length();
        
        if (distance < 0.001) return candidates;
        
        const currentAngle = Math.atan2(vector.y, vector.x);
        const currentAngleDeg = currentAngle * 180 / Math.PI;
        
        // Standard angles
        const snapAngles: number[] = [...Constants.SNAP.ANGLE_SNAP_DEGREES];
        const increment = this.settings.angleIncrement;
        
        // Add custom increment angles
        for (let angle = 0; angle < 360; angle += increment) {
            if (!snapAngles.includes(angle)) {
                snapAngles.push(angle);
            }
        }
        
        snapAngles.forEach(targetAngle => {
            const diff = this.normalizeAngle(currentAngleDeg - targetAngle);
            
            if (Math.abs(diff) < Constants.SNAP.ANGLE_TOLERANCE) {
                const targetAngleRad = targetAngle * Math.PI / 180;
                const snapPoint = referencePoint.clone().add(new Vector3(
                    Math.cos(targetAngleRad) * distance,
                    Math.sin(targetAngleRad) * distance,
                    point.z
                ));
                
                candidates.push({
                    point: snapPoint,
                    type: SnapType.ANGLE,
                    feature: `${targetAngle}Â°`,
                    distance: point.distanceTo(snapPoint),
                    priority: 6
                });
            }
        });
        
        return candidates;
    }

    /**
     * Get grid snap candidate
     */
    private getGridSnapCandidate(point: Vector3): SnapCandidate {
        const snapped = new Vector3(
            Math.round(point.x / this.settings.gridSize) * this.settings.gridSize,
            Math.round(point.y / this.settings.gridSize) * this.settings.gridSize,
            point.z
        );
        
        return {
            point: snapped,
            type: SnapType.GRID,
            feature: 'grid',
            distance: point.distanceTo(snapped),
            priority: 1
        };
    }

    /**
     * Snap to grid
     */
    private snapToGrid(point: Vector3): SnapResult {
        const candidate = this.getGridSnapCandidate(point);
        
        return {
            point: candidate.point,
            snapped: true,
            type: SnapType.GRID,
            distance: candidate.distance
        };
    }

    /**
     * Calculate tangent points from external point to circle
     */
    private calculateTangentPoints(external: Vector3, center: Vector3, radius: number): Vector3[] {
        const d = external.distanceTo(center);
        if (d <= radius) return [];
        
        const theta = Math.asin(radius / d);
        const baseAngle = Math.atan2(external.y - center.y, external.x - center.x);
        
        const angle1 = baseAngle + theta;
        const angle2 = baseAngle - theta;
        
        const tangentDist = Math.sqrt(d * d - radius * radius);
        
        return [
            new Vector3(
                center.x + radius * Math.cos(angle1 + Math.PI / 2),
                center.y + radius * Math.sin(angle1 + Math.PI / 2),
                center.z
            ),
            new Vector3(
                center.x + radius * Math.cos(angle2 - Math.PI / 2),
                center.y + radius * Math.sin(angle2 - Math.PI / 2),
                center.z
            )
        ];
    }

    /**
     * Normalize angle to [-180, 180]
     */
    private normalizeAngle(angle: number): number {
        while (angle > 180) angle -= 360;
        while (angle < -180) angle += 360;
        return angle;
    }

    // ==================== Public API ====================

    /**
     * Update settings
     */
    public updateSettings(settings: Partial<SnapSettings>): void {
        Object.assign(this.settings, settings);
    }

    /**
     * Get current settings
     */
    public getSettings(): SnapSettings {
        return { ...this.settings };
    }

    /**
     * Set grid size
     */
    public setGridSize(size: number): void {
        this.settings.gridSize = Math.max(
            Constants.GRID.MIN_SIZE,
            Math.min(Constants.GRID.MAX_SIZE, size)
        );
    }

    /**
     * Set grid enabled
     */
    public setGridEnabled(enabled: boolean): void {
        this.settings.gridEnabled = enabled;
    }

    /**
     * Toggle snap type
     */
    public toggleSnapType(type: SnapType, enabled?: boolean): void {
        const settingMap: Record<SnapType, keyof SnapSettings> = {
            [SnapType.GRID]: 'gridEnabled',
            [SnapType.ENDPOINT]: 'endpointEnabled',
            [SnapType.MIDPOINT]: 'midpointEnabled',
            [SnapType.CENTER]: 'centerEnabled',
            [SnapType.INTERSECTION]: 'intersectionEnabled',
            [SnapType.PERPENDICULAR]: 'perpendicularEnabled',
            [SnapType.TANGENT]: 'tangentEnabled',
            [SnapType.NEAREST]: 'nearestEnabled',
            [SnapType.QUADRANT]: 'quadrantEnabled',
            [SnapType.NODE]: 'nodeEnabled',
            [SnapType.EXTENSION]: 'extensionEnabled',
            [SnapType.ANGLE]: 'angleEnabled',
            [SnapType.PARALLEL]: 'angleEnabled'
        };
        
        const setting = settingMap[type];
        if (setting && typeof this.settings[setting] === 'boolean') {
            (this.settings as any)[setting] = enabled ?? !this.settings[setting];
        }
    }

    /**
     * Get snap info string
     */
    public getSnapInfo(snapResult: SnapResult): string {
        if (!snapResult.snapped) return '';
        
        const typeLabels: Record<SnapType, string> = {
            [SnapType.GRID]: `Grid (${this.settings.gridSize}m)`,
            [SnapType.ENDPOINT]: 'Endpoint',
            [SnapType.MIDPOINT]: 'Midpoint',
            [SnapType.CENTER]: 'Center',
            [SnapType.INTERSECTION]: 'Intersection',
            [SnapType.PERPENDICULAR]: 'Perpendicular',
            [SnapType.TANGENT]: 'Tangent',
            [SnapType.NEAREST]: 'Nearest',
            [SnapType.QUADRANT]: 'Quadrant',
            [SnapType.NODE]: 'Node',
            [SnapType.EXTENSION]: 'Extension',
            [SnapType.PARALLEL]: 'Parallel',
            [SnapType.ANGLE]: snapResult.feature || 'Angle'
        };
        
        return typeLabels[snapResult.type!] || 'Snapped';
    }

    /**
     * Clear cache
     */
    public clearCache(): void {
        this.snapCache.clear();
    }
}

==== FILE: src\types\opencascade.d.ts ====

declare module 'opencascade.js' {
    const opencascade: {
        ready: Promise<void>;
        [key: string]: any;
    };
    
    export default opencascade;
}

==== FILE: src\ui\BlockPanel.ts ====



==== FILE: src\ui\CommandLine.ts ====



==== FILE: src\ui\DimensionLabel.ts ====

// Ù…ÙƒÙˆÙ† ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø¹Ø±Ø¶ Ù‚ÙŠØ§Ø³Ø§Øª Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†
export class DimensionLabel {
    private element: HTMLDivElement;
    private container: HTMLElement;
    private isPreview: boolean;

    constructor(container: HTMLElement, isPreview: boolean = false) {
        this.container = container;
        this.isPreview = isPreview;
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± HTML Ù„Ù„ØªØ³Ù…ÙŠØ©
        this.element = document.createElement('div');
        this.element.className = isPreview ? 'dimension-label preview' : 'dimension-label';
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù†ØµØ± Ù„Ù„Ø­Ø§ÙˆÙŠ
        this.container.appendChild(this.element);
    }

    // ØªØ­Ø¯ÙŠØ« Ù†Øµ Ø§Ù„ØªØ³Ù…ÙŠØ©
    setText(text: string): void {
        this.element.textContent = text;
    }

    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆØ¶Ø¹ Ø§Ù„ØªØ³Ù…ÙŠØ©
    setPosition(x: number, y: number): void {
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ù‚Ø§Ø¡ Ø§Ù„ØªØ³Ù…ÙŠØ© Ø¯Ø§Ø®Ù„ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø©
        const rect = this.element.getBoundingClientRect();
        const containerRect = this.container.getBoundingClientRect();
        
        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù…Ø¹ Ø§Ù„Ø£Ø®Ø° ÙÙŠ Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø± Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø´Ø§Ø´Ø©
        let finalX = x;
        let finalY = y;
        
        // Ù…Ù†Ø¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠÙ…Ù†
        if (x + rect.width > containerRect.width) {
            finalX = containerRect.width - rect.width - 10;
        }
        
        // Ù…Ù†Ø¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠØ³Ø±
        if (x < 10) {
            finalX = 10;
        }
        
        // Ù…Ù†Ø¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„
        if (y + rect.height > containerRect.height) {
            finalY = containerRect.height - rect.height - 10;
        }
        
        // Ù…Ù†Ø¹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰
        if (y < 10) {
            finalY = 10;
        }
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ÙˆØ¶Ø¹
        this.element.style.left = `${finalX}px`;
        this.element.style.top = `${finalY}px`;
    }

    // ØªØ­Ø¯ÙŠØ« Ø²Ø§ÙˆÙŠØ© Ø§Ù„ØªØ³Ù…ÙŠØ©
    setRotation(degrees: number): void {
        // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù„ØªÙƒÙˆÙ† Ø£ÙƒØ«Ø± Ù‚Ø§Ø¨Ù„ÙŠØ© Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©
        let rotation = degrees;
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø²Ø§ÙˆÙŠØ© ØªØ¬Ø¹Ù„ Ø§Ù„Ù†Øµ Ù…Ù‚Ù„ÙˆØ¨Ø§Ù‹ØŒ Ø§Ù‚Ù„Ø¨Ù‡Ø§ 180 Ø¯Ø±Ø¬Ø©
        if (degrees > 90 || degrees < -90) {
            rotation = degrees + 180;
        }
        
        // Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©ØŒ Ø­Ø¯Ø¯ Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø¨ÙŠÙ† -45 Ùˆ 45 Ø¯Ø±Ø¬Ø©
        if (rotation > 45) {
            rotation = 45;
        } else if (rotation < -45) {
            rotation = -45;
        }
        
        this.element.style.transform = `rotate(${rotation}deg)`;
    }

    // Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ØªØ³Ù…ÙŠØ©
    show(): void {
        this.element.style.display = 'block';
    }

    // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„ØªØ³Ù…ÙŠØ©
    hide(): void {
        this.element.style.display = 'none';
    }

    // ØªØ­Ø¯ÙŠØ« Ù†Ù…Ø· Ø§Ù„ØªØ³Ù…ÙŠØ©
    setStyle(style: 'normal' | 'highlighted' | 'selected'): void {
        // Ø¥Ø²Ø§Ù„Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        this.element.classList.remove('highlighted', 'selected');
        
        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯
        if (style !== 'normal') {
            this.element.classList.add(style);
        }
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø´ÙØ§ÙÙŠØ©
    setOpacity(opacity: number): void {
        this.element.style.opacity = opacity.toString();
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ù†ØµØ±
    getBounds(): DOMRect {
        return this.element.getBoundingClientRect();
    }

    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ³Ù…ÙŠØ© Ù…Ù† DOM
    remove(): void {
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
    }

    // ØªØ­Ø¯ÙŠØ« z-index Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ø±Ø¶
    setZIndex(zIndex: number): void {
        this.element.style.zIndex = zIndex.toString();
    }

    // Ø¥Ø¶Ø§ÙØ© Ø£Ùˆ Ø¥Ø²Ø§Ù„Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¸Ù„
    setShadow(enabled: boolean): void {
        if (enabled) {
            this.element.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.15)';
        } else {
            this.element.style.boxShadow = 'none';
        }
    }

    // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©
    setBackgroundColor(color: string): void {
        this.element.style.backgroundColor = color;
    }

    // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø§Ù„Ù†Øµ
    setTextColor(color: string): void {
        this.element.style.color = color;
    }

    // Ø¥Ø¶Ø§ÙØ© Ø±Ø³Ø§Ù„Ø© ØªÙ„Ù…ÙŠØ­ (tooltip)
    setTooltip(text: string): void {
        this.element.title = text;
    }

    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„ØªØ³Ù…ÙŠØ© Ø¨Ø³Ù„Ø§Ø³Ø©
    animateToPosition(x: number, y: number, duration: number = 300): void {
        this.element.style.transition = `all ${duration}ms ease-out`;
        this.setPosition(x, y);
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ÙŠ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø­Ø±ÙƒØ©
        setTimeout(() => {
            this.element.style.transition = '';
        }, duration);
    }
}

==== FILE: src\ui\index.ts ====



==== FILE: src\ui\InfoBar.ts ====



==== FILE: src\ui\LayerPanel.ts ====



==== FILE: src\ui\ModalManager.ts ====



==== FILE: src\ui\PropertyEditor.ts ====



==== FILE: src\ui\Toolbar.ts ====

/**
 * Toolbar - Advanced UI Toolbar System
 * Manages drawing tools and UI controls
 */

import { DrawLineTool, LineDrawMode } from '../drawing_tools/DrawLineTool';
import { DrawCircleTool, CircleDrawMode } from '../drawing_tools/DrawCircleTool';
import { DrawArcTool, ArcDrawMode } from '../drawing_tools/DrawArcTool';
import { DrawPolylineTool, PolylineDrawMode } from '../drawing_tools/DrawPolylineTool';
import { AbstractDrawTool } from '../drawing_tools/AbstractDrawTool';
import { Logger } from '../core/Logger';

// Tool definition interface
export interface ToolDefinition {
    id: string;
    name: string;
    icon: string;
    category: 'draw' | 'edit' | 'measure' | 'view';
    shortcut?: string;
    description: string;
    subTools?: ToolDefinition[];
}

// Toolbar button interface
export interface ToolbarButton {
    element: HTMLElement;
    tool: ToolDefinition;
    isActive: boolean;
}

// Event listener type
type ToolbarEventListener = (event: ToolbarEvent) => void;

// Toolbar event
export interface ToolbarEvent {
    type: string;
    toolId: string;
    previousToolId?: string;
    data?: any;
}

/**
 * Toolbar class - manages UI toolbar and tool selection
 */
export class Toolbar {
    private container: HTMLElement;
    private logger: Logger;
    
    // Tool definitions
    private tools: Map<string, ToolDefinition> = new Map();
    private toolButtons: Map<string, ToolbarButton> = new Map();
    
    // Current state
    private activeToolId: string = 'select';
    private previousToolId: string = 'select';
    
    // Event management
    private eventListeners: Map<string, ToolbarEventListener[]> = new Map();
    
    // Tool groups
    private toolGroups: Map<string, HTMLElement> = new Map();

    constructor(containerId: string) {
        const container = document.getElementById(containerId);
        if (!container) {
            throw new Error(`Toolbar container not found: ${containerId}`);
        }
        
        this.container = container;
        this.logger = Logger.getInstance();
        
        this.initializeTools();
        this.createToolbarUI();
        this.setupEventHandlers();
    }

    /**
     * Initialize tool definitions
     */
    private initializeTools(): void {
        // Drawing tools
        const drawingTools: ToolDefinition[] = [
            {
                id: 'select',
                name: 'Select',
                icon: 'cursor',
                category: 'edit',
                shortcut: 'S',
                description: 'Select and manipulate objects'
            },
            {
                id: 'line',
                name: 'Line',
                icon: 'line',
                category: 'draw',
                shortcut: 'L',
                description: 'Draw straight lines',
                subTools: [
                    {
                        id: 'line-single',
                        name: 'Single Line',
                        icon: 'line',
                        category: 'draw',
                        description: 'Draw a single line'
                    },
                    {
                        id: 'line-continuous',
                        name: 'Continuous Lines',
                        icon: 'polyline',
                        category: 'draw',
                        description: 'Draw continuous lines'
                    },
                    {
                        id: 'line-construction',
                        name: 'Construction Line',
                        icon: 'construction',
                        category: 'draw',
                        description: 'Draw construction lines'
                    }
                ]
            },
            {
                id: 'circle',
                name: 'Circle',
                icon: 'circle',
                category: 'draw',
                shortcut: 'C',
                description: 'Draw circles',
                subTools: [
                    {
                        id: 'circle-center-radius',
                        name: 'Center, Radius',
                        icon: 'circle-center',
                        category: 'draw',
                        description: 'Draw circle from center and radius'
                    },
                    {
                        id: 'circle-two-points',
                        name: 'Two Points',
                        icon: 'circle-diameter',
                        category: 'draw',
                        description: 'Draw circle from two points on diameter'
                    },
                    {
                        id: 'circle-three-points',
                        name: 'Three Points',
                        icon: 'circle-3p',
                        category: 'draw',
                        description: 'Draw circle through three points'
                    }
                ]
            },
            {
                id: 'arc',
                name: 'Arc',
                icon: 'arc',
                category: 'draw',
                shortcut: 'A',
                description: 'Draw arcs',
                subTools: [
                    {
                        id: 'arc-three-points',
                        name: 'Three Points',
                        icon: 'arc-3p',
                        category: 'draw',
                        description: 'Draw arc through three points'
                    },
                    {
                        id: 'arc-center-start-end',
                        name: 'Center, Start, End',
                        icon: 'arc-center',
                        category: 'draw',
                        description: 'Draw arc from center, start and end'
                    }
                ]
            },
            {
                id: 'polyline',
                name: 'Polyline',
                icon: 'polyline',
                category: 'draw',
                shortcut: 'P',
                description: 'Draw polylines',
                subTools: [
                    {
                        id: 'polyline-open',
                        name: 'Open Polyline',
                        icon: 'polyline-open',
                        category: 'draw',
                        description: 'Draw open polyline'
                    },
                    {
                        id: 'polyline-closed',
                        name: 'Closed Polyline',
                        icon: 'polygon',
                        category: 'draw',
                        description: 'Draw closed polyline (polygon)'
                    },
                    {
                        id: 'polyline-rectangle',
                        name: 'Rectangle',
                        icon: 'rectangle',
                        category: 'draw',
                        shortcut: 'R',
                        description: 'Draw rectangle'
                    },
                    {
                        id: 'polyline-polygon',
                        name: 'Regular Polygon',
                        icon: 'hexagon',
                        category: 'draw',
                        description: 'Draw regular polygon'
                    }
                ]
            }
        ];

        // Register all tools
        drawingTools.forEach(tool => {
            this.registerTool(tool);
            if (tool.subTools) {
                tool.subTools.forEach(subTool => {
                    this.registerTool(subTool);
                });
            }
        });
    }

    /**
     * Register a tool
     */
    private registerTool(tool: ToolDefinition): void {
        this.tools.set(tool.id, tool);
    }

    /**
     * Create toolbar UI
     */
    private createToolbarUI(): void {
        // Clear existing content
        this.container.innerHTML = '';
        
        // Create tool groups
        const categories = ['draw', 'edit', 'measure', 'view'];
        
        categories.forEach(category => {
            const group = this.createToolGroup(category);
            this.toolGroups.set(category, group);
            this.container.appendChild(group);
        });
        
        // Add tools to groups
        this.tools.forEach(tool => {
            if (!tool.id.includes('-')) { // Main tools only
                const button = this.createToolButton(tool);
                const group = this.toolGroups.get(tool.category);
                if (group) {
                    group.appendChild(button);
                }
            }
        });
        
        // Add separators and special controls
        this.addSpecialControls();
    }

    /**
     * Create tool group
     */
    private createToolGroup(category: string): HTMLElement {
        const group = document.createElement('div');
        group.className = 'toolbar-group';
        group.dataset.category = category;
        
        // Add group label
        const label = document.createElement('div');
        label.className = 'toolbar-group-label';
        label.textContent = this.getCategoryLabel(category);
        group.appendChild(label);
        
        return group;
    }

    /**
     * Create tool button
     */
    private createToolButton(tool: ToolDefinition): HTMLElement {
        const button = document.createElement('button');
        button.className = 'toolbar-btn';
        button.id = `tool-${tool.id}`;
        button.title = `${tool.description}${tool.shortcut ? ` (${tool.shortcut})` : ''}`;
        
        // Add icon
        const icon = this.createToolIcon(tool.icon);
        button.appendChild(icon);
        
        // Add label
        const label = document.createElement('span');
        label.className = 'toolbar-btn-label';
        label.textContent = tool.name;
        button.appendChild(label);
        
        // Add dropdown arrow if has sub-tools
        if (tool.subTools && tool.subTools.length > 0) {
            const arrow = document.createElement('span');
            arrow.className = 'toolbar-btn-arrow';
            arrow.innerHTML = 'â–¼';
            button.appendChild(arrow);
            
            // Create dropdown menu
            const dropdown = this.createDropdownMenu(tool.subTools);
            button.appendChild(dropdown);
        }
        
        // Store button reference
        this.toolButtons.set(tool.id, {
            element: button,
            tool: tool,
            isActive: false
        });
        
        // Add click handler
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.handleToolClick(tool.id);
        });
        
        // Add right-click handler for sub-tools
        if (tool.subTools) {
            button.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                this.showDropdownMenu(button);
            });
        }
        
        return button;
    }

    /**
     * Create tool icon
     */
    private createToolIcon(iconName: string): HTMLElement {
        const icon = document.createElement('i');
        icon.className = `toolbar-icon icon-${iconName}`;
        
        // Use SVG icons based on name
        switch (iconName) {
            case 'cursor':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M4 4l7 7-7 7z"/></svg>';
                break;
            case 'line':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><line x1="5" y1="19" x2="19" y2="5"/></svg>';
                break;
            case 'circle':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/></svg>';
                break;
            case 'arc':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2 A 10 10 0 0 0 2 12"/></svg>';
                break;
            case 'polyline':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><polyline points="4 17 10 11 14 15 20 9"/></svg>';
                break;
            case 'rectangle':
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><rect x="3" y="3" width="18" height="18"/></svg>';
                break;
            default:
                icon.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="2"/></svg>';
        }
        
        return icon;
    }

    /**
     * Create dropdown menu for sub-tools
     */
    private createDropdownMenu(subTools: ToolDefinition[]): HTMLElement {
        const dropdown = document.createElement('div');
        dropdown.className = 'toolbar-dropdown';
        
        subTools.forEach(subTool => {
            const item = document.createElement('div');
            item.className = 'toolbar-dropdown-item';
            item.dataset.toolId = subTool.id;
            
            const icon = this.createToolIcon(subTool.icon);
            item.appendChild(icon);
            
            const label = document.createElement('span');
            label.textContent = subTool.name;
            item.appendChild(label);
            
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                this.handleToolClick(subTool.id);
                this.hideAllDropdowns();
            });
            
            dropdown.appendChild(item);
        });
        
        return dropdown;
    }

    /**
     * Add special controls (separators, etc.)
     */
    private addSpecialControls(): void {
        // Add separators between groups
        const groups = Array.from(this.toolGroups.values());
        for (let i = 1; i < groups.length; i++) {
            const separator = document.createElement('div');
            separator.className = 'toolbar-separator';
            this.container.insertBefore(separator, groups[i]);
        }
    }

    /**
     * Setup event handlers
     */
    private setupEventHandlers(): void {
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
                return;
            }
            
            // Check for tool shortcuts
            this.tools.forEach(tool => {
                if (tool.shortcut && e.key.toUpperCase() === tool.shortcut) {
                    e.preventDefault();
                    this.setActiveTool(tool.id);
                }
            });
        });
        
        // Click outside to close dropdowns
        document.addEventListener('click', () => {
            this.hideAllDropdowns();
        });
    }

    /**
     * Handle tool button click
     */
    private handleToolClick(toolId: string): void {
        const button = this.toolButtons.get(toolId);
        if (!button) return;
        
        // If has sub-tools, show dropdown
        if (button.tool.subTools && button.tool.subTools.length > 0) {
            this.toggleDropdown(button.element);
        } else {
            this.setActiveTool(toolId);
        }
    }

    /**
     * Show dropdown menu
     */
    private showDropdownMenu(button: HTMLElement): void {
        this.hideAllDropdowns();
        button.classList.add('show-dropdown');
    }

    /**
     * Toggle dropdown menu
     */
    private toggleDropdown(button: HTMLElement): void {
        if (button.classList.contains('show-dropdown')) {
            button.classList.remove('show-dropdown');
        } else {
            this.hideAllDropdowns();
            button.classList.add('show-dropdown');
        }
    }

    /**
     * Hide all dropdown menus
     */
    private hideAllDropdowns(): void {
        this.toolButtons.forEach(button => {
            button.element.classList.remove('show-dropdown');
        });
    }

    /**
     * Set active tool
     */
    public setActiveTool(toolId: string): void {
        if (toolId === this.activeToolId) return;
        
        const tool = this.tools.get(toolId);
        if (!tool) {
            this.logger.warn(`Tool not found: ${toolId}`);
            return;
        }
        
        // Store previous tool
        this.previousToolId = this.activeToolId;
        
        // Update UI
        this.updateToolButtons(toolId);
        
        // Update active tool
        this.activeToolId = toolId;
        
        // Emit event
        this.emit({
            type: 'toolChanged',
            toolId: toolId,
            previousToolId: this.previousToolId,
            data: { tool }
        });
        
        this.logger.info(`Active tool changed to: ${tool.name}`);
    }

    /**
     * Update tool button states
     */
    private updateToolButtons(activeToolId: string): void {
        this.toolButtons.forEach((button, toolId) => {
            const isActive = toolId === activeToolId || 
                           (button.tool.subTools?.some(st => st.id === activeToolId) ?? false);
            
            button.element.classList.toggle('active', isActive);
            button.isActive = isActive;
        });
    }

    /**
     * Get category label
     */
    private getCategoryLabel(category: string): string {
        const labels: Record<string, string> = {
            'draw': 'Drawing',
            'edit': 'Editing',
            'measure': 'Measure',
            'view': 'View'
        };
        
        return labels[category] || category;
    }

    // ==================== Public API ====================

    /**
     * Get active tool ID
     */
    public getActiveTool(): string {
        return this.activeToolId;
    }

    /**
     * Get tool definition
     */
    public getTool(toolId: string): ToolDefinition | undefined {
        return this.tools.get(toolId);
    }

    /**
     * Enable/disable tool
     */
    public setToolEnabled(toolId: string, enabled: boolean): void {
        const button = this.toolButtons.get(toolId);
        if (button) {
            (button.element as HTMLButtonElement).disabled = !enabled;
            button.element.classList.toggle('disabled', !enabled);
        }
    }

    /**
     * Add custom tool
     */
    public addTool(tool: ToolDefinition, groupId?: string): void {
        this.registerTool(tool);
        
        const button = this.createToolButton(tool);
        const group = groupId ? this.toolGroups.get(groupId) : this.toolGroups.get(tool.category);
        
        if (group) {
            group.appendChild(button);
        }
    }

    /**
     * Remove tool
     */
    public removeTool(toolId: string): void {
        const button = this.toolButtons.get(toolId);
        if (button) {
            button.element.remove();
            this.toolButtons.delete(toolId);
            this.tools.delete(toolId);
        }
    }

    // ==================== Event System ====================

    /**
     * Add event listener
     */
    public on(event: string, listener: ToolbarEventListener): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event)!.push(listener);
    }

    /**
     * Remove event listener
     */
    public off(event: string, listener: ToolbarEventListener): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            const index = listeners.indexOf(listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
    }

    /**
     * Emit event
     */
    private emit(event: ToolbarEvent): void {
        const listeners = this.eventListeners.get(event.type);
        if (listeners) {
            listeners.forEach(listener => {
                try {
                    listener(event);
                } catch (error) {
                    this.logger.error(`Error in toolbar event listener:`, error);
                }
            });
        }
    }

    /**
     * Dispose
     */
    public dispose(): void {
        this.eventListeners.clear();
        this.toolButtons.clear();
        this.tools.clear();
        this.toolGroups.clear();
        this.container.innerHTML = '';
    }
}

==== FILE: src\utils\MathUtils.ts ====

import { Vector3, Vector2 } from 'three';

// Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ù…Ø´Ø±ÙˆØ¹
export class MathUtils {
    
    // ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø¯Ø±Ø¬Ø§Øª Ø¥Ù„Ù‰ Ø±Ø§Ø¯ÙŠØ§Ù†
    static degToRad(degrees: number): number {
        return degrees * (Math.PI / 180);
    }

    // ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø±Ø§Ø¯ÙŠØ§Ù† Ø¥Ù„Ù‰ Ø¯Ø±Ø¬Ø§Øª
    static radToDeg(radians: number): number {
        return radians * (180 / Math.PI);
    }

    // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù„ØªÙƒÙˆÙ† Ø¨ÙŠÙ† 0 Ùˆ 360 Ø¯Ø±Ø¬Ø©
    static normalizeAngleDegrees(degrees: number): number {
        let angle = degrees % 360;
        if (angle < 0) angle += 360;
        return angle;
    }

    // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ù„ØªÙƒÙˆÙ† Ø¨ÙŠÙ† -180 Ùˆ 180 Ø¯Ø±Ø¬Ø©
    static normalizeAngleDegreesSymmetric(degrees: number): number {
        let angle = degrees % 360;
        if (angle > 180) angle -= 360;
        if (angle < -180) angle += 360;
        return angle;
    }

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ù†Ù‚Ø·ØªÙŠÙ† ÙÙŠ 2D
    static distance2D(p1: Vector2, p2: Vector2): number {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ù†Ù‚Ø·ØªÙŠÙ† ÙÙŠ 3D
    static distance3D(p1: Vector3, p2: Vector3): number {
        return p1.distanceTo(p2);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ³Ø§ÙˆÙŠ Ø±Ù‚Ù…ÙŠÙ† Ù…Ø¹ Ù‡Ø§Ù…Ø´ Ø®Ø·Ø£
    static approximatelyEqual(a: number, b: number, epsilon: number = 0.001): boolean {
        return Math.abs(a - b) < epsilon;
    }

    // ØªÙ‚ÙŠÙŠØ¯ Ù‚ÙŠÙ…Ø© Ø¨ÙŠÙ† Ø­Ø¯ Ø£Ø¯Ù†Ù‰ ÙˆØ£Ø¹Ù„Ù‰
    static clamp(value: number, min: number, max: number): number {
        return Math.max(min, Math.min(max, value));
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆÙ‚ÙˆØ¹ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ…
    static isPointOnLine(
        point: Vector3,
        lineStart: Vector3,
        lineEnd: Vector3,
        tolerance: number = 0.1
    ): boolean {
        const d1 = point.distanceTo(lineStart);
        const d2 = point.distanceTo(lineEnd);
        const lineLength = lineStart.distanceTo(lineEnd);
        
        return Math.abs(d1 + d2 - lineLength) < tolerance;
    }

    // Ø­Ø³Ø§Ø¨ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø®Ø· Ù…Ø³ØªÙ‚ÙŠÙ… Ù…Ù† Ù†Ù‚Ø·Ø© Ù…Ø¹ÙŠÙ†Ø©
    static closestPointOnLine(
        point: Vector3,
        lineStart: Vector3,
        lineEnd: Vector3
    ): Vector3 {
        const lineVector = new Vector3().subVectors(lineEnd, lineStart);
        const pointVector = new Vector3().subVectors(point, lineStart);
        
        const lineLength = lineVector.length();
        if (lineLength === 0) return lineStart.clone();
        
        const lineDirection = lineVector.normalize();
        const projectionLength = pointVector.dot(lineDirection);
        
        // ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„Ù†Ù‚Ø·Ø© Ù„ØªÙƒÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø·
        const t = MathUtils.clamp(projectionLength / lineLength, 0, 1);
        
        return new Vector3()
            .copy(lineStart)
            .add(lineVector.multiplyScalar(t));
    }

    // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø­Ø© Ù…Ø¶Ù„Ø¹ Ù…Ù† Ù†Ù‚Ø§Ø·Ù‡
    static calculatePolygonArea(points: Vector3[]): number {
        if (points.length < 3) return 0;
        
        let area = 0;
        const n = points.length;
        
        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            area += points[i].x * points[j].y;
            area -= points[j].x * points[i].y;
        }
        
        return Math.abs(area) / 2;
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ‚Ø§Ø·Ø¹ Ø®Ø·ÙŠÙ†
    static linesIntersect(
        line1Start: Vector2,
        line1End: Vector2,
        line2Start: Vector2,
        line2End: Vector2
    ): { intersects: boolean; point?: Vector2 } {
        const x1 = line1Start.x;
        const y1 = line1Start.y;
        const x2 = line1End.x;
        const y2 = line1End.y;
        const x3 = line2Start.x;
        const y3 = line2Start.y;
        const x4 = line2End.x;
        const y4 = line2End.y;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        
        if (Math.abs(denom) < 0.0001) {
            return { intersects: false };
        }
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            const intersectionX = x1 + t * (x2 - x1);
            const intersectionY = y1 + t * (y2 - y1);
            
            return {
                intersects: true,
                point: new Vector2(intersectionX, intersectionY)
            };
        }
        
        return { intersects: false };
    }

    // ØªÙ‚Ø±ÙŠØ¨ Ø±Ù‚Ù… Ù„Ø£Ù‚Ø±Ø¨ Ù…Ø¶Ø§Ø¹Ù
    static roundToNearest(value: number, nearest: number): number {
        return Math.round(value / nearest) * nearest;
    }

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø¨ÙŠÙ† Ø«Ù„Ø§Ø« Ù†Ù‚Ø§Ø·
    static angleBetweenPoints(p1: Vector3, vertex: Vector3, p2: Vector3): number {
        const v1 = new Vector3().subVectors(p1, vertex).normalize();
        const v2 = new Vector3().subVectors(p2, vertex).normalize();
        
        const dot = v1.dot(v2);
        const angle = Math.acos(MathUtils.clamp(dot, -1, 1));
        
        return angle;
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙˆÙ† Ø«Ù„Ø§Ø« Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø®Ø· ÙˆØ§Ø­Ø¯
    static areCollinear(p1: Vector3, p2: Vector3, p3: Vector3, tolerance: number = 0.001): boolean {
        // Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø«Ù„Ø« Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø«Ù„Ø§Ø«
        const area = Math.abs(
            (p2.x - p1.x) * (p3.y - p1.y) - 
            (p3.x - p1.x) * (p2.y - p1.y)
        ) / 2;
        
        return area < tolerance;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØµÙÙˆÙØ© ØªØ­ÙˆÙŠÙ„ Ù„Ù„Ø¯ÙˆØ±Ø§Ù† Ø­ÙˆÙ„ Ù†Ù‚Ø·Ø©
    static createRotationMatrix(center: Vector3, angle: number): {
        rotate: (point: Vector3) => Vector3;
    } {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        return {
            rotate: (point: Vector3): Vector3 => {
                const translated = new Vector3(
                    point.x - center.x,
                    point.y - center.y,
                    point.z
                );
                
                const rotated = new Vector3(
                    translated.x * cos - translated.y * sin,
                    translated.x * sin + translated.y * cos,
                    translated.z
                );
                
                return new Vector3(
                    rotated.x + center.x,
                    rotated.y + center.y,
                    rotated.z
                );
            }
        };
    }
}

==== FILE: src\vite-env.d.ts ====

/// <reference types="vite/client" />

declare global {
  interface Window {
    OpenCascadeModule: any;
    OpenCascade: any;
    globalOpenCascadeFactory: any;
    appState?: any;
    logger?: any;
  }
}

// Ø¥Ø¶Ø§ÙØ© ØªØ¹Ø±ÙŠÙØ§Øª Ù„Ù„Ù€ OpenCASCADE
declare module 'opencascade.js' {
  export default function OpenCascade(config?: any): Promise<any>;
}

// ØªØ¹Ø±ÙŠÙØ§Øª Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø«Ø§Ø¨ØªØ©
declare module '*.svg' {
  const content: string;
  export default content;
}

declare module '*.png' {
  const content: string;
  export default content;
}

declare module '*.jpg' {
  const content: string;
  export default content;
}

declare module '*.jpeg' {
  const content: string;
  export default content;
}

declare module '*.gif' {
  const content: string;
  export default content;
}

declare module '*.wasm' {
  const content: string;
  export default content;
}

// ØªØ¹Ø±ÙŠÙØ§Øª Ù„Ù„Ù€ Three.js extensions
declare module 'three/examples/jsm/controls/OrbitControls.js' {
  import { Camera, EventDispatcher, MOUSE, TOUCH, Vector3 } from 'three';
  
  export class OrbitControls extends EventDispatcher {
    constructor(object: Camera, domElement?: HTMLElement);
    
    object: Camera;
    domElement: HTMLElement | Document;
    
    // API
    enabled: boolean;
    target: Vector3;
    
    // Mouse buttons
    mouseButtons: { LEFT?: MOUSE; MIDDLE?: MOUSE; RIGHT?: MOUSE };
    
    // Touch fingers
    touches: { ONE?: TOUCH; TWO?: TOUCH };
    
    // Limits
    minDistance: number;
    maxDistance: number;
    minZoom: number;
    maxZoom: number;
    minPolarAngle: number;
    maxPolarAngle: number;
    minAzimuthAngle: number;
    maxAzimuthAngle: number;
    
    // Internals
    enableDamping: boolean;
    dampingFactor: number;
    enableZoom: boolean;
    zoomSpeed: number;
    enableRotate: boolean;
    rotateSpeed: number;
    enablePan: boolean;
    panSpeed: number;
    screenSpacePanning: boolean;
    keyPanSpeed: number;
    autoRotate: boolean;
    autoRotateSpeed: number;
    enableKeys: boolean;
    
    // Methods
    update(): boolean;
    saveState(): void;
    reset(): void;
    dispose(): void;
    getPolarAngle(): number;
    getAzimuthalAngle(): number;
    getDistance(): number;
    listenToKeyEvents(domElement: HTMLElement): void;
    stopListenToKeyEvents(): void;
  }
}

export {};

==== FILE: src\workers\opencascade.worker.ts ====

// src/workers/opencascade.worker.ts
export {};
